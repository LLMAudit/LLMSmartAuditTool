[2024-01-09 05:06:45 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901050645)

**Timestamp**: 20240901050645

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}

**project_name**: RealWorld_BA_124_CToken

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_124_CToken_RealWord_20240901050645.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 05:06:45 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': 'pragma solidity ^0.5.8;\n\n\n/\n * @title Compound\'s CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n /\ncontract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {\n    /\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n\n    /\n     * @notice EIP-20 token name for this token\n     /\n    string public name;\n\n    /\n     * @notice EIP-20 token symbol for this token\n     /\n    string public symbol;\n\n    /\n     * @notice EIP-20 token decimals for this token\n     */\n    uint public decimals;\n\n    /\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     /\n    uint constant borrowRateMaxMantissa = 5e14;\n\n    /\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     /\n    uint constant reserveFactorMaxMantissa = 1e18;\n\n    /\n     * @notice Administrator for this contract\n     */\n    address payable public admin;\n\n    /\n     * @notice Pending administrator for this contract\n     /\n    address payable public pendingAdmin;\n\n    /\n     * @notice Contract which oversees inter-cToken operations\n     /\n    ComptrollerInterface public comptroller;\n\n    /\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModel public interestRateModel;\n\n    /\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n     /\n    uint public initialExchangeRateMantissa;\n\n    /\n     * @notice Fraction of interest currently set aside for reserves\n     /\n    uint public reserveFactorMantissa;\n\n    /\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n\n    /\n     * @notice Accumulator of total earned interest since the opening of the market\n     /\n    uint public borrowIndex;\n\n    /\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     /\n    uint public totalBorrows;\n\n    /\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n\n    /\n     * @notice Total number of tokens in circulation\n     /\n    uint256 public totalSupply;\n\n    /\n     * @notice Official record of token balances for each account\n     /\n    mapping (address =&gt; uint256) accountTokens;\n\n    /\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;\n\n    /\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     /\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /\n     * @notice Mapping of account addresses to outstanding borrow balances\n     /\n    mapping(address =&gt; BorrowSnapshot) accountBorrows;\n\n\n    / Market Events /\n\n    /\n     * @notice Event emitted when interest is accrued\n     /\n    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /\n     * @notice Event emitted when tokens are minted\n     /\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n\n    /\n     * @notice Event emitted when tokens are redeemed\n     /\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n\n    /\n     * @notice Event emitted when underlying is borrowed\n     /\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n\n    / Admin Events /\n\n    /\n     * @notice Event emitted when pendingAdmin is changed\n     /\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     /\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /\n     * @notice Event emitted when comptroller is changed\n     /\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /\n     * @notice Event emitted when interestRateModel is changed\n     /\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n    /\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /\n     * @notice Event emitted when the reserves are reduced\n     /\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n\n    /\n     * @notice Construct a new money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     /\n    constructor(ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                uint initialExchangeRateMantissa_,\n                string memory name_,\n                string memory symbol_,\n                uint decimals_) internal {\n        // Set admin to msg.sender\n        admin = msg.sender;\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");\n\n        // Set the comptroller\n        uint err = setComptroller(comptroller);\n        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = setInterestRateModelFresh(interestRateModel);\n        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /\n     * @notice Transfer tokens tokens from src to dst by spender\n     * @dev Called by both transfer and transferFrom internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        / Fail if transfer not allowed /\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Do not allow self-transfers /\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n\n        / We call the defense hook (which checks for under-collateralization) */\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfer amount tokens from msg.sender to dst\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfer amount tokens from src to dst\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Approve spender to transfer up to amount from src\n     * @dev This will overwrite the approval amount for spender\n     *  and is subject to issues noted here\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /\n     * @notice Get the current allowance from owner for spender\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     /\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /\n     * @notice Get the token balance of the owner\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by owner\n     /\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /\n     * @notice Get the underlying balance of the owner\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by owner\n     */\n    function balanceOfUnderlying(address owner) external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR);\n        return balance;\n    }\n\n    /\n     * @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     /\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     /\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint) {\n        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque\n        return borrowRateMantissa;\n    }\n\n    /\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     /\n    function supplyRatePerBlock() external view returns (uint) {\n        / We calculate the supply rate:\n         *  underlying = totalSupply × exchangeRate\n         *  borrowsPer = totalBorrows ÷ underlying\n         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer\n         /\n        uint exchangeRateMantissa = exchangeRateStored();\n\n        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque\n\n        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);\n        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");\n\n        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);\n        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");\n\n        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));\n        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");\n\n        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);\n        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");\n\n        return supplyRate.mantissa;\n    }\n\n    /\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     /\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return totalBorrows;\n    }\n\n    /\n     * @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return borrowBalanceStored(account);\n    }\n\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     /\n    function borrowBalanceStored(address account) public view returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");\n        return result;\n    }\n\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     /\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return exchangeRateStored();\n    }\n\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     /\n    function exchangeRateStored() public view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");\n        return result;\n    }\n\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     /\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        if (totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint) {\n        return getCashPrior();\n    }\n\n    struct AccrueInterestLocalVars {\n        MathError mathErr;\n        uint opaqueErr;\n        uint borrowRateMantissa;\n        uint currentBlockNumber;\n        uint blockDelta;\n\n        Exp simpleInterestFactor;\n\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n    }\n\n    /\n      * @notice Applies accrued interest to total borrows and reserves.\n      * @dev This calculates interest accrued from the last checkpointed block\n      *      up to the current block and writes new checkpoint to storage.\n      /\n    function accrueInterest() public returns (uint) {\n        AccrueInterestLocalVars memory vars;\n\n        / Calculate the current borrow interest rate /\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");\n        if (vars.opaqueErr != 0) {\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n        }\n\n        / Remember the initial block number /\n        vars.currentBlockNumber = getBlockNumber();\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn\'t, blow up.\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = vars.currentBlockNumber;\n        borrowIndex = vars.borrowIndexNew;\n        totalBorrows = vars.totalBorrowsNew;\n        totalReserves = vars.totalReservesNew;\n\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don\'t need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n        / Fail if mint not allowed /\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n        }\n\n        MintLocalVars memory vars;\n\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n        }\n\n        /\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = mintAmount / exchangeRate\n         /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We call doTransferIn for the minter and the mintAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional mintAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n        }\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, mintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        / We call the defense hook */\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");\n\n        RedeemLocalVars memory vars;\n\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        / Fail if redeem not allowed /\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        / Fail gracefully if protocol has insufficient cash /\n        if (getCashPrior() &lt; vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        / We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return borrowFresh(msg.sender, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n        / Fail if borrow not allowed /\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        / Fail gracefully if protocol has insufficient underlying cash /\n        if (getCashPrior() &lt; borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(borrower, borrowAmount);\n        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a Borrow event /\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook /\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n        / Fail if repayBorrow not allowed /\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        / We remember the original borrowerIndex for verification purposes /\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        / We fetch the amount the borrower owes, with accumulated interest /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        / If repayAmount == -1, repayAmount = accountBorrows /\n        if (repayAmount == uint(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n        }\n\n        /\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - repayAmount\n         *  totalBorrowsNew = totalBorrows - repayAmount\n         /\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(payer, vars.repayAmount);\n        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook /\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {\n        / Fail if liquidate not allowed /\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);\n        }\n\n        / Verify cTokenCollateral market\'s block number equals current block number /\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);\n        }\n\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        / Fail if repayAmount = 0 /\n        if (repayAmount == 0) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);\n        }\n\n        / Fail if repayAmount = -1 /\n        if (repayAmount == uint(-1)) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);\n        }\n\n        / We calculate the number of collateral tokens that will be seized /\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);\n        if (amountSeizeError != 0) {\n            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);\n        }\n\n        / Fail if seizeTokens &gt; borrower collateral token balance /\n        if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {\n            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);\n        }\n\n        / Fail if repayBorrow fails /\n        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\n            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);\n        }\n\n        / Revert if seize tokens fails (since we cannot be sure of side effects) /\n        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");\n\n        / We emit a LiquidateBorrow event /\n        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);\n\n        / We call the defense hook /\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n        / Fail if seize not allowed /\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n\n        /\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         /\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n        }\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        / We write the previously calculated values into storage /\n        accountTokens[borrower] = borrowerTokensNew;\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n        / Emit a Transfer event /\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        / We call the defense hook /\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n\n    / Admin Functions /\n\n    /\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      \n      * TODO: Should we add a second arg to verify, like a checksum of newAdmin address?\n      */\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _acceptAdmin() external returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Sets a new comptroller for the market\n      * @dev Admin function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n        }\n\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), "marker method returned false");\n\n        // Set market\'s comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don\'t need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /\n      * @notice Sets a new reserve factor for the protocol (requires fresh interest accrual)\n      * @dev Admin function to set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n\n        // Verify market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don\'t need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n        Error err;\n        // totalReserves - reduceAmount\n        uint totalReservesNew;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() &lt; reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        // TODO: I\'m following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n        if (reduceAmount &gt; totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        totalReservesNew = totalReserves - reduceAmount;\n        // We checked reduceAmount &lt;= totalReserves above, so this should never revert.\n        require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // invoke doTransferOut(reduceAmount, admin)\n        err = doTransferOut(admin, reduceAmount);\n        // we revert on the failure of this command\n        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don\'t need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /\n     * @notice updates the interest rate model (requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Track the market\'s current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    / Safe Token /\n\n    /\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     /\n    function getCashPrior() internal view returns (uint);\n\n    /\n     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from from and\n     *      whether or not from has a balance of at least amount. Does NOT do a transfer.\n     /\n    function checkTransferIn(address from, uint amount) internal view returns (Error);\n\n    /\n     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checkTransferIn, this may revert due to insufficient balance or insufficient allowance.\n     *  If caller has called checkTransferIn successfully, this should not revert in normal conditions.\n     /\n    function doTransferIn(address from, uint amount) internal returns (Error);\n\n    /*\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol\'s balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol\'s balance, and verified it is &gt;= amount, this should not revert in normal conditions.\n     /\n    function doTransferOut(address payable to, uint amount) internal returns (Error);\n}'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:06:45 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:06:45 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 05:06:49 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:06:49 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 30062
completion_tokens: 1
total_tokens: 30063
cost: $-1.000000


[2024-01-09 05:06:49 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Let's

[2024-01-09 05:06:52 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: pragma solidity ^0.5.8;\n\n/\n * @title Compound\'s CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n /\ncontract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {\n    /\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n    /\n     * @notice EIP-20 token name for this token\n     /\n    string public name;\n    /\n     * @notice EIP-20 token symbol for this token\n     /\n    string public symbol;\n    /\n     * @notice EIP-20 token decimals for this token\n     */\n    uint public decimals;\n    /\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     /\n    uint constant borrowRateMaxMantissa = 5e14;\n    /\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     /\n    uint constant reserveFactorMaxMantissa = 1e18;\n    /\n     * @notice Administrator for this contract\n     */\n    address payable public admin;\n    /\n     * @notice Pending administrator for this contract\n     /\n    address payable public pendingAdmin;\n    /\n     * @notice Contract which oversees inter-cToken operations\n     /\n    ComptrollerInterface public comptroller;\n    /\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModel public interestRateModel;\n    /\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n     /\n    uint public initialExchangeRateMantissa;\n    /\n     * @notice Fraction of interest currently set aside for reserves\n     /\n    uint public reserveFactorMantissa;\n    /\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n    /\n     * @notice Accumulator of total earned interest since the opening of the market\n     /\n    uint public borrowIndex;\n    /\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     /\n    uint public totalBorrows;\n    /\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n    /\n     * @notice Total number of tokens in circulation\n     /\n    uint256 public totalSupply;\n    /\n     * @notice Official record of token balances for each account\n     /\n    mapping (address =&gt; uint256) accountTokens;\n    /\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;\n    /\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     /\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n    /\n     * @notice Mapping of account addresses to outstanding borrow balances\n     /\n    mapping(address =&gt; BorrowSnapshot) accountBorrows;\n\n    / Market Events /\n    /\n     * @notice Event emitted when interest is accrued\n     /\n    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n    /\n     * @notice Event emitted when tokens are minted\n     /\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n    /\n     * @notice Event emitted when tokens are redeemed\n     /\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n    /\n     * @notice Event emitted when underlying is borrowed\n     /\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n    /\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n    /\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n    / Admin Events /\n    /\n     * @notice Event emitted when pendingAdmin is changed\n     /\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n    /\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     /\n    event NewAdmin(address oldAdmin, address newAdmin);\n    /\n     * @notice Event emitted when comptroller is changed\n     /\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n    /\n     * @notice Event emitted when interestRateModel is changed\n     /\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n    /\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n    /\n     * @notice Event emitted when the reserves are reduced\n     /\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n    /\n     * @notice Construct a new money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     /\n    constructor(ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                uint initialExchangeRateMantissa_,\n                string memory name_,\n                string memory symbol_,\n                uint decimals_) internal {\n        // Set admin to msg.sender\n        admin = msg.sender;\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");\n        // Set the comptroller\n        uint err = setComptroller(comptroller);\n        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n        // Set the interest rate model (depends on block number / borrow index)\n        err = setInterestRateModelFresh(interestRateModel);\n        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n    /\n     * @notice Transfer tokens tokens from src to dst by spender\n     * @dev Called by both transfer and transferFrom internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        / Fail if transfer not allowed /\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n        / Do not allow self-transfers /\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n        / We call the defense hook (which checks for under-collateralization) */\n        comptroller.transferVerify(address(this), src, dst, tokens);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Transfer amount tokens from msg.sender to dst\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Transfer amount tokens from src to dst\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Approve spender to transfer up to amount from src\n     * @dev This will overwrite the approval amount for spender\n     *  and is subject to issues noted here\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n    /\n     * @notice Get the current allowance from owner for spender\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     /\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n    /\n     * @notice Get the token balance of the owner\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by owner\n     /\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n    /\n     * @notice Get the underlying balance of the owner\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by owner\n     */\n    function balanceOfUnderlying(address owner) external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR);\n        return balance;\n    }\n    /\n     * @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     /\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        MathError mErr;\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n    /\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     /\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n    /\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint) {\n        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque\n        return borrowRateMantissa;\n    }\n    /\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     /\n    function supplyRatePerBlock() external view returns (uint) {\n        / We calculate the supply rate:\n         *  underlying = totalSupply × exchangeRate\n         *  borrowsPer = totalBorrows ÷ underlying\n         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer\n         /\n        uint exchangeRateMantissa = exchangeRateStored();\n        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque\n        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);\n        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");\n        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);\n        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");\n        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));\n        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");\n        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);\n        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");\n        return supplyRate.mantissa;\n    }\n    /\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     /\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return totalBorrows;\n    }\n    /\n     * @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return borrowBalanceStored(account);\n    }\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     /\n    function borrowBalanceStored(address account) public view returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");\n        return result;\n    }\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     /\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        return (MathError.NO_ERROR, result);\n    }\n    /\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return exchangeRateStored();\n    }\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     /\n    function exchangeRateStored() public view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");\n        return result;\n    }\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     /\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        if (totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n    /\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint) {\n        return getCashPrior();\n    }\n    struct AccrueInterestLocalVars {\n        MathError mathErr;\n        uint opaqueErr;\n        uint borrowRateMantissa;\n        uint currentBlockNumber;\n        uint blockDelta;\n        Exp simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n    }\n    /\n      * @notice Applies accrued interest to total borrows and reserves.\n      * @dev This calculates interest accrued from the last checkpointed block\n      *      up to the current block and writes new checkpoint to storage.\n      /\n    function accrueInterest() public returns (uint) {\n        AccrueInterestLocalVars memory vars;\n        / Calculate the current borrow interest rate /\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");\n        if (vars.opaqueErr != 0) {\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n        }\n        / Remember the initial block number /\n        vars.currentBlockNumber = getBlockNumber();\n        / Calculate the number of blocks elapsed since the last accrual /\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn\'t, blow up.\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = vars.currentBlockNumber;\n        borrowIndex = vars.borrowIndexNew;\n        totalBorrows = vars.totalBorrowsNew;\n        totalReserves = vars.totalReservesNew;\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don\'t need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n    /\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n        / Fail if mint not allowed /\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n        }\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n        }\n        MintLocalVars memory vars;\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n        }\n        /\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = mintAmount / exchangeRate\n         /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        /\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        /\n         * We call doTransferIn for the minter and the mintAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional mintAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n        }\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, mintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n        / We call the defense hook */\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n    /\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n    /\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");\n        RedeemLocalVars memory vars;\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n            vars.redeemAmount = redeemAmountIn;\n        }\n        / Fail if redeem not allowed /\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        / Fail gracefully if protocol has insufficient cash /\n        if (getCashPrior() &lt; vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n        / We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n        return uint(Error.NO_ERROR);\n    }\n    /\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return borrowFresh(msg.sender, borrowAmount);\n    }\n    struct BorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n    /\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n        / Fail if borrow not allowed /\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n        / Fail gracefully if protocol has insufficient underlying cash /\n        if (getCashPrior() &lt; borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n        BorrowLocalVars memory vars;\n        /\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        /\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(borrower, borrowAmount);\n        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n        / We emit a Borrow event /\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n        / We call the defense hook /\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n    /\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n    /\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n        / Fail if repayBorrow not allowed /\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n        }\n        RepayBorrowLocalVars memory vars;\n        / We remember the original borrowerIndex for verification purposes /\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n        / We fetch the amount the borrower owes, with accumulated interest /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        / If repayAmount == -1, repayAmount = accountBorrows /\n        if (repayAmount == uint(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n        }\n        /\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - repayAmount\n         *  totalBorrowsNew = totalBorrows - repayAmount\n         /\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        /\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(payer, vars.repayAmount);\n        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n        / We call the defense hook /\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n        }\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n        }\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n    /\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {\n        / Fail if liquidate not allowed /\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);\n        }\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);\n        }\n        / Verify cTokenCollateral market\'s block number equals current block number /\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);\n        }\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);\n        }\n        / Fail if repayAmount = 0 /\n        if (repayAmount == 0) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);\n        }\n        / Fail if repayAmount = -1 /\n        if (repayAmount == uint(-1)) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);\n        }\n        / We calculate the number of collateral tokens that will be seized /\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);\n        if (amountSeizeError != 0) {\n            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);\n        }\n        / Fail if seizeTokens &gt; borrower collateral token balance /\n        if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {\n            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);\n        }\n        / Fail if repayBorrow fails /\n        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\n            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);\n        }\n        / Revert if seize tokens fails (since we cannot be sure of side effects) /\n        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");\n        / We emit a LiquidateBorrow event /\n        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);\n        / We call the defense hook /\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n        / Fail if seize not allowed /\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n        /\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         /\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n        }\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        / We write the previously calculated values into storage /\n        accountTokens[borrower] = borrowerTokensNew;\n        accountTokens[liquidator] = liquidatorTokensNew;\n        / Emit a Transfer event /\n        emit Transfer(borrower, liquidator, seizeTokens);\n        / We call the defense hook /\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n        return uint(Error.NO_ERROR);\n    }\n\n    / Admin Functions /\n    /\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      \n      * TODO: Should we add a second arg to verify, like a checksum of newAdmin address?\n      */\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n        return uint(Error.NO_ERROR);\n    }\n    /\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _acceptAdmin() external returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = address(0);\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n        return uint(Error.NO_ERROR);\n    }\n    /\n      * @notice Sets a new comptroller for the market\n      * @dev Admin function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n        }\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), "marker method returned false");\n        // Set market\'s comptroller to newComptroller\n        comptroller = newComptroller;\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n        return uint(Error.NO_ERROR);\n    }\n    /\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don\'t need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n    /\n      * @notice Sets a new reserve factor for the protocol (requires fresh interest accrual)\n      * @dev Admin function to set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n        // Verify market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don\'t need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n    /\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n        Error err;\n        // totalReserves - reduceAmount\n        uint totalReservesNew;\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() &lt; reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        // TODO: I\'m following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n        if (reduceAmount &gt; totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        totalReservesNew = totalReserves - reduceAmount;\n        // We checked reduceAmount &lt;= totalReserves above, so this should never revert.\n        require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n        // invoke doTransferOut(reduceAmount, admin)\n        err = doTransferOut(admin, reduceAmount);\n        // we revert on the failure of this command\n        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don\'t need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n    /\n     * @notice updates the interest rate model (requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n        // Track the market\'s current interest rate model\n        oldInterestRateModel = interestRateModel;\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n        return uint(Error.NO_ERROR);\n    }\n    / Safe Token /\n    /\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     /\n    function getCashPrior() internal view returns (uint);\n    /\n     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from from and\n     *      whether or not from has a balance of at least amount. Does NOT do a transfer.\n     /\n    function checkTransferIn(address from, uint amount) internal view returns (Error);\n    /\n     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checkTransferIn, this may revert due to insufficient balance or insufficient allowance.\n     *  If caller has called checkTransferIn successfully, this should not revert in normal conditions.\n     /\n    function doTransferIn(address from, uint amount) internal returns (Error);\n    /\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol\'s balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol\'s balance, and verified it is &gt;= amount, this should not revert in normal conditions.\n     /\n    function doTransferOut(address payable to, uint amount) internal returns (Error);\n}.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "pragma solidity ^0.5.8;\n\n/\n * @title Compound\'s CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ncontract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {\n    /\n     * @notice Indicator that this is a CToken contract (for inspection)\n     /\n    bool public constant isCToken = true;\n    /\n     * @notice EIP-20 token name for this token\n     /\n    string public name;\n    /\n     * @notice EIP-20 token symbol for this token\n     */\n    string public symbol;\n    /\n     * @notice EIP-20 token decimals for this token\n     /\n    uint public decimals;\n    /\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     /\n    uint constant borrowRateMaxMantissa = 5e14;\n    /\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     */\n    uint constant reserveFactorMaxMantissa = 1e18;\n    /\n     * @notice Administrator for this contract\n     /\n    address payable public admin;\n    /\n     * @notice Pending administrator for this contract\n     /\n    address payable public pendingAdmin;\n    /\n     * @notice Contract which oversees inter-cToken operations\n     */\n    ComptrollerInterface public comptroller;\n    /\n     * @notice Model which tells what the current interest rate should be\n     /\n    InterestRateModel public interestRateModel;\n    /\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n     /\n    uint public initialExchangeRateMantissa;\n    /\n     * @notice Fraction of interest currently set aside for reserves\n     */\n    uint public reserveFactorMantissa;\n    /\n     * @notice Block number that interest was last accrued at\n     /\n    uint public accrualBlockNumber;\n    /\n     * @notice Accumulator of total earned interest since the opening of the market\n     /\n    uint public borrowIndex;\n    /\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n    uint public totalBorrows;\n    /\n     * @notice Total amount of reserves of the underlying held in this market\n     /\n    uint public totalReserves;\n    /\n     * @notice Total number of tokens in circulation\n     /\n    uint256 public totalSupply;\n    /\n     * @notice Official record of token balances for each account\n     */\n    mapping (address =&gt; uint256) accountTokens;\n    /\n     * @notice Approved token transfer amounts on behalf of others\n     /\n    mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;\n    /\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     /\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n    /*\n     * @notice Mapping of account addresses to outstanding borrow balances\n     /\n    mapping(address =&gt; BorrowSnapshot) accountBorrows;\n\n    / Market Events /\n    /\n     * @notice Event emitted when interest is accrued\n     /\n    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n    /\n     * @notice Event emitted when tokens are minted\n     /\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n    /\n     * @notice Event emitted when tokens are redeemed\n     /\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n    /\n     * @notice Event emitted when underlying is borrowed\n     /\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n    /\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n    /\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n    / Admin Events /\n    /\n     * @notice Event emitted when pendingAdmin is changed\n     /\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n    /\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     /\n    event NewAdmin(address oldAdmin, address newAdmin);\n    /\n     * @notice Event emitted when comptroller is changed\n     /\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n    /\n     * @notice Event emitted when interestRateModel is changed\n     /\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n    /\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n    /\n     * @notice Event emitted when the reserves are reduced\n     /\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n    /\n     * @notice Construct a new money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     /\n    constructor(ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                uint initialExchangeRateMantissa_,\n                string memory name_,\n                string memory symbol_,\n                uint decimals_) internal {\n        // Set admin to msg.sender\n        admin = msg.sender;\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");\n        // Set the comptroller\n        uint err = setComptroller(comptroller);\n        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n        // Set the interest rate model (depends on block number / borrow index)\n        err = setInterestRateModelFresh(interestRateModel);\n        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n    /\n     * @notice Transfer tokens tokens from src to dst by spender\n     * @dev Called by both transfer and transferFrom internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        / Fail if transfer not allowed /\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n        / Do not allow self-transfers /\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n        / We call the defense hook (which checks for under-collateralization) */\n        comptroller.transferVerify(address(this), src, dst, tokens);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Transfer amount tokens from msg.sender to dst\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Transfer amount tokens from src to dst\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Approve spender to transfer up to amount from src\n     * @dev This will overwrite the approval amount for spender\n     *  and is subject to issues noted here\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n    /\n     * @notice Get the current allowance from owner for spender\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     /\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n    /\n     * @notice Get the token balance of the owner\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by owner\n     /\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n    /\n     * @notice Get the underlying balance of the owner\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by owner\n     */\n    function balanceOfUnderlying(address owner) external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR);\n        return balance;\n    }\n    /\n     * @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     /\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        MathError mErr;\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n    /\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     /\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n    /\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint) {\n        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque\n        return borrowRateMantissa;\n    }\n    /\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     /\n    function supplyRatePerBlock() external view returns (uint) {\n        / We calculate the supply rate:\n         *  underlying = totalSupply × exchangeRate\n         *  borrowsPer = totalBorrows ÷ underlying\n         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer\n         /\n        uint exchangeRateMantissa = exchangeRateStored();\n        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque\n        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);\n        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");\n        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);\n        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");\n        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));\n        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");\n        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);\n        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");\n        return supplyRate.mantissa;\n    }\n    /\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     /\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return totalBorrows;\n    }\n    /\n     * @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return borrowBalanceStored(account);\n    }\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     /\n    function borrowBalanceStored(address account) public view returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");\n        return result;\n    }\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     /\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        return (MathError.NO_ERROR, result);\n    }\n    /\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return exchangeRateStored();\n    }\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     /\n    function exchangeRateStored() public view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");\n        return result;\n    }\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     /\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        if (totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n    /\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint) {\n        return getCashPrior();\n    }\n    struct AccrueInterestLocalVars {\n        MathError mathErr;\n        uint opaqueErr;\n        uint borrowRateMantissa;\n        uint currentBlockNumber;\n        uint blockDelta;\n        Exp simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n    }\n    /\n      * @notice Applies accrued interest to total borrows and reserves.\n      * @dev This calculates interest accrued from the last checkpointed block\n      *      up to the current block and writes new checkpoint to storage.\n      /\n    function accrueInterest() public returns (uint) {\n        AccrueInterestLocalVars memory vars;\n        / Calculate the current borrow interest rate /\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");\n        if (vars.opaqueErr != 0) {\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n        }\n        / Remember the initial block number /\n        vars.currentBlockNumber = getBlockNumber();\n        / Calculate the number of blocks elapsed since the last accrual /\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn\'t, blow up.\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = vars.currentBlockNumber;\n        borrowIndex = vars.borrowIndexNew;\n        totalBorrows = vars.totalBorrowsNew;\n        totalReserves = vars.totalReservesNew;\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don\'t need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n    /\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n        / Fail if mint not allowed /\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n        }\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n        }\n        MintLocalVars memory vars;\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n        }\n        /\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = mintAmount / exchangeRate\n         /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        /\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        /\n         * We call doTransferIn for the minter and the mintAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional mintAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n        }\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, mintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n        / We call the defense hook */\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n    /\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n    /\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");\n        RedeemLocalVars memory vars;\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n            vars.redeemAmount = redeemAmountIn;\n        }\n        / Fail if redeem not allowed /\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        / Fail gracefully if protocol has insufficient cash /\n        if (getCashPrior() &lt; vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n        / We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n        return uint(Error.NO_ERROR);\n    }\n    /\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return borrowFresh(msg.sender, borrowAmount);\n    }\n    struct BorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n    /\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n        / Fail if borrow not allowed /\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n        / Fail gracefully if protocol has insufficient underlying cash /\n        if (getCashPrior() &lt; borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n        BorrowLocalVars memory vars;\n        /\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        /\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(borrower, borrowAmount);\n        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n        / We emit a Borrow event /\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n        / We call the defense hook /\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n    /\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n    /\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n        / Fail if repayBorrow not allowed /\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n        }\n        RepayBorrowLocalVars memory vars;\n        / We remember the original borrowerIndex for verification purposes /\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n        / We fetch the amount the borrower owes, with accumulated interest /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        / If repayAmount == -1, repayAmount = accountBorrows /\n        if (repayAmount == uint(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n        }\n        /\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - repayAmount\n         *  totalBorrowsNew = totalBorrows - repayAmount\n         /\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        /\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(payer, vars.repayAmount);\n        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n        / We call the defense hook /\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n        }\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n        }\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n    /\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {\n        / Fail if liquidate not allowed /\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);\n        }\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);\n        }\n        / Verify cTokenCollateral market\'s block number equals current block number /\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);\n        }\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);\n        }\n        / Fail if repayAmount = 0 /\n        if (repayAmount == 0) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);\n        }\n        / Fail if repayAmount = -1 /\n        if (repayAmount == uint(-1)) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);\n        }\n        / We calculate the number of collateral tokens that will be seized /\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);\n        if (amountSeizeError != 0) {\n            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);\n        }\n        / Fail if seizeTokens &gt; borrower collateral token balance /\n        if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {\n            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);\n        }\n        / Fail if repayBorrow fails /\n        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\n            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);\n        }\n        / Revert if seize tokens fails (since we cannot be sure of side effects) /\n        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");\n        / We emit a LiquidateBorrow event /\n        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);\n        / We call the defense hook /\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n        / Fail if seize not allowed /\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n        /\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         /\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n        }\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        / We write the previously calculated values into storage /\n        accountTokens[borrower] = borrowerTokensNew;\n        accountTokens[liquidator] = liquidatorTokensNew;\n        / Emit a Transfer event /\n        emit Transfer(borrower, liquidator, seizeTokens);\n        / We call the defense hook /\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n        return uint(Error.NO_ERROR);\n    }\n\n    / Admin Functions /\n    /\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      \n      * TODO: Should we add a second arg to verify, like a checksum of newAdmin address?\n      */\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n        return uint(Error.NO_ERROR);\n    }\n    /\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _acceptAdmin() external returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = address(0);\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n        return uint(Error.NO_ERROR);\n    }\n    /\n      * @notice Sets a new comptroller for the market\n      * @dev Admin function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n        }\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), "marker method returned false");\n        // Set market\'s comptroller to newComptroller\n        comptroller = newComptroller;\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n        return uint(Error.NO_ERROR);\n    }\n    /\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don\'t need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n    /\n      * @notice Sets a new reserve factor for the protocol (requires fresh interest accrual)\n      * @dev Admin function to set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n        // Verify market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don\'t need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n    /\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n        Error err;\n        // totalReserves - reduceAmount\n        uint totalReservesNew;\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() &lt; reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        // TODO: I\'m following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n        if (reduceAmount &gt; totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n        totalReservesNew = totalReserves - reduceAmount;\n        // We checked reduceAmount &lt;= totalReserves above, so this should never revert.\n        require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n        // invoke doTransferOut(reduceAmount, admin)\n        err = doTransferOut(admin, reduceAmount);\n        // we revert on the failure of this command\n        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n        return uint(Error.NO_ERROR);\n    }\n    /\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don\'t need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n    /\n     * @notice updates the interest rate model (requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n        // Track the market\'s current interest rate model\n        oldInterestRateModel = interestRateModel;\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n        return uint(Error.NO_ERROR);\n    }\n    / Safe Token /\n    /\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     /\n    function getCashPrior() internal view returns (uint);\n    /\n     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from from and\n     *      whether or not from has a balance of at least amount. Does NOT do a transfer.\n     /\n    function checkTransferIn(address from, uint amount) internal view returns (Error);\n    /\n     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checkTransferIn, this may revert due to insufficient balance or insufficient allowance.\n     *  If caller has called checkTransferIn successfully, this should not revert in normal conditions.\n     /\n    function doTransferIn(address from, uint amount) internal returns (Error);\n    /*\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol\'s balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol\'s balance, and verified it is &gt;= amount, this should not revert in normal conditions.\n     /\n    function doTransferOut(address payable to, uint amount) internal returns (Error);\n}".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:06:52 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:06:52 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.8;

/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;
    /**
     * @notice EIP-20 token name for this token
     */
    string public name;
    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;
    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;
    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;
    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;
    /**
     * @notice Administrator for this contract
     */
    address payable public admin;
    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;
    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;
    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;
    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;
    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;
    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;
    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;
    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;
    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;
    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;
    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;
    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;
    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }
    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;

    /*** Market Events ***/
    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);
    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);
    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);
    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);
    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);
    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);

    /*** Admin Events ***/
    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);
    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);
    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);
    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);
    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);
    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);

    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;
        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");
        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");
        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;
        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");
        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }
    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }
        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }
        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }
        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;
        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }
        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }
        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;
        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }
    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }
    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }
    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }
    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }
    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }
    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;
        MathError mErr;
        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }
        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }
        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }
    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }
    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }
    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();
        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque
        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");
        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");
        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");
        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");
        return supplyRate.mantissa;
    }
    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }
    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }
    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }
    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;
        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];
        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }
        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        return (MathError.NO_ERROR, result);
    }
    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }
    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }
    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;
            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }
            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }
            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }
    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }
    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;
        Exp simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }
    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;
        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }
        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();
        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.
        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;
        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }
    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }
    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }
        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }
        MintLocalVars memory vars;
        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }
        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }
        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;
        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);
        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }
    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }
    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }
    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");
        RedeemLocalVars memory vars;
        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }
        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;
            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */
            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }
            vars.redeemAmount = redeemAmountIn;
        }
        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }
        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }
        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");
        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);
        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);
        return uint(Error.NO_ERROR);
    }
    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }
    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }
    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }
        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }
        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }
        BorrowLocalVars memory vars;
        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");
        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;
        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);
        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }
    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }
    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }
    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }
        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }
        RepayBorrowLocalVars memory vars;
        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;
        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }
        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");
        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;
        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);
        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }
        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }
        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }
    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }
        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }
        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }
        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }
        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }
        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }
        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }
        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }
        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }
        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");
        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);
        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }
        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }
        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;
        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }
        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;
        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);
        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);
        return uint(Error.NO_ERROR);
    }

    /*** Admin Functions ***/
    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }
        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;
        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;
        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);
        return uint(Error.NO_ERROR);
    }
    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }
        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;
        // Store admin with value pendingAdmin
        admin = pendingAdmin;
        // Clear the pending value
        pendingAdmin = address(0);
        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);
        return uint(Error.NO_ERROR);
    }
    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }
        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");
        // Set market's comptroller to newComptroller
        comptroller = newComptroller;
        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);
        return uint(Error.NO_ERROR);
    }
    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }
    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }
        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }
        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }
    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }
        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }
        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }
        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");
        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;
        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");
        emit ReservesReduced(admin, reduceAmount, totalReservesNew);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }
    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {
        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }
        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }
        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;
        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");
        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;
        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);
        return uint(Error.NO_ERROR);
    }
    /*** Safe Token ***/
    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);
    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);
    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);
    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "pragma solidity ^0.5.8;

/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;
    /**
     * @notice EIP-20 token name for this token
     */
    string public name;
    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;
    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;
    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;
    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;
    /**
     * @notice Administrator for this contract
     */
    address payable public admin;
    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;
    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;
    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;
    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;
    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;
    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;
    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;
    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;
    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;
    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;
    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;
    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;
    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }
    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;

    /*** Market Events ***/
    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);
    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);
    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);
    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);
    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);
    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);

    /*** Admin Events ***/
    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);
    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);
    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);
    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);
    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);
    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);

    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;
        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");
        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");
        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;
        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");
        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }
    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }
        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }
        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }
        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;
        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }
        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }
        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;
        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }
    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }
    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }
    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }
    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }
    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }
    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;
        MathError mErr;
        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }
        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }
        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }
    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }
    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }
    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();
        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque
        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");
        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");
        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");
        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");
        return supplyRate.mantissa;
    }
    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }
    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }
    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }
    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;
        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];
        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }
        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        return (MathError.NO_ERROR, result);
    }
    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }
    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }
    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;
            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }
            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }
            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }
    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }
    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;
        Exp simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }
    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;
        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }
        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();
        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.
        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;
        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }
    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }
    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }
        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }
        MintLocalVars memory vars;
        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }
        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }
        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;
        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);
        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }
    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }
    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }
    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");
        RedeemLocalVars memory vars;
        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }
        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;
            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */
            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }
            vars.redeemAmount = redeemAmountIn;
        }
        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }
        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }
        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");
        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);
        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);
        return uint(Error.NO_ERROR);
    }
    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }
    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }
    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }
        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }
        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }
        BorrowLocalVars memory vars;
        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");
        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;
        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);
        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }
    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }
    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }
    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }
        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }
        RepayBorrowLocalVars memory vars;
        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;
        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }
        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");
        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;
        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);
        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }
        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }
        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }
    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }
        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }
        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }
        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }
        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }
        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }
        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }
        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }
        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }
        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");
        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);
        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }
        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }
        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;
        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }
        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;
        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);
        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);
        return uint(Error.NO_ERROR);
    }

    /*** Admin Functions ***/
    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }
        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;
        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;
        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);
        return uint(Error.NO_ERROR);
    }
    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }
        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;
        // Store admin with value pendingAdmin
        admin = pendingAdmin;
        // Clear the pending value
        pendingAdmin = address(0);
        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);
        return uint(Error.NO_ERROR);
    }
    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }
        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");
        // Set market's comptroller to newComptroller
        comptroller = newComptroller;
        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);
        return uint(Error.NO_ERROR);
    }
    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }
    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }
        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }
        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }
    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }
        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }
        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }
        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }
        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)
        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");
        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;
        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");
        emit ReservesReduced(admin, reduceAmount, totalReservesNew);
        return uint(Error.NO_ERROR);
    }
    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }
    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {
        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }
        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }
        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;
        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");
        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;
        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);
        return uint(Error.NO_ERROR);
    }
    /*** Safe Token ***/
    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);
    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);
    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);
    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 05:06:57 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:06:57 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 45148
completion_tokens: 1
total_tokens: 45149
cost: $-1.000000


[2024-01-09 05:06:57 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Security

[2024-01-09 05:06:57 INFO] **[Seminar Conclusion]**:

 Security

[2024-01-09 05:06:57 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-01-09 05:06:57 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 05:06:58 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': 'pragma solidity ^0.5.8;\n\n\n/\n * @title Compound\'s CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n /\ncontract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {\n    /\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n\n    /\n     * @notice EIP-20 token name for this token\n     /\n    string public name;\n\n    /\n     * @notice EIP-20 token symbol for this token\n     /\n    string public symbol;\n\n    /\n     * @notice EIP-20 token decimals for this token\n     */\n    uint public decimals;\n\n    /\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     /\n    uint constant borrowRateMaxMantissa = 5e14;\n\n    /\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     /\n    uint constant reserveFactorMaxMantissa = 1e18;\n\n    /\n     * @notice Administrator for this contract\n     */\n    address payable public admin;\n\n    /\n     * @notice Pending administrator for this contract\n     /\n    address payable public pendingAdmin;\n\n    /\n     * @notice Contract which oversees inter-cToken operations\n     /\n    ComptrollerInterface public comptroller;\n\n    /\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModel public interestRateModel;\n\n    /\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n     /\n    uint public initialExchangeRateMantissa;\n\n    /\n     * @notice Fraction of interest currently set aside for reserves\n     /\n    uint public reserveFactorMantissa;\n\n    /\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n\n    /\n     * @notice Accumulator of total earned interest since the opening of the market\n     /\n    uint public borrowIndex;\n\n    /\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     /\n    uint public totalBorrows;\n\n    /\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n\n    /\n     * @notice Total number of tokens in circulation\n     /\n    uint256 public totalSupply;\n\n    /\n     * @notice Official record of token balances for each account\n     /\n    mapping (address =&gt; uint256) accountTokens;\n\n    /\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;\n\n    /\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     /\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /\n     * @notice Mapping of account addresses to outstanding borrow balances\n     /\n    mapping(address =&gt; BorrowSnapshot) accountBorrows;\n\n\n    / Market Events /\n\n    /\n     * @notice Event emitted when interest is accrued\n     /\n    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /\n     * @notice Event emitted when tokens are minted\n     /\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n\n    /\n     * @notice Event emitted when tokens are redeemed\n     /\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n\n    /\n     * @notice Event emitted when underlying is borrowed\n     /\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n\n    / Admin Events /\n\n    /\n     * @notice Event emitted when pendingAdmin is changed\n     /\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     /\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /\n     * @notice Event emitted when comptroller is changed\n     /\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /\n     * @notice Event emitted when interestRateModel is changed\n     /\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n    /\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /\n     * @notice Event emitted when the reserves are reduced\n     /\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n\n    /\n     * @notice Construct a new money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     /\n    constructor(ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                uint initialExchangeRateMantissa_,\n                string memory name_,\n                string memory symbol_,\n                uint decimals_) internal {\n        // Set admin to msg.sender\n        admin = msg.sender;\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");\n\n        // Set the comptroller\n        uint err = setComptroller(comptroller);\n        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = setInterestRateModelFresh(interestRateModel);\n        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /\n     * @notice Transfer tokens tokens from src to dst by spender\n     * @dev Called by both transfer and transferFrom internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        / Fail if transfer not allowed /\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Do not allow self-transfers /\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n\n        / We call the defense hook (which checks for under-collateralization) */\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfer amount tokens from msg.sender to dst\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfer amount tokens from src to dst\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Approve spender to transfer up to amount from src\n     * @dev This will overwrite the approval amount for spender\n     *  and is subject to issues noted here\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /\n     * @notice Get the current allowance from owner for spender\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     /\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /\n     * @notice Get the token balance of the owner\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by owner\n     /\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /\n     * @notice Get the underlying balance of the owner\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by owner\n     */\n    function balanceOfUnderlying(address owner) external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR);\n        return balance;\n    }\n\n    /\n     * @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     /\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     /\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint) {\n        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque\n        return borrowRateMantissa;\n    }\n\n    /\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     /\n    function supplyRatePerBlock() external view returns (uint) {\n        / We calculate the supply rate:\n         *  underlying = totalSupply × exchangeRate\n         *  borrowsPer = totalBorrows ÷ underlying\n         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer\n         /\n        uint exchangeRateMantissa = exchangeRateStored();\n\n        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque\n\n        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);\n        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");\n\n        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);\n        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");\n\n        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));\n        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");\n\n        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);\n        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");\n\n        return supplyRate.mantissa;\n    }\n\n    /\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     /\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return totalBorrows;\n    }\n\n    /\n     * @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return borrowBalanceStored(account);\n    }\n\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     /\n    function borrowBalanceStored(address account) public view returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");\n        return result;\n    }\n\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     /\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return exchangeRateStored();\n    }\n\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     /\n    function exchangeRateStored() public view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");\n        return result;\n    }\n\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     /\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        if (totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint) {\n        return getCashPrior();\n    }\n\n    struct AccrueInterestLocalVars {\n        MathError mathErr;\n        uint opaqueErr;\n        uint borrowRateMantissa;\n        uint currentBlockNumber;\n        uint blockDelta;\n\n        Exp simpleInterestFactor;\n\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n    }\n\n    /\n      * @notice Applies accrued interest to total borrows and reserves.\n      * @dev This calculates interest accrued from the last checkpointed block\n      *      up to the current block and writes new checkpoint to storage.\n      /\n    function accrueInterest() public returns (uint) {\n        AccrueInterestLocalVars memory vars;\n\n        / Calculate the current borrow interest rate /\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");\n        if (vars.opaqueErr != 0) {\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n        }\n\n        / Remember the initial block number /\n        vars.currentBlockNumber = getBlockNumber();\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn\'t, blow up.\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = vars.currentBlockNumber;\n        borrowIndex = vars.borrowIndexNew;\n        totalBorrows = vars.totalBorrowsNew;\n        totalReserves = vars.totalReservesNew;\n\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don\'t need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n        / Fail if mint not allowed /\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n        }\n\n        MintLocalVars memory vars;\n\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n        }\n\n        /\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = mintAmount / exchangeRate\n         /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We call doTransferIn for the minter and the mintAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional mintAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n        }\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, mintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        / We call the defense hook */\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");\n\n        RedeemLocalVars memory vars;\n\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        / Fail if redeem not allowed /\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        / Fail gracefully if protocol has insufficient cash /\n        if (getCashPrior() &lt; vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        / We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return borrowFresh(msg.sender, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n        / Fail if borrow not allowed /\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        / Fail gracefully if protocol has insufficient underlying cash /\n        if (getCashPrior() &lt; borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(borrower, borrowAmount);\n        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a Borrow event /\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook /\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n        / Fail if repayBorrow not allowed /\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        / We remember the original borrowerIndex for verification purposes /\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        / We fetch the amount the borrower owes, with accumulated interest /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        / If repayAmount == -1, repayAmount = accountBorrows /\n        if (repayAmount == uint(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n        }\n\n        /\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - repayAmount\n         *  totalBorrowsNew = totalBorrows - repayAmount\n         /\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(payer, vars.repayAmount);\n        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook /\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {\n        / Fail if liquidate not allowed /\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);\n        }\n\n        / Verify cTokenCollateral market\'s block number equals current block number /\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);\n        }\n\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        / Fail if repayAmount = 0 /\n        if (repayAmount == 0) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);\n        }\n\n        / Fail if repayAmount = -1 /\n        if (repayAmount == uint(-1)) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);\n        }\n\n        / We calculate the number of collateral tokens that will be seized /\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);\n        if (amountSeizeError != 0) {\n            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);\n        }\n\n        / Fail if seizeTokens &gt; borrower collateral token balance /\n        if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {\n            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);\n        }\n\n        / Fail if repayBorrow fails /\n        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\n            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);\n        }\n\n        / Revert if seize tokens fails (since we cannot be sure of side effects) /\n        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");\n\n        / We emit a LiquidateBorrow event /\n        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);\n\n        / We call the defense hook /\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n        / Fail if seize not allowed /\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n\n        /\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         /\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n        }\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        / We write the previously calculated values into storage /\n        accountTokens[borrower] = borrowerTokensNew;\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n        / Emit a Transfer event /\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        / We call the defense hook /\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n\n    / Admin Functions /\n\n    /\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      \n      * TODO: Should we add a second arg to verify, like a checksum of newAdmin address?\n      */\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _acceptAdmin() external returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Sets a new comptroller for the market\n      * @dev Admin function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n        }\n\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), "marker method returned false");\n\n        // Set market\'s comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don\'t need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /\n      * @notice Sets a new reserve factor for the protocol (requires fresh interest accrual)\n      * @dev Admin function to set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n\n        // Verify market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don\'t need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n        Error err;\n        // totalReserves - reduceAmount\n        uint totalReservesNew;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() &lt; reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        // TODO: I\'m following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n        if (reduceAmount &gt; totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        totalReservesNew = totalReserves - reduceAmount;\n        // We checked reduceAmount &lt;= totalReserves above, so this should never revert.\n        require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // invoke doTransferOut(reduceAmount, admin)\n        err = doTransferOut(admin, reduceAmount);\n        // we revert on the failure of this command\n        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don\'t need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /\n     * @notice updates the interest rate model (requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Track the market\'s current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    / Safe Token /\n\n    /\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     /\n    function getCashPrior() internal view returns (uint);\n\n    /\n     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from from and\n     *      whether or not from has a balance of at least amount. Does NOT do a transfer.\n     /\n    function checkTransferIn(address from, uint amount) internal view returns (Error);\n\n    /\n     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checkTransferIn, this may revert due to insufficient balance or insufficient allowance.\n     *  If caller has called checkTransferIn successfully, this should not revert in normal conditions.\n     /\n    function doTransferIn(address from, uint amount) internal returns (Error);\n\n    /*\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol\'s balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol\'s balance, and verified it is &gt;= amount, this should not revert in normal conditions.\n     /\n    function doTransferOut(address payable to, uint amount) internal returns (Error);\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:06:58 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:06:58 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Given the user's task and the brainstorming ideas provided:
Task: "pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 05:07:01 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:07:01 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 30053
completion_tokens: 1
total_tokens: 30054
cost: $-1.000000


[2024-01-09 05:07:01 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

###

[2024-01-09 05:07:01 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 05:07:01 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 05:07:01 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:07:01 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:07:01 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 05:07:12 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:07:12 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15085
completion_tokens: 670
total_tokens: 15755
cost: $-1.000000


[2024-01-09 05:07:12 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

### Summary of Security Vulnerabilities in the CToken Contract

1. **Reentrancy Vulnerability**:
   - The contract uses the `nonReentrant` modifier to prevent reentrancy attacks, but it is crucial to ensure that all external calls (like transfers) are made after state changes to avoid potential reentrancy issues.

2. **Lack of Input Validation**:
   - Certain functions do not adequately validate inputs, such as `redeemFresh`, which allows for zero or negative values for `redeemAmount` and `redeemTokensIn`. This could lead to unexpected behavior or loss of funds.

3. **Arithmetic Errors**:
   - The contract relies on manual arithmetic checks (e.g., for underflows and overflows) instead of using SafeMath or similar libraries. This could lead to vulnerabilities if not handled correctly, especially in older versions of Solidity where underflows and overflows were not automatically checked.

4. **Potential for Excessive Gas Consumption**:
   - Functions that involve multiple state changes and external calls (like `accrueInterest`) could lead to excessive gas consumption, making them susceptible to denial-of-service attacks if the gas limit is reached.

5. **Improper Error Handling**:
   - The contract uses a custom error handling mechanism that may not provide sufficient feedback to users or developers. This could lead to confusion when errors occur, making it harder to debug issues.

6. **Admin Privileges**:
   - The contract grants significant privileges to the admin, including changing the interest rate model and reserve factors. If the admin's private key is compromised, it could lead to malicious actions that affect all users.

7. **Lack of Access Control on Critical Functions**:
   - Some functions that modify critical state variables (like `_setComptroller` and `_setInterestRateModel`) do not have adequate access control checks, which could allow unauthorized users to make changes.

8. **Potential for Front-Running Attacks**:
   - The contract does not implement any mechanisms to prevent front-running, which could allow malicious actors to exploit the timing of transactions for profit.

### Comprehensive Analysis Report

The CToken contract exhibits several security vulnerabilities that could pose significant risks to users and the overall integrity of the protocol. While the use of the `nonReentrant` modifier is a positive step towards mitigating reentrancy attacks, it is essential to ensure that all external calls are made after state changes to fully protect against such vulnerabilities.

Input validation is lacking in multiple areas, which could lead to unexpected behaviors or even loss of funds. The reliance on manual arithmetic checks instead of established libraries like SafeMath increases the risk of arithmetic errors, particularly in older Solidity versions.

The potential for excessive gas consumption in certain functions could lead to denial-of-service vulnerabilities, while improper error handling may hinder debugging efforts. The significant privileges granted to the admin, coupled with inadequate access control on critical functions, create a risk of unauthorized changes that could adversely affect users.

Additionally, the absence of mechanisms to prevent front-running attacks leaves the contract vulnerable to exploitation by malicious actors. 

In conclusion, it is imperative to address these vulnerabilities through rigorous testing, code reviews, and the implementation of best practices in smart contract development. This will enhance the security posture of the CToken contract and protect users' assets effectively.

[2024-01-09 05:07:12 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the CToken Contract

1. **Reentrancy Vulnerability**:
   - The contract uses the `nonReentrant` modifier to prevent reentrancy attacks, but it is crucial to ensure that all external calls (like transfers) are made after state changes to avoid potential reentrancy issues.

2. **Lack of Input Validation**:
   - Certain functions do not adequately validate inputs, such as `redeemFresh`, which allows for zero or negative values for `redeemAmount` and `redeemTokensIn`. This could lead to unexpected behavior or loss of funds.

3. **Arithmetic Errors**:
   - The contract relies on manual arithmetic checks (e.g., for underflows and overflows) instead of using SafeMath or similar libraries. This could lead to vulnerabilities if not handled correctly, especially in older versions of Solidity where underflows and overflows were not automatically checked.

4. **Potential for Excessive Gas Consumption**:
   - Functions that involve multiple state changes and external calls (like `accrueInterest`) could lead to excessive gas consumption, making them susceptible to denial-of-service attacks if the gas limit is reached.

5. **Improper Error Handling**:
   - The contract uses a custom error handling mechanism that may not provide sufficient feedback to users or developers. This could lead to confusion when errors occur, making it harder to debug issues.

6. **Admin Privileges**:
   - The contract grants significant privileges to the admin, including changing the interest rate model and reserve factors. If the admin's private key is compromised, it could lead to malicious actions that affect all users.

7. **Lack of Access Control on Critical Functions**:
   - Some functions that modify critical state variables (like `_setComptroller` and `_setInterestRateModel`) do not have adequate access control checks, which could allow unauthorized users to make changes.

8. **Potential for Front-Running Attacks**:
   - The contract does not implement any mechanisms to prevent front-running, which could allow malicious actors to exploit the timing of transactions for profit.

### Comprehensive Analysis Report

The CToken contract exhibits several security vulnerabilities that could pose significant risks to users and the overall integrity of the protocol. While the use of the `nonReentrant` modifier is a positive step towards mitigating reentrancy attacks, it is essential to ensure that all external calls are made after state changes to fully protect against such vulnerabilities.

Input validation is lacking in multiple areas, which could lead to unexpected behaviors or even loss of funds. The reliance on manual arithmetic checks instead of established libraries like SafeMath increases the risk of arithmetic errors, particularly in older Solidity versions.

The potential for excessive gas consumption in certain functions could lead to denial-of-service vulnerabilities, while improper error handling may hinder debugging efforts. The significant privileges granted to the admin, coupled with inadequate access control on critical functions, create a risk of unauthorized changes that could adversely affect users.

Additionally, the absence of mechanisms to prevent front-running attacks leaves the contract vulnerable to exploitation by malicious actors. 

In conclusion, it is imperative to address these vulnerabilities through rigorous testing, code reviews, and the implementation of best practices in smart contract development. This will enhance the security posture of the CToken contract and protect users' assets effectively.

[2024-01-09 05:07:12 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 05:07:13 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': 'pragma solidity ^0.5.8;\n\n\n/\n * @title Compound\'s CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n /\ncontract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {\n    /\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n\n    /\n     * @notice EIP-20 token name for this token\n     /\n    string public name;\n\n    /\n     * @notice EIP-20 token symbol for this token\n     /\n    string public symbol;\n\n    /\n     * @notice EIP-20 token decimals for this token\n     */\n    uint public decimals;\n\n    /\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     /\n    uint constant borrowRateMaxMantissa = 5e14;\n\n    /\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     /\n    uint constant reserveFactorMaxMantissa = 1e18;\n\n    /\n     * @notice Administrator for this contract\n     */\n    address payable public admin;\n\n    /\n     * @notice Pending administrator for this contract\n     /\n    address payable public pendingAdmin;\n\n    /\n     * @notice Contract which oversees inter-cToken operations\n     /\n    ComptrollerInterface public comptroller;\n\n    /\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModel public interestRateModel;\n\n    /\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n     /\n    uint public initialExchangeRateMantissa;\n\n    /\n     * @notice Fraction of interest currently set aside for reserves\n     /\n    uint public reserveFactorMantissa;\n\n    /\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n\n    /\n     * @notice Accumulator of total earned interest since the opening of the market\n     /\n    uint public borrowIndex;\n\n    /\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     /\n    uint public totalBorrows;\n\n    /\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n\n    /\n     * @notice Total number of tokens in circulation\n     /\n    uint256 public totalSupply;\n\n    /\n     * @notice Official record of token balances for each account\n     /\n    mapping (address =&gt; uint256) accountTokens;\n\n    /\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;\n\n    /\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     /\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /\n     * @notice Mapping of account addresses to outstanding borrow balances\n     /\n    mapping(address =&gt; BorrowSnapshot) accountBorrows;\n\n\n    / Market Events /\n\n    /\n     * @notice Event emitted when interest is accrued\n     /\n    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /\n     * @notice Event emitted when tokens are minted\n     /\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n\n    /\n     * @notice Event emitted when tokens are redeemed\n     /\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n\n    /\n     * @notice Event emitted when underlying is borrowed\n     /\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n\n    / Admin Events /\n\n    /\n     * @notice Event emitted when pendingAdmin is changed\n     /\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     /\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /\n     * @notice Event emitted when comptroller is changed\n     /\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /\n     * @notice Event emitted when interestRateModel is changed\n     /\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n    /\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /\n     * @notice Event emitted when the reserves are reduced\n     /\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n\n    /\n     * @notice Construct a new money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     /\n    constructor(ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                uint initialExchangeRateMantissa_,\n                string memory name_,\n                string memory symbol_,\n                uint decimals_) internal {\n        // Set admin to msg.sender\n        admin = msg.sender;\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");\n\n        // Set the comptroller\n        uint err = setComptroller(comptroller);\n        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = setInterestRateModelFresh(interestRateModel);\n        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /\n     * @notice Transfer tokens tokens from src to dst by spender\n     * @dev Called by both transfer and transferFrom internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        / Fail if transfer not allowed /\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Do not allow self-transfers /\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n\n        / We call the defense hook (which checks for under-collateralization) */\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfer amount tokens from msg.sender to dst\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfer amount tokens from src to dst\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Approve spender to transfer up to amount from src\n     * @dev This will overwrite the approval amount for spender\n     *  and is subject to issues noted here\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /\n     * @notice Get the current allowance from owner for spender\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     /\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /\n     * @notice Get the token balance of the owner\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by owner\n     /\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /\n     * @notice Get the underlying balance of the owner\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by owner\n     */\n    function balanceOfUnderlying(address owner) external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR);\n        return balance;\n    }\n\n    /\n     * @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     /\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     /\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint) {\n        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque\n        return borrowRateMantissa;\n    }\n\n    /\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     /\n    function supplyRatePerBlock() external view returns (uint) {\n        / We calculate the supply rate:\n         *  underlying = totalSupply × exchangeRate\n         *  borrowsPer = totalBorrows ÷ underlying\n         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer\n         /\n        uint exchangeRateMantissa = exchangeRateStored();\n\n        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque\n\n        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);\n        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");\n\n        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);\n        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");\n\n        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));\n        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");\n\n        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);\n        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");\n\n        return supplyRate.mantissa;\n    }\n\n    /\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     /\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return totalBorrows;\n    }\n\n    /\n     * @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return borrowBalanceStored(account);\n    }\n\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     /\n    function borrowBalanceStored(address account) public view returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");\n        return result;\n    }\n\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     /\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return exchangeRateStored();\n    }\n\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     /\n    function exchangeRateStored() public view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");\n        return result;\n    }\n\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     /\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        if (totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint) {\n        return getCashPrior();\n    }\n\n    struct AccrueInterestLocalVars {\n        MathError mathErr;\n        uint opaqueErr;\n        uint borrowRateMantissa;\n        uint currentBlockNumber;\n        uint blockDelta;\n\n        Exp simpleInterestFactor;\n\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n    }\n\n    /\n      * @notice Applies accrued interest to total borrows and reserves.\n      * @dev This calculates interest accrued from the last checkpointed block\n      *      up to the current block and writes new checkpoint to storage.\n      /\n    function accrueInterest() public returns (uint) {\n        AccrueInterestLocalVars memory vars;\n\n        / Calculate the current borrow interest rate /\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");\n        if (vars.opaqueErr != 0) {\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n        }\n\n        / Remember the initial block number /\n        vars.currentBlockNumber = getBlockNumber();\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn\'t, blow up.\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = vars.currentBlockNumber;\n        borrowIndex = vars.borrowIndexNew;\n        totalBorrows = vars.totalBorrowsNew;\n        totalReserves = vars.totalReservesNew;\n\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don\'t need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n        / Fail if mint not allowed /\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n        }\n\n        MintLocalVars memory vars;\n\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n        }\n\n        /\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = mintAmount / exchangeRate\n         /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We call doTransferIn for the minter and the mintAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional mintAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n        }\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, mintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        / We call the defense hook */\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");\n\n        RedeemLocalVars memory vars;\n\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        / Fail if redeem not allowed /\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        / Fail gracefully if protocol has insufficient cash /\n        if (getCashPrior() &lt; vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        / We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return borrowFresh(msg.sender, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n        / Fail if borrow not allowed /\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        / Fail gracefully if protocol has insufficient underlying cash /\n        if (getCashPrior() &lt; borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(borrower, borrowAmount);\n        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a Borrow event /\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook /\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n        / Fail if repayBorrow not allowed /\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        / We remember the original borrowerIndex for verification purposes /\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        / We fetch the amount the borrower owes, with accumulated interest /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        / If repayAmount == -1, repayAmount = accountBorrows /\n        if (repayAmount == uint(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n        }\n\n        /\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - repayAmount\n         *  totalBorrowsNew = totalBorrows - repayAmount\n         /\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(payer, vars.repayAmount);\n        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook /\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {\n        / Fail if liquidate not allowed /\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);\n        }\n\n        / Verify cTokenCollateral market\'s block number equals current block number /\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);\n        }\n\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        / Fail if repayAmount = 0 /\n        if (repayAmount == 0) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);\n        }\n\n        / Fail if repayAmount = -1 /\n        if (repayAmount == uint(-1)) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);\n        }\n\n        / We calculate the number of collateral tokens that will be seized /\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);\n        if (amountSeizeError != 0) {\n            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);\n        }\n\n        / Fail if seizeTokens &gt; borrower collateral token balance /\n        if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {\n            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);\n        }\n\n        / Fail if repayBorrow fails /\n        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\n            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);\n        }\n\n        / Revert if seize tokens fails (since we cannot be sure of side effects) /\n        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");\n\n        / We emit a LiquidateBorrow event /\n        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);\n\n        / We call the defense hook /\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n        / Fail if seize not allowed /\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n\n        /\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         /\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n        }\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        / We write the previously calculated values into storage /\n        accountTokens[borrower] = borrowerTokensNew;\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n        / Emit a Transfer event /\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        / We call the defense hook /\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n\n    / Admin Functions /\n\n    /\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      \n      * TODO: Should we add a second arg to verify, like a checksum of newAdmin address?\n      */\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _acceptAdmin() external returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Sets a new comptroller for the market\n      * @dev Admin function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n        }\n\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), "marker method returned false");\n\n        // Set market\'s comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don\'t need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /\n      * @notice Sets a new reserve factor for the protocol (requires fresh interest accrual)\n      * @dev Admin function to set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n\n        // Verify market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don\'t need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n        Error err;\n        // totalReserves - reduceAmount\n        uint totalReservesNew;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() &lt; reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        // TODO: I\'m following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n        if (reduceAmount &gt; totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        totalReservesNew = totalReserves - reduceAmount;\n        // We checked reduceAmount &lt;= totalReserves above, so this should never revert.\n        require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // invoke doTransferOut(reduceAmount, admin)\n        err = doTransferOut(admin, reduceAmount);\n        // we revert on the failure of this command\n        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don\'t need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /\n     * @notice updates the interest rate model (requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Track the market\'s current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    / Safe Token /\n\n    /\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     /\n    function getCashPrior() internal view returns (uint);\n\n    /\n     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from from and\n     *      whether or not from has a balance of at least amount. Does NOT do a transfer.\n     /\n    function checkTransferIn(address from, uint amount) internal view returns (Error);\n\n    /\n     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checkTransferIn, this may revert due to insufficient balance or insufficient allowance.\n     *  If caller has called checkTransferIn successfully, this should not revert in normal conditions.\n     /\n    function doTransferIn(address from, uint amount) internal returns (Error);\n\n    /*\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol\'s balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol\'s balance, and verified it is &gt;= amount, this should not revert in normal conditions.\n     /\n    function doTransferOut(address payable to, uint amount) internal returns (Error);\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:07:13 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:07:13 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Given the user's task and the brainstorming ideas provided:
Task: "pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 05:07:16 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:07:16 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 30053
completion_tokens: 1
total_tokens: 30054
cost: $-1.000000


[2024-01-09 05:07:16 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

###

[2024-01-09 05:07:16 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 05:07:16 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 05:07:16 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:07:16 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:07:16 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 05:07:28 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:07:28 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15085
completion_tokens: 780
total_tokens: 15865
cost: $-1.000000


[2024-01-09 05:07:28 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Based on the provided smart contract code for the CToken contract, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses the `nonReentrant` modifier, which is a good practice to prevent reentrancy attacks. However, it is crucial to ensure that all external calls (like transfers) are made after state changes to avoid potential vulnerabilities.

2. **Arithmetic Overflow/Underflow**:
   - The contract uses custom math functions (e.g., `addUInt`, `subUInt`) to handle arithmetic operations. While this mitigates overflow/underflow risks, it is essential to ensure that these functions are thoroughly tested and handle all edge cases correctly.

3. **Access Control Issues**:
   - The contract has several functions that are restricted to the admin (e.g., `_setComptroller`, `_setReserveFactor`). If the admin's address is compromised, an attacker could manipulate the contract's state. Implementing a multi-signature wallet for admin functions could enhance security.

4. **Lack of Input Validation**:
   - Some functions do not adequately validate inputs. For example, in functions like `redeemFresh`, there should be checks to ensure that the amounts being redeemed or borrowed are valid and do not exceed the user's balance or the contract's available cash.

5. **Potential for Denial of Service (DoS)**:
   - If an external contract called by this contract fails (e.g., during a transfer), it could lead to a DoS situation where the contract cannot proceed with its operations. Proper error handling and fallback mechanisms should be in place.

6. **Event Emission on Failure**:
   - The contract emits events even when operations fail (e.g., in `accrueInterest`). This could lead to misleading logs and should be handled carefully to ensure that events are only emitted on successful operations.

7. **Gas Limit Issues**:
   - Functions that involve multiple state changes and external calls may run into gas limit issues, especially during high network congestion. It is essential to optimize these functions to ensure they can be executed within the gas limits.

8. **Inadequate Documentation**:
   - While the contract has comments, some functions lack detailed explanations of their purpose and expected behavior. Comprehensive documentation is crucial for future audits and maintenance.

### Comprehensive Analysis Report:

The CToken contract is a complex implementation of a tokenized lending and borrowing mechanism. While it incorporates several best practices, such as the use of the `nonReentrant` modifier and custom math functions to prevent overflow/underflow, there are notable vulnerabilities that need addressing.

1. **Reentrancy Protection**: The use of the `nonReentrant` modifier is commendable, but developers must ensure that all external calls are made after state changes to prevent reentrancy attacks effectively.

2. **Access Control**: The reliance on a single admin for critical functions poses a significant risk. Transitioning to a multi-signature approach for administrative actions would enhance security.

3. **Input Validation**: The contract should implement stricter input validation to prevent invalid operations that could lead to unexpected behaviors or losses.

4. **Error Handling**: The contract should ensure that events are only emitted for successful operations and that proper error handling is in place to avoid misleading logs.

5. **Gas Optimization**: Functions should be optimized to prevent gas limit issues, especially during high network activity.

6. **Documentation**: Improved documentation will aid in understanding the contract's functionality and facilitate future audits.

In conclusion, while the CToken contract demonstrates a solid foundation for a lending and borrowing protocol, addressing the identified vulnerabilities will significantly enhance its security and reliability. Regular audits and updates should be conducted to adapt to evolving security standards and practices in the blockchain space.

[2024-01-09 05:07:28 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the CToken contract, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses the `nonReentrant` modifier, which is a good practice to prevent reentrancy attacks. However, it is crucial to ensure that all external calls (like transfers) are made after state changes to avoid potential vulnerabilities.

2. **Arithmetic Overflow/Underflow**:
   - The contract uses custom math functions (e.g., `addUInt`, `subUInt`) to handle arithmetic operations. While this mitigates overflow/underflow risks, it is essential to ensure that these functions are thoroughly tested and handle all edge cases correctly.

3. **Access Control Issues**:
   - The contract has several functions that are restricted to the admin (e.g., `_setComptroller`, `_setReserveFactor`). If the admin's address is compromised, an attacker could manipulate the contract's state. Implementing a multi-signature wallet for admin functions could enhance security.

4. **Lack of Input Validation**:
   - Some functions do not adequately validate inputs. For example, in functions like `redeemFresh`, there should be checks to ensure that the amounts being redeemed or borrowed are valid and do not exceed the user's balance or the contract's available cash.

5. **Potential for Denial of Service (DoS)**:
   - If an external contract called by this contract fails (e.g., during a transfer), it could lead to a DoS situation where the contract cannot proceed with its operations. Proper error handling and fallback mechanisms should be in place.

6. **Event Emission on Failure**:
   - The contract emits events even when operations fail (e.g., in `accrueInterest`). This could lead to misleading logs and should be handled carefully to ensure that events are only emitted on successful operations.

7. **Gas Limit Issues**:
   - Functions that involve multiple state changes and external calls may run into gas limit issues, especially during high network congestion. It is essential to optimize these functions to ensure they can be executed within the gas limits.

8. **Inadequate Documentation**:
   - While the contract has comments, some functions lack detailed explanations of their purpose and expected behavior. Comprehensive documentation is crucial for future audits and maintenance.

### Comprehensive Analysis Report:

The CToken contract is a complex implementation of a tokenized lending and borrowing mechanism. While it incorporates several best practices, such as the use of the `nonReentrant` modifier and custom math functions to prevent overflow/underflow, there are notable vulnerabilities that need addressing.

1. **Reentrancy Protection**: The use of the `nonReentrant` modifier is commendable, but developers must ensure that all external calls are made after state changes to prevent reentrancy attacks effectively.

2. **Access Control**: The reliance on a single admin for critical functions poses a significant risk. Transitioning to a multi-signature approach for administrative actions would enhance security.

3. **Input Validation**: The contract should implement stricter input validation to prevent invalid operations that could lead to unexpected behaviors or losses.

4. **Error Handling**: The contract should ensure that events are only emitted for successful operations and that proper error handling is in place to avoid misleading logs.

5. **Gas Optimization**: Functions should be optimized to prevent gas limit issues, especially during high network activity.

6. **Documentation**: Improved documentation will aid in understanding the contract's functionality and facilitate future audits.

In conclusion, while the CToken contract demonstrates a solid foundation for a lending and borrowing protocol, addressing the identified vulnerabilities will significantly enhance its security and reliability. Regular audits and updates should be conducted to adapt to evolving security standards and practices in the blockchain space.

[2024-01-09 05:07:28 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 05:07:28 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': 'pragma solidity ^0.5.8;\n\n\n/\n * @title Compound\'s CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n /\ncontract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {\n    /\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n\n    /\n     * @notice EIP-20 token name for this token\n     /\n    string public name;\n\n    /\n     * @notice EIP-20 token symbol for this token\n     /\n    string public symbol;\n\n    /\n     * @notice EIP-20 token decimals for this token\n     */\n    uint public decimals;\n\n    /\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     /\n    uint constant borrowRateMaxMantissa = 5e14;\n\n    /\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     /\n    uint constant reserveFactorMaxMantissa = 1e18;\n\n    /\n     * @notice Administrator for this contract\n     */\n    address payable public admin;\n\n    /\n     * @notice Pending administrator for this contract\n     /\n    address payable public pendingAdmin;\n\n    /\n     * @notice Contract which oversees inter-cToken operations\n     /\n    ComptrollerInterface public comptroller;\n\n    /\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModel public interestRateModel;\n\n    /\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n     /\n    uint public initialExchangeRateMantissa;\n\n    /\n     * @notice Fraction of interest currently set aside for reserves\n     /\n    uint public reserveFactorMantissa;\n\n    /\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n\n    /\n     * @notice Accumulator of total earned interest since the opening of the market\n     /\n    uint public borrowIndex;\n\n    /\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     /\n    uint public totalBorrows;\n\n    /\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n\n    /\n     * @notice Total number of tokens in circulation\n     /\n    uint256 public totalSupply;\n\n    /\n     * @notice Official record of token balances for each account\n     /\n    mapping (address =&gt; uint256) accountTokens;\n\n    /\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;\n\n    /\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     /\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /\n     * @notice Mapping of account addresses to outstanding borrow balances\n     /\n    mapping(address =&gt; BorrowSnapshot) accountBorrows;\n\n\n    / Market Events /\n\n    /\n     * @notice Event emitted when interest is accrued\n     /\n    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /\n     * @notice Event emitted when tokens are minted\n     /\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n\n    /\n     * @notice Event emitted when tokens are redeemed\n     /\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n\n    /\n     * @notice Event emitted when underlying is borrowed\n     /\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n\n    / Admin Events /\n\n    /\n     * @notice Event emitted when pendingAdmin is changed\n     /\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     /\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /\n     * @notice Event emitted when comptroller is changed\n     /\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /\n     * @notice Event emitted when interestRateModel is changed\n     /\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n    /\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /\n     * @notice Event emitted when the reserves are reduced\n     /\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n\n    /\n     * @notice Construct a new money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     /\n    constructor(ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                uint initialExchangeRateMantissa_,\n                string memory name_,\n                string memory symbol_,\n                uint decimals_) internal {\n        // Set admin to msg.sender\n        admin = msg.sender;\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");\n\n        // Set the comptroller\n        uint err = setComptroller(comptroller);\n        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = setInterestRateModelFresh(interestRateModel);\n        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /\n     * @notice Transfer tokens tokens from src to dst by spender\n     * @dev Called by both transfer and transferFrom internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        / Fail if transfer not allowed /\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Do not allow self-transfers /\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n\n        / We call the defense hook (which checks for under-collateralization) */\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfer amount tokens from msg.sender to dst\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfer amount tokens from src to dst\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Approve spender to transfer up to amount from src\n     * @dev This will overwrite the approval amount for spender\n     *  and is subject to issues noted here\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /\n     * @notice Get the current allowance from owner for spender\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     /\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /\n     * @notice Get the token balance of the owner\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by owner\n     /\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /\n     * @notice Get the underlying balance of the owner\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by owner\n     */\n    function balanceOfUnderlying(address owner) external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR);\n        return balance;\n    }\n\n    /\n     * @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     /\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     /\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint) {\n        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque\n        return borrowRateMantissa;\n    }\n\n    /\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     /\n    function supplyRatePerBlock() external view returns (uint) {\n        / We calculate the supply rate:\n         *  underlying = totalSupply × exchangeRate\n         *  borrowsPer = totalBorrows ÷ underlying\n         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer\n         /\n        uint exchangeRateMantissa = exchangeRateStored();\n\n        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque\n\n        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);\n        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");\n\n        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);\n        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");\n\n        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));\n        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");\n\n        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);\n        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");\n\n        return supplyRate.mantissa;\n    }\n\n    /\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     /\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return totalBorrows;\n    }\n\n    /\n     * @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return borrowBalanceStored(account);\n    }\n\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     /\n    function borrowBalanceStored(address account) public view returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");\n        return result;\n    }\n\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     /\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return exchangeRateStored();\n    }\n\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     /\n    function exchangeRateStored() public view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");\n        return result;\n    }\n\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     /\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        if (totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint) {\n        return getCashPrior();\n    }\n\n    struct AccrueInterestLocalVars {\n        MathError mathErr;\n        uint opaqueErr;\n        uint borrowRateMantissa;\n        uint currentBlockNumber;\n        uint blockDelta;\n\n        Exp simpleInterestFactor;\n\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n    }\n\n    /\n      * @notice Applies accrued interest to total borrows and reserves.\n      * @dev This calculates interest accrued from the last checkpointed block\n      *      up to the current block and writes new checkpoint to storage.\n      /\n    function accrueInterest() public returns (uint) {\n        AccrueInterestLocalVars memory vars;\n\n        / Calculate the current borrow interest rate /\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");\n        if (vars.opaqueErr != 0) {\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n        }\n\n        / Remember the initial block number /\n        vars.currentBlockNumber = getBlockNumber();\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn\'t, blow up.\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = vars.currentBlockNumber;\n        borrowIndex = vars.borrowIndexNew;\n        totalBorrows = vars.totalBorrowsNew;\n        totalReserves = vars.totalReservesNew;\n\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don\'t need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n        / Fail if mint not allowed /\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n        }\n\n        MintLocalVars memory vars;\n\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n        }\n\n        /\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = mintAmount / exchangeRate\n         /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We call doTransferIn for the minter and the mintAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional mintAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n        }\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, mintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        / We call the defense hook */\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");\n\n        RedeemLocalVars memory vars;\n\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        / Fail if redeem not allowed /\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        / Fail gracefully if protocol has insufficient cash /\n        if (getCashPrior() &lt; vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        / We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return borrowFresh(msg.sender, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n        / Fail if borrow not allowed /\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        / Fail gracefully if protocol has insufficient underlying cash /\n        if (getCashPrior() &lt; borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(borrower, borrowAmount);\n        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a Borrow event /\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook /\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n        / Fail if repayBorrow not allowed /\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        / We remember the original borrowerIndex for verification purposes /\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        / We fetch the amount the borrower owes, with accumulated interest /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        / If repayAmount == -1, repayAmount = accountBorrows /\n        if (repayAmount == uint(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n        }\n\n        /\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - repayAmount\n         *  totalBorrowsNew = totalBorrows - repayAmount\n         /\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(payer, vars.repayAmount);\n        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook /\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {\n        / Fail if liquidate not allowed /\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);\n        }\n\n        / Verify cTokenCollateral market\'s block number equals current block number /\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);\n        }\n\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        / Fail if repayAmount = 0 /\n        if (repayAmount == 0) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);\n        }\n\n        / Fail if repayAmount = -1 /\n        if (repayAmount == uint(-1)) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);\n        }\n\n        / We calculate the number of collateral tokens that will be seized /\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);\n        if (amountSeizeError != 0) {\n            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);\n        }\n\n        / Fail if seizeTokens &gt; borrower collateral token balance /\n        if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {\n            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);\n        }\n\n        / Fail if repayBorrow fails /\n        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\n            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);\n        }\n\n        / Revert if seize tokens fails (since we cannot be sure of side effects) /\n        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");\n\n        / We emit a LiquidateBorrow event /\n        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);\n\n        / We call the defense hook /\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n        / Fail if seize not allowed /\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n\n        /\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         /\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n        }\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        / We write the previously calculated values into storage /\n        accountTokens[borrower] = borrowerTokensNew;\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n        / Emit a Transfer event /\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        / We call the defense hook /\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n\n    / Admin Functions /\n\n    /\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      \n      * TODO: Should we add a second arg to verify, like a checksum of newAdmin address?\n      */\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _acceptAdmin() external returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Sets a new comptroller for the market\n      * @dev Admin function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n        }\n\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), "marker method returned false");\n\n        // Set market\'s comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don\'t need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /\n      * @notice Sets a new reserve factor for the protocol (requires fresh interest accrual)\n      * @dev Admin function to set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n\n        // Verify market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don\'t need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n        Error err;\n        // totalReserves - reduceAmount\n        uint totalReservesNew;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() &lt; reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        // TODO: I\'m following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n        if (reduceAmount &gt; totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        totalReservesNew = totalReserves - reduceAmount;\n        // We checked reduceAmount &lt;= totalReserves above, so this should never revert.\n        require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // invoke doTransferOut(reduceAmount, admin)\n        err = doTransferOut(admin, reduceAmount);\n        // we revert on the failure of this command\n        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don\'t need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /\n     * @notice updates the interest rate model (requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Track the market\'s current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    / Safe Token /\n\n    /\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     /\n    function getCashPrior() internal view returns (uint);\n\n    /\n     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from from and\n     *      whether or not from has a balance of at least amount. Does NOT do a transfer.\n     /\n    function checkTransferIn(address from, uint amount) internal view returns (Error);\n\n    /\n     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checkTransferIn, this may revert due to insufficient balance or insufficient allowance.\n     *  If caller has called checkTransferIn successfully, this should not revert in normal conditions.\n     /\n    function doTransferIn(address from, uint amount) internal returns (Error);\n\n    /*\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol\'s balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol\'s balance, and verified it is &gt;= amount, this should not revert in normal conditions.\n     /\n    function doTransferOut(address payable to, uint amount) internal returns (Error);\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:07:28 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:07:28 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Given the user's task and the brainstorming ideas provided:
Task: "pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 05:07:31 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:07:31 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 30053
completion_tokens: 1
total_tokens: 30054
cost: $-1.000000


[2024-01-09 05:07:31 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

###

[2024-01-09 05:07:31 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 05:07:31 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 05:07:31 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:07:31 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:07:31 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 05:07:42 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:07:42 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15085
completion_tokens: 801
total_tokens: 15886
cost: $-1.000000


[2024-01-09 05:07:42 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Based on the provided smart contract code for the `CToken` contract, here are the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses the `nonReentrant` modifier, which is a good practice to prevent reentrancy attacks. However, the implementation of this modifier should be thoroughly reviewed to ensure it is correctly applied in all relevant functions, especially those that involve external calls.

2. **Arithmetic Operations**:
   - The contract relies on custom math functions (e.g., `addUInt`, `subUInt`, `mulUInt`, etc.) for arithmetic operations. If these functions do not handle overflow and underflow correctly, it could lead to vulnerabilities. It is essential to ensure that these functions are implemented using safe math practices.

3. **Access Control**:
   - The contract has several functions that require admin privileges (e.g., `_setPendingAdmin`, `_acceptAdmin`, `_setComptroller`, etc.). If the admin address is compromised, an attacker could gain control over the contract. It is crucial to implement multi-signature wallets or time-lock mechanisms for sensitive operations.

4. **Interest Rate Model Dependency**:
   - The contract relies on an external `InterestRateModel` for calculating interest rates. If this model is compromised or behaves unexpectedly, it could lead to financial losses for users. Proper validation and checks should be in place to ensure the integrity of the interest rate model.

5. **Comptroller Dependency**:
   - The contract interacts with a `ComptrollerInterface` for various operations (e.g., minting, borrowing, redeeming). If the comptroller is malicious or has vulnerabilities, it could affect the security of the `CToken` contract. A thorough audit of the comptroller contract is necessary.

6. **Event Emission**:
   - The contract emits events for significant actions (e.g., `Mint`, `Redeem`, `Borrow`, etc.), which is good for transparency. However, it is essential to ensure that all critical state changes are accompanied by appropriate event emissions to maintain an accurate log.

7. **Error Handling**:
   - The contract uses a custom error handling mechanism. While this can provide clarity, it may lead to confusion if not documented properly. It is essential to ensure that all error codes are well-defined and that users can understand the reasons for failures.

8. **Potential Gas Limit Issues**:
   - Functions that involve loops or extensive calculations may run into gas limit issues. It is crucial to assess the gas consumption of functions, especially those that could be called frequently or with large inputs.

### Comprehensive Analysis Report:

The `CToken` contract exhibits a robust structure for managing tokenized assets and borrowing mechanisms. However, several security vulnerabilities could pose risks to users and the overall integrity of the contract. The reliance on external contracts (interest rate model and comptroller) introduces additional risk factors that must be managed through thorough audits and validation checks.

To enhance the security posture of the `CToken` contract, the following recommendations are made:

- **Conduct a thorough audit of all external dependencies**, including the `InterestRateModel` and `ComptrollerInterface`, to ensure they are secure and function as intended.
- **Implement additional access control measures**, such as multi-signature wallets or time-locks, for sensitive administrative functions to mitigate the risk of unauthorized access.
- **Review and test all custom math functions** to ensure they handle arithmetic operations safely and correctly, preventing overflow and underflow vulnerabilities.
- **Ensure comprehensive documentation** of the error handling mechanism to aid users in understanding potential failure points and their causes.
- **Monitor gas consumption** for functions that may involve loops or extensive calculations to prevent transaction failures due to gas limits.

By addressing these vulnerabilities and implementing the recommended measures, the `CToken` contract can significantly improve its security and reliability, fostering user trust and confidence in its operations.

[2024-01-09 05:07:42 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `CToken` contract, here are the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses the `nonReentrant` modifier, which is a good practice to prevent reentrancy attacks. However, the implementation of this modifier should be thoroughly reviewed to ensure it is correctly applied in all relevant functions, especially those that involve external calls.

2. **Arithmetic Operations**:
   - The contract relies on custom math functions (e.g., `addUInt`, `subUInt`, `mulUInt`, etc.) for arithmetic operations. If these functions do not handle overflow and underflow correctly, it could lead to vulnerabilities. It is essential to ensure that these functions are implemented using safe math practices.

3. **Access Control**:
   - The contract has several functions that require admin privileges (e.g., `_setPendingAdmin`, `_acceptAdmin`, `_setComptroller`, etc.). If the admin address is compromised, an attacker could gain control over the contract. It is crucial to implement multi-signature wallets or time-lock mechanisms for sensitive operations.

4. **Interest Rate Model Dependency**:
   - The contract relies on an external `InterestRateModel` for calculating interest rates. If this model is compromised or behaves unexpectedly, it could lead to financial losses for users. Proper validation and checks should be in place to ensure the integrity of the interest rate model.

5. **Comptroller Dependency**:
   - The contract interacts with a `ComptrollerInterface` for various operations (e.g., minting, borrowing, redeeming). If the comptroller is malicious or has vulnerabilities, it could affect the security of the `CToken` contract. A thorough audit of the comptroller contract is necessary.

6. **Event Emission**:
   - The contract emits events for significant actions (e.g., `Mint`, `Redeem`, `Borrow`, etc.), which is good for transparency. However, it is essential to ensure that all critical state changes are accompanied by appropriate event emissions to maintain an accurate log.

7. **Error Handling**:
   - The contract uses a custom error handling mechanism. While this can provide clarity, it may lead to confusion if not documented properly. It is essential to ensure that all error codes are well-defined and that users can understand the reasons for failures.

8. **Potential Gas Limit Issues**:
   - Functions that involve loops or extensive calculations may run into gas limit issues. It is crucial to assess the gas consumption of functions, especially those that could be called frequently or with large inputs.

### Comprehensive Analysis Report:

The `CToken` contract exhibits a robust structure for managing tokenized assets and borrowing mechanisms. However, several security vulnerabilities could pose risks to users and the overall integrity of the contract. The reliance on external contracts (interest rate model and comptroller) introduces additional risk factors that must be managed through thorough audits and validation checks.

To enhance the security posture of the `CToken` contract, the following recommendations are made:

- **Conduct a thorough audit of all external dependencies**, including the `InterestRateModel` and `ComptrollerInterface`, to ensure they are secure and function as intended.
- **Implement additional access control measures**, such as multi-signature wallets or time-locks, for sensitive administrative functions to mitigate the risk of unauthorized access.
- **Review and test all custom math functions** to ensure they handle arithmetic operations safely and correctly, preventing overflow and underflow vulnerabilities.
- **Ensure comprehensive documentation** of the error handling mechanism to aid users in understanding potential failure points and their causes.
- **Monitor gas consumption** for functions that may involve loops or extensive calculations to prevent transaction failures due to gas limits.

By addressing these vulnerabilities and implementing the recommended measures, the `CToken` contract can significantly improve its security and reliability, fostering user trust and confidence in its operations.

[2024-01-09 05:07:46 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': 'pragma solidity ^0.5.8;\n\n\n/\n * @title Compound\'s CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n /\ncontract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {\n    /\n     * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    bool public constant isCToken = true;\n\n    /\n     * @notice EIP-20 token name for this token\n     /\n    string public name;\n\n    /\n     * @notice EIP-20 token symbol for this token\n     /\n    string public symbol;\n\n    /\n     * @notice EIP-20 token decimals for this token\n     */\n    uint public decimals;\n\n    /\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     /\n    uint constant borrowRateMaxMantissa = 5e14;\n\n    /\n     * @notice Maximum fraction of interest that can be set aside for reserves\n     /\n    uint constant reserveFactorMaxMantissa = 1e18;\n\n    /\n     * @notice Administrator for this contract\n     */\n    address payable public admin;\n\n    /\n     * @notice Pending administrator for this contract\n     /\n    address payable public pendingAdmin;\n\n    /\n     * @notice Contract which oversees inter-cToken operations\n     /\n    ComptrollerInterface public comptroller;\n\n    /\n     * @notice Model which tells what the current interest rate should be\n     */\n    InterestRateModel public interestRateModel;\n\n    /\n     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n     /\n    uint public initialExchangeRateMantissa;\n\n    /\n     * @notice Fraction of interest currently set aside for reserves\n     /\n    uint public reserveFactorMantissa;\n\n    /\n     * @notice Block number that interest was last accrued at\n     */\n    uint public accrualBlockNumber;\n\n    /\n     * @notice Accumulator of total earned interest since the opening of the market\n     /\n    uint public borrowIndex;\n\n    /\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     /\n    uint public totalBorrows;\n\n    /\n     * @notice Total amount of reserves of the underlying held in this market\n     */\n    uint public totalReserves;\n\n    /\n     * @notice Total number of tokens in circulation\n     /\n    uint256 public totalSupply;\n\n    /\n     * @notice Official record of token balances for each account\n     /\n    mapping (address =&gt; uint256) accountTokens;\n\n    /\n     * @notice Approved token transfer amounts on behalf of others\n     */\n    mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;\n\n    /\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     /\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /\n     * @notice Mapping of account addresses to outstanding borrow balances\n     /\n    mapping(address =&gt; BorrowSnapshot) accountBorrows;\n\n\n    / Market Events /\n\n    /\n     * @notice Event emitted when interest is accrued\n     /\n    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /\n     * @notice Event emitted when tokens are minted\n     /\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n\n    /\n     * @notice Event emitted when tokens are redeemed\n     /\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n\n    /\n     * @notice Event emitted when underlying is borrowed\n     /\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n    /\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n\n    / Admin Events /\n\n    /\n     * @notice Event emitted when pendingAdmin is changed\n     /\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     /\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /\n     * @notice Event emitted when comptroller is changed\n     /\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n    /\n     * @notice Event emitted when interestRateModel is changed\n     /\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n    /\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n    /\n     * @notice Event emitted when the reserves are reduced\n     /\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n\n    /\n     * @notice Construct a new money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     /\n    constructor(ComptrollerInterface comptroller_,\n                InterestRateModel interestRateModel_,\n                uint initialExchangeRateMantissa_,\n                string memory name_,\n                string memory symbol_,\n                uint decimals_) internal {\n        // Set admin to msg.sender\n        admin = msg.sender;\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");\n\n        // Set the comptroller\n        uint err = setComptroller(comptroller);\n        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = setInterestRateModelFresh(interestRateModel);\n        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /\n     * @notice Transfer tokens tokens from src to dst by spender\n     * @dev Called by both transfer and transferFrom internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n        / Fail if transfer not allowed /\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Do not allow self-transfers /\n        if (src == dst) {\n            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(-1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n        }\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n        }\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(-1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n\n        / We call the defense hook (which checks for under-collateralization) */\n        comptroller.transferVerify(address(this), src, dst, tokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfer amount tokens from msg.sender to dst\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfer amount tokens from src to dst\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     /\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Approve spender to transfer up to amount from src\n     * @dev This will overwrite the approval amount for spender\n     *  and is subject to issues noted here\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /\n     * @notice Get the current allowance from owner for spender\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     /\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /\n     * @notice Get the token balance of the owner\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by owner\n     /\n    function balanceOf(address owner) external view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /\n     * @notice Get the underlying balance of the owner\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by owner\n     */\n    function balanceOfUnderlying(address owner) external returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR);\n        return balance;\n    }\n\n    /\n     * @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     /\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     /\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint) {\n        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque\n        return borrowRateMantissa;\n    }\n\n    /\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     /\n    function supplyRatePerBlock() external view returns (uint) {\n        / We calculate the supply rate:\n         *  underlying = totalSupply × exchangeRate\n         *  borrowsPer = totalBorrows ÷ underlying\n         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer\n         /\n        uint exchangeRateMantissa = exchangeRateStored();\n\n        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque\n\n        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);\n        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");\n\n        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);\n        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");\n\n        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));\n        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");\n\n        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);\n        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");\n\n        return supplyRate.mantissa;\n    }\n\n    /\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     /\n    function totalBorrowsCurrent() external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return totalBorrows;\n    }\n\n    /\n     * @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return borrowBalanceStored(account);\n    }\n\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     /\n    function borrowBalanceStored(address account) public view returns (uint) {\n        (MathError err, uint result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");\n        return result;\n    }\n\n    /\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     /\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint) {\n        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");\n        return exchangeRateStored();\n    }\n\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     /\n    function exchangeRateStored() public view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");\n        return result;\n    }\n\n    /\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return (error code, calculated exchange rate scaled by 1e18)\n     /\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        if (totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint) {\n        return getCashPrior();\n    }\n\n    struct AccrueInterestLocalVars {\n        MathError mathErr;\n        uint opaqueErr;\n        uint borrowRateMantissa;\n        uint currentBlockNumber;\n        uint blockDelta;\n\n        Exp simpleInterestFactor;\n\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint totalReservesNew;\n        uint borrowIndexNew;\n    }\n\n    /\n      * @notice Applies accrued interest to total borrows and reserves.\n      * @dev This calculates interest accrued from the last checkpointed block\n      *      up to the current block and writes new checkpoint to storage.\n      /\n    function accrueInterest() public returns (uint) {\n        AccrueInterestLocalVars memory vars;\n\n        / Calculate the current borrow interest rate /\n        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n        require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");\n        if (vars.opaqueErr != 0) {\n            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);\n        }\n\n        / Remember the initial block number /\n        vars.currentBlockNumber = getBlockNumber();\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);\n        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn\'t, blow up.\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = vars.currentBlockNumber;\n        borrowIndex = vars.borrowIndexNew;\n        totalBorrows = vars.totalBorrowsNew;\n        totalReserves = vars.totalReservesNew;\n\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\n        }\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don\'t need to\n        return mintFresh(msg.sender, mintAmount);\n    }\n\n    struct MintLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /\n     * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function mintFresh(address minter, uint mintAmount) internal returns (uint) {\n        / Fail if mint not allowed /\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\n        }\n\n        MintLocalVars memory vars;\n\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\n        }\n\n        /\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\n         *  mintTokens = mintAmount / exchangeRate\n         /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We call doTransferIn for the minter and the mintAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional mintAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(minter, mintAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\n        }\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, mintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        / We call the defense hook */\n        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n        }\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        return redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    struct RedeemLocalVars {\n        Error err;\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /\n     * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");\n\n        RedeemLocalVars memory vars;\n\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));\n        }\n\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));\n            }\n\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        / Fail if redeem not allowed /\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n        }\n\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        / Fail gracefully if protocol has insufficient cash /\n        if (getCashPrior() &lt; vars.redeemAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(redeemer, vars.redeemAmount);\n        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        / We call the defense hook */\n        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return borrowFresh(msg.sender, borrowAmount);\n    }\n\n    struct BorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /\n      * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n        / Fail if borrow not allowed /\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n        }\n\n        / Fail gracefully if protocol has insufficient underlying cash /\n        if (getCashPrior() &lt; borrowAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n        }\n\n        BorrowLocalVars memory vars;\n\n        /\n         * We calculate the new borrower and total borrow balances, failing on overflow:\n         *  accountBorrowsNew = accountBorrows + borrowAmount\n         *  totalBorrowsNew = totalBorrows + borrowAmount\n         /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We invoke doTransferOut for the borrower and the borrowAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken borrowAmount less of cash.\n         *  If doTransferOut fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferOut(borrower, borrowAmount);\n        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a Borrow event /\n        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook /\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    /\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\n        }\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        return repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint repayAmount;\n        uint borrowerIndex;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /\n     * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of undelrying tokens being returned\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n        / Fail if repayBorrow not allowed /\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        / We remember the original borrowerIndex for verification purposes /\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        / We fetch the amount the borrower owes, with accumulated interest /\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        / If repayAmount == -1, repayAmount = accountBorrows /\n        if (repayAmount == uint(-1)) {\n            vars.repayAmount = vars.accountBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        / Fail if checkTransferIn fails /\n        vars.err = checkTransferIn(payer, vars.repayAmount);\n        if (vars.err != Error.NO_ERROR) {\n            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n        }\n\n        /\n         * We calculate the new borrower and total borrow balances, failing on underflow:\n         *  accountBorrowsNew = accountBorrows - repayAmount\n         *  totalBorrowsNew = totalBorrows - repayAmount\n         /\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        /\n         * We call doTransferIn for the payer and the repayAmount\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken holds an additional repayAmount of cash.\n         *  If doTransferIn fails despite the fact we checked pre-conditions,\n         *   we revert because we can\'t be sure if side effects occurred.\n         /\n        vars.err = doTransferIn(payer, vars.repayAmount);\n        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook /\n        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\n        }\n\n        error = cTokenCollateral.accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);\n        }\n\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n    }\n\n    /\n     * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {\n        / Fail if liquidate not allowed /\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Verify market\'s block number equals current block number /\n        if (accrualBlockNumber != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);\n        }\n\n        / Verify cTokenCollateral market\'s block number equals current block number /\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);\n        }\n\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        / Fail if repayAmount = 0 /\n        if (repayAmount == 0) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);\n        }\n\n        / Fail if repayAmount = -1 /\n        if (repayAmount == uint(-1)) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);\n        }\n\n        / We calculate the number of collateral tokens that will be seized /\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);\n        if (amountSeizeError != 0) {\n            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);\n        }\n\n        / Fail if seizeTokens &gt; borrower collateral token balance /\n        if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {\n            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);\n        }\n\n        / Fail if repayBorrow fails /\n        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);\n        if (repayBorrowError != uint(Error.NO_ERROR)) {\n            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);\n        }\n\n        / Revert if seize tokens fails (since we cannot be sure of side effects) /\n        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");\n\n        / We emit a LiquidateBorrow event /\n        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);\n\n        / We call the defense hook /\n        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n        / Fail if seize not allowed /\n        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);\n        if (allowed != 0) {\n            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n        }\n\n        / Fail if borrower = liquidator /\n        if (borrower == liquidator) {\n            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n        }\n\n        MathError mathErr;\n        uint borrowerTokensNew;\n        uint liquidatorTokensNew;\n\n        /\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n         /\n        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));\n        }\n\n        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);\n        if (mathErr != MathError.NO_ERROR) {\n            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        / We write the previously calculated values into storage /\n        accountTokens[borrower] = borrowerTokensNew;\n        accountTokens[liquidator] = liquidatorTokensNew;\n\n        / Emit a Transfer event /\n        emit Transfer(borrower, liquidator, seizeTokens);\n\n        / We call the defense hook /\n        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);\n\n        return uint(Error.NO_ERROR);\n    }\n\n\n    / Admin Functions /\n\n    /\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call _acceptAdmin to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      \n      * TODO: Should we add a second arg to verify, like a checksum of newAdmin address?\n      */\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _acceptAdmin() external returns (uint) {\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice Sets a new comptroller for the market\n      * @dev Admin function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n        }\n\n        ComptrollerInterface oldComptroller = comptroller;\n        // Ensure invoke comptroller.isComptroller() returns true\n        require(newComptroller.isComptroller(), "marker method returned false");\n\n        // Set market\'s comptroller to newComptroller\n        comptroller = newComptroller;\n\n        // Emit NewComptroller(oldComptroller, newComptroller)\n        emit NewComptroller(oldComptroller, newComptroller);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n        }\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don\'t need to.\n        return _setReserveFactorFresh(newReserveFactorMantissa);\n    }\n\n    /\n      * @notice Sets a new reserve factor for the protocol (requires fresh interest accrual)\n      * @dev Admin function to set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      /\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n        }\n\n        // Verify market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n        }\n\n        // Check newReserveFactor ≤ maxReserveFactor\n        if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {\n            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n        }\n\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n        }\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don\'t need to.\n        return _reduceReservesFresh(reduceAmount);\n    }\n\n    /\n     * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n        Error err;\n        // totalReserves - reduceAmount\n        uint totalReservesNew;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n        }\n\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n        }\n\n        // Fail gracefully if protocol has insufficient underlying cash\n        if (getCashPrior() &lt; reduceAmount) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n        }\n\n        // Check reduceAmount ≤ reserves[n] (totalReserves)\n        // TODO: I\'m following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\n        if (reduceAmount &gt; totalReserves) {\n            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS &amp; INTERACTIONS\n        // (No safe failures beyond this point)\n\n        totalReservesNew = totalReserves - reduceAmount;\n        // We checked reduceAmount &lt;= totalReserves above, so this should never revert.\n        require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");\n\n        // Store reserves[n+1] = reserves[n] - reduceAmount\n        totalReserves = totalReservesNew;\n\n        // invoke doTransferOut(reduceAmount, admin)\n        err = doTransferOut(admin, reduceAmount);\n        // we revert on the failure of this command\n        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");\n\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don\'t need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    /\n     * @notice updates the interest rate model (requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     /\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n        // Used to store old model for use in the event that is emitted on success\n        InterestRateModel oldInterestRateModel;\n\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // We fail gracefully unless market\'s block number equals current block number\n        if (accrualBlockNumber != getBlockNumber()) {\n            // TODO: static_assert + no error code?\n            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n        }\n\n        // Track the market\'s current interest rate model\n        oldInterestRateModel = interestRateModel;\n\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");\n\n        // Set the interest rate model to newInterestRateModel\n        interestRateModel = newInterestRateModel;\n\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    / Safe Token /\n\n    /\n     * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     /\n    function getCashPrior() internal view returns (uint);\n\n    /\n     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from from and\n     *      whether or not from has a balance of at least amount. Does NOT do a transfer.\n     /\n    function checkTransferIn(address from, uint amount) internal view returns (Error);\n\n    /\n     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checkTransferIn, this may revert due to insufficient balance or insufficient allowance.\n     *  If caller has called checkTransferIn successfully, this should not revert in normal conditions.\n     /\n    function doTransferIn(address from, uint amount) internal returns (Error);\n\n    /*\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n     *  If caller has not called checked protocol\'s balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol\'s balance, and verified it is &gt;= amount, this should not revert in normal conditions.\n     /\n    function doTransferOut(address payable to, uint amount) internal returns (Error);\n}', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 05:07:46 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | pragma solidity ^0.5.8; /  * @title Compound's CToken Contract  * @notice Abstract base for CTokens  * @author Compound  */ contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {     /      * @notice Indicator that this is a CToken contract (for inspection)      */     bool public constant isCToken = true; /**  * @notice EIP-20 token name for this token  */ string public name;  /**  * @notice EIP-20 token symbol for this token  */ string public symbol;  /**  * @notice EIP-20 token decimals for this token  */ uint public decimals;  /**  * @notice Maximum borrow rate that can ever be applied (.0005% / block)  */ uint constant borrowRateMaxMantissa = 5e14;  /**  * @notice Maximum fraction of interest that can be set aside for reserves  */ uint constant reserveFactorMaxMantissa = 1e18;  /**  * @notice Administrator for this contract  */ address payable public admin;  /**  * @notice Pending administrator for this contract  */ address payable public pendingAdmin;  /**  * @notice Contract which oversees inter-cToken operations  */ ComptrollerInterface public comptroller;  /**  * @notice Model which tells what the current interest rate should be  */ InterestRateModel public interestRateModel;  /**  * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)  */ uint public initialExchangeRateMantissa;  /**  * @notice Fraction of interest currently set aside for reserves  */ uint public reserveFactorMantissa;  /**  * @notice Block number that interest was last accrued at  */ uint public accrualBlockNumber;  /**  * @notice Accumulator of total earned interest since the opening of the market  */ uint public borrowIndex;  /**  * @notice Total amount of outstanding borrows of the underlying in this market  */ uint public totalBorrows;  /**  * @notice Total amount of reserves of the underlying held in this market  */ uint public totalReserves;  /**  * @notice Total number of tokens in circulation  */ uint256 public totalSupply;  /**  * @notice Official record of token balances for each account  */ mapping (address =&gt; uint256) accountTokens;  /**  * @notice Approved token transfer amounts on behalf of others  */ mapping (address =&gt; mapping (address =&gt; uint256)) transferAllowances;  /**  * @notice Container for borrow balance information  * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action  * @member interestIndex Global borrowIndex as of the most recent balance-changing action  */ struct BorrowSnapshot {     uint principal;     uint interestIndex; }  /**  * @notice Mapping of account addresses to outstanding borrow balances  */ mapping(address =&gt; BorrowSnapshot) accountBorrows;   /*** Market Events ***/  /**  * @notice Event emitted when interest is accrued  */ event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);  /**  * @notice Event emitted when tokens are minted  */ event Mint(address minter, uint mintAmount, uint mintTokens);  /**  * @notice Event emitted when tokens are redeemed  */ event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);  /**  * @notice Event emitted when underlying is borrowed  */ event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is repaid  */ event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);  /**  * @notice Event emitted when a borrow is liquidated  */ event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);   /*** Admin Events ***/  /**  * @notice Event emitted when pendingAdmin is changed  */ event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);  /**  * @notice Event emitted when pendingAdmin is accepted, which means admin is updated  */ event NewAdmin(address oldAdmin, address newAdmin);  /**  * @notice Event emitted when comptroller is changed  */ event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);  /**  * @notice Event emitted when interestRateModel is changed  */ event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);  /**  * @notice Event emitted when the reserve factor is changed  */ event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);  /**  * @notice Event emitted when the reserves are reduced  */ event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);   /**  * @notice Construct a new money market  * @param comptroller_ The address of the Comptroller  * @param interestRateModel_ The address of the interest rate model  * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18  * @param name_ EIP-20 name of this token  * @param symbol_ EIP-20 symbol of this token  * @param decimals_ EIP-20 decimal precision of this token  */ constructor(ComptrollerInterface comptroller_,             InterestRateModel interestRateModel_,             uint initialExchangeRateMantissa_,             string memory name_,             string memory symbol_,             uint decimals_) internal {     // Set admin to msg.sender     admin = msg.sender;      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial exchange rate must be greater than zero.");      // Set the comptroller     uint err = _setComptroller(comptroller_);     require(err == uint(Error.NO_ERROR), "Setting comptroller failed");      // Initialize block number and borrow index (block number mocks depend on comptroller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = mantissaOne;      // Set the interest rate model (depends on block number / borrow index)     err = _setInterestRateModelFresh(interestRateModel_);     require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");      name = name_;     symbol = symbol_;     decimals = decimals_; }  /**  * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`  * @dev Called by both `transfer` and `transferFrom` internally  * @param spender The address of the account performing the transfer  * @param src The address of the source account  * @param dst The address of the destination account  * @param tokens The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {     /* Fail if transfer not allowed */     uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);     }      /* Do not allow self-transfers */     if (src == dst) {         return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);     }      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(-1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);     }      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);     }      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     if (mathErr != MathError.NO_ERROR) {         return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(-1)) {         transferAllowances[src][spender] = allowanceNew;     }      /* We emit a Transfer event */     emit Transfer(src, dst, tokens);      /* We call the defense hook (which checks for under-collateralization) */     comptroller.transferVerify(address(this), src, dst, tokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `msg.sender` to `dst`  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Transfer `amount` tokens from `src` to `dst`  * @param src The address of the source account  * @param dst The address of the destination account  * @param amount The number of tokens to transfer  * @return Whether or not the transfer succeeded  */ function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR); }  /**  * @notice Approve `spender` to transfer up to `amount` from `src`  * @dev This will overwrite the approval amount for `spender`  *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)  * @param spender The address of the account which may transfer tokens  * @param amount The number of tokens that are approved (-1 means infinite)  * @return Whether or not the approval succeeded  */ function approve(address spender, uint256 amount) external returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /**  * @notice Get the current allowance from `owner` for `spender`  * @param owner The address of the account which owns the tokens to be spent  * @param spender The address of the account which may transfer tokens  * @return The number of tokens allowed to be spent (-1 means infinite)  */ function allowance(address owner, address spender) external view returns (uint256) {     return transferAllowances[owner][spender]; }  /**  * @notice Get the token balance of the `owner`  * @param owner The address of the account to query  * @return The number of tokens owned by `owner`  */ function balanceOf(address owner) external view returns (uint256) {     return accountTokens[owner]; }  /**  * @notice Get the underlying balance of the `owner`  * @dev This also accrues interest in a transaction  * @param owner The address of the account to query  * @return The amount of underlying owned by `owner`  */ function balanceOfUnderlying(address owner) external returns (uint) {     Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR);     return balance; }  /**  * @notice Get a snapshot of the account's balances, and the cached exchange rate  * @dev This is used by comptroller to more efficiently perform liquidity checks.  * @param account Address of the account to snapshot  * @return (possible error, token balance, borrow balance, exchange rate mantissa)  */ function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (uint(Error.MATH_ERROR), 0, 0, 0);     }      return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa); }  /**  * @dev Function to simply retrieve block number  *  This exists mainly for inheriting test contracts to stub this result.  */ function getBlockNumber() internal view returns (uint) {     return block.number; }  /**  * @notice Returns the current per-block borrow interest rate for this cToken  * @return The borrow interest rate per block, scaled by 1e18  */ function borrowRatePerBlock() external view returns (uint) {     (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque     return borrowRateMantissa; }  /**  * @notice Returns the current per-block supply interest rate for this cToken  * @return The supply interest rate per block, scaled by 1e18  */ function supplyRatePerBlock() external view returns (uint) {     /* We calculate the supply rate:      *  underlying = totalSupply × exchangeRate      *  borrowsPer = totalBorrows ÷ underlying      *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer      */     uint exchangeRateMantissa = exchangeRateStored();      (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque      (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);     require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");      (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);     require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");      (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));     require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");      (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);     require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");      return supplyRate.mantissa; }  /**  * @notice Returns the current total borrows plus accrued interest  * @return The total borrows with interest  */ function totalBorrowsCurrent() external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return totalBorrows; }  /**  * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex  * @param account The address whose balance should be calculated after updating borrowIndex  * @return The calculated balance  */ function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return borrowBalanceStored(account); }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return The calculated balance  */ function borrowBalanceStored(address account) public view returns (uint) {     (MathError err, uint result) = borrowBalanceStoredInternal(account);     require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");     return result; }  /**  * @notice Return the borrow balance of account based on stored data  * @param account The address whose balance should be calculated  * @return (error code, the calculated balance or 0 if error code is non-zero)  */ function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /**  * @notice Accrue interest then return the up-to-date exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateCurrent() public nonReentrant returns (uint) {     require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");     return exchangeRateStored(); }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return Calculated exchange rate scaled by 1e18  */ function exchangeRateStored() public view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");     return result; }  /**  * @notice Calculates the exchange rate from the underlying to the CToken  * @dev This function does not accrue interest before calculating the exchange rate  * @return (error code, calculated exchange rate scaled by 1e18)  */ function exchangeRateStoredInternal() internal view returns (MathError, uint) {     if (totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /**  * @notice Get cash balance of this cToken in the underlying asset  * @return The quantity of underlying asset owned by this contract  */ function getCash() external view returns (uint) {     return getCashPrior(); }  struct AccrueInterestLocalVars {     MathError mathErr;     uint opaqueErr;     uint borrowRateMantissa;     uint currentBlockNumber;     uint blockDelta;      Exp simpleInterestFactor;      uint interestAccumulated;     uint totalBorrowsNew;     uint totalReservesNew;     uint borrowIndexNew; }  /**   * @notice Applies accrued interest to total borrows and reserves.   * @dev This calculates interest accrued from the last checkpointed block   *      up to the current block and writes new checkpoint to storage.   */ function accrueInterest() public returns (uint) {     AccrueInterestLocalVars memory vars;      /* Calculate the current borrow interest rate */     (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);     require(vars.borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrow rate is absurdly high");     if (vars.opaqueErr != 0) {         return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);     }      /* Remember the initial block number */     vars.currentBlockNumber = getBlockNumber();      /* Calculate the number of blocks elapsed since the last accrual */     (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);     assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.      /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */     (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accrualBlockNumber = vars.currentBlockNumber;     borrowIndex = vars.borrowIndexNew;     totalBorrows = vars.totalBorrowsNew;     totalReserves = vars.totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);      return uint(Error.NO_ERROR); }  /**  * @notice Sender supplies assets into the market and receives cTokens in exchange  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);     }     // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to     return mintFresh(msg.sender, mintAmount); }  struct MintLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User supplies assets into the market and receives cTokens in exchange  * @dev Assumes interest has already been accrued up to the current block  * @param minter The address of the account which is supplying the assets  * @param mintAmount The amount of the underlying asset to supply  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function mintFresh(address minter, uint mintAmount) internal returns (uint) {     /* Fail if mint not allowed */     uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);     }      MintLocalVars memory vars;      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We get the current exchange rate and calculate the number of cTokens to be minted:      *  mintTokens = mintAmount / exchangeRate      */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));     }      /*      * We calculate the new total supply of cTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the minter and the mintAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional mintAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(minter, mintAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);     }      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, mintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */     comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Sender redeems cTokens in exchange for the underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemTokens The number of cTokens to redeem into underlying  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, redeemTokens, 0); }  /**  * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset  * @dev Accrues interest whether or not the operation succeeds, unless reverted  * @param redeemAmount The amount of underlying to redeem  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed         return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);     }     // redeemFresh emits redeem-specific logs on errors, so we don't need to     return redeemFresh(msg.sender, 0, redeemAmount); }  struct RedeemLocalVars {     Error err;     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /**  * @notice User redeems cTokens in exchange for the underlying asset  * @dev Assumes interest has already been accrued up to the current block  * @param redeemer The address of the account which is redeeming the tokens  * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));     }      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));         }     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));         if (vars.mathErr != MathError.NO_ERROR) {             return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));         }          vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);     }      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* Fail gracefully if protocol has insufficient cash */     if (getCashPrior() &lt; vars.redeemAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(redeemer, vars.redeemAmount);     require(vars.err == Error.NO_ERROR, "redeem transfer out failed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;      /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */     comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);      return uint(Error.NO_ERROR); }  /**   * @notice Sender borrows assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);     }     // borrowFresh emits borrow-specific logs on errors, so we don't need to     return borrowFresh(msg.sender, borrowAmount); }  struct BorrowLocalVars {     Error err;     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**   * @notice Users borrow assets from the protocol to their own address   * @param borrowAmount The amount of the underlying asset to borrow   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {     /* Fail if borrow not allowed */     uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);     }      /* Fail gracefully if protocol has insufficient underlying cash */     if (getCashPrior() &lt; borrowAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);     }      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  If doTransferOut fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferOut(borrower, borrowAmount);     require(vars.err == Error.NO_ERROR, "borrow transfer out failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a Borrow event */     emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.borrowVerify(address(this), borrower, borrowAmount);      return uint(Error.NO_ERROR); }  /**  * @notice Sender repays their own borrow  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, msg.sender, repayAmount); }  /**  * @notice Sender repays a borrow belonging to borrower  * @param borrower the account with the debt being payed off  * @param repayAmount The amount to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed         return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);     }     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     return repayBorrowFresh(msg.sender, borrower, repayAmount); }  struct RepayBorrowLocalVars {     Error err;     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /**  * @notice Borrows are repaid by another user (possibly the borrower).  * @param payer the account paying off the borrow  * @param borrower the account with the debt being payed off  * @param repayAmount the amount of undelrying tokens being returned  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {     /* Fail if repayBorrow not allowed */     uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);     }      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(-1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }      /* Fail if checkTransferIn fails */     vars.err = checkTransferIn(payer, vars.repayAmount);     if (vars.err != Error.NO_ERROR) {         return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);     }      /*      * We calculate the new borrower and total borrow balances, failing on underflow:      *  accountBorrowsNew = accountBorrows - repayAmount      *  totalBorrowsNew = totalBorrows - repayAmount      */     (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);     if (vars.mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /*      * We call doTransferIn for the payer and the repayAmount      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken holds an additional repayAmount of cash.      *  If doTransferIn fails despite the fact we checked pre-conditions,      *   we revert because we can't be sure if side effects occurred.      */     vars.err = doTransferIn(payer, vars.repayAmount);     require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */     comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);      return uint(Error.NO_ERROR); }  /**  * @notice The sender liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);     }      error = cTokenCollateral.accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed         return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);     }      // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to     return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral); }  /**  * @notice The liquidator liquidates the borrowers collateral.  *  The collateral seized is transferred to the liquidator.  * @param borrower The borrower of this cToken to be liquidated  * @param liquidator The address repaying the borrow and seizing collateral  * @param cTokenCollateral The market in which to seize collateral from the borrower  * @param repayAmount The amount of the underlying borrowed asset to repay  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {     /* Fail if liquidate not allowed */     uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);     }      /* Verify market's block number equals current block number */     if (accrualBlockNumber != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);     }      /* Verify cTokenCollateral market's block number equals current block number */     if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {         return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);     }      /* Fail if repayAmount = 0 */     if (repayAmount == 0) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);     }      /* Fail if repayAmount = -1 */     if (repayAmount == uint(-1)) {         return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);     }      /* We calculate the number of collateral tokens that will be seized */     (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);     if (amountSeizeError != 0) {         return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);     }      /* Fail if seizeTokens &gt; borrower collateral token balance */     if (seizeTokens &gt; cTokenCollateral.balanceOf(borrower)) {         return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);     }      /* Fail if repayBorrow fails */     uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);     if (repayBorrowError != uint(Error.NO_ERROR)) {         return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);     }      /* Revert if seize tokens fails (since we cannot be sure of side effects) */     uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);     require(seizeError == uint(Error.NO_ERROR), "token seizure failed");      /* We emit a LiquidateBorrow event */     emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);      /* We call the defense hook */     comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);      return uint(Error.NO_ERROR); }  /**  * @notice Transfers collateral tokens (this market) to the liquidator.  * @dev Will fail unless called by another cToken during the process of liquidation.  *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.  * @param liquidator The account receiving seized collateral  * @param borrower The account having collateral seized  * @param seizeTokens The number of cTokens to seize  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {     /* Fail if seize not allowed */     uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);     if (allowed != 0) {         return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);     }      /* Fail if borrower = liquidator */     if (borrower == liquidator) {         return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);     }      MathError mathErr;     uint borrowerTokensNew;     uint liquidatorTokensNew;      /*      * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:      *  borrowerTokensNew = accountTokens[borrower] - seizeTokens      *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens      */     (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));     }      (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);     if (mathErr != MathError.NO_ERROR) {         return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      /* We write the previously calculated values into storage */     accountTokens[borrower] = borrowerTokensNew;     accountTokens[liquidator] = liquidatorTokensNew;      /* Emit a Transfer event */     emit Transfer(borrower, liquidator, seizeTokens);      /* We call the defense hook */     comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);      return uint(Error.NO_ERROR); }   /*** Admin Functions ***/  /**   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.   * @param newPendingAdmin New pending admin.   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   *   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?   */ function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {     // Check caller = admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);     }      // Save current value, if any, for inclusion in log     address oldPendingAdmin = pendingAdmin;      // Store pendingAdmin with value newPendingAdmin     pendingAdmin = newPendingAdmin;      // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)     emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin   * @dev Admin function for pending admin to accept role and update admin   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _acceptAdmin() external returns (uint) {     // Check caller is pendingAdmin and pendingAdmin ≠ address(0)     if (msg.sender != pendingAdmin || msg.sender == address(0)) {         return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);     }      // Save current values for inclusion in log     address oldAdmin = admin;     address oldPendingAdmin = pendingAdmin;      // Store admin with value pendingAdmin     admin = pendingAdmin;      // Clear the pending value     pendingAdmin = address(0);      emit NewAdmin(oldAdmin, admin);     emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);      return uint(Error.NO_ERROR); }  /**   * @notice Sets a new comptroller for the market   * @dev Admin function to set a new comptroller   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);     }      ComptrollerInterface oldComptroller = comptroller;     // Ensure invoke comptroller.isComptroller() returns true     require(newComptroller.isComptroller(), "marker method returned false");      // Set market's comptroller to newComptroller     comptroller = newComptroller;      // Emit NewComptroller(oldComptroller, newComptroller)     emit NewComptroller(oldComptroller, newComptroller);      return uint(Error.NO_ERROR); }  /**   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh   * @dev Admin function to accrue interest and set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.         return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);     }     // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.     return _setReserveFactorFresh(newReserveFactorMantissa); }  /**   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)   * @dev Admin function to set a new reserve factor   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)   */ function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {     // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);     }      // Verify market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);     }      // Check newReserveFactor ≤ maxReserveFactor     if (newReserveFactorMantissa &gt; reserveFactorMaxMantissa) {         return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);     }      uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;      emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);      return uint(Error.NO_ERROR); }  /**  * @notice Accrues interest and reduces reserves by transferring to admin  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.         return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);     }     // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.     return _reduceReservesFresh(reduceAmount); }  /**  * @notice Reduces reserves by transferring to admin  * @dev Requires fresh interest accrual  * @param reduceAmount Amount of reduction to reserves  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {     Error err;     // totalReserves - reduceAmount     uint totalReservesNew;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);     }      // Fail gracefully if protocol has insufficient underlying cash     if (getCashPrior() &lt; reduceAmount) {         return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);     }      // Check reduceAmount ≤ reserves[n] (totalReserves)     // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)     if (reduceAmount &gt; totalReserves) {         return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);     }      /////////////////////////     // EFFECTS &amp; INTERACTIONS     // (No safe failures beyond this point)      totalReservesNew = totalReserves - reduceAmount;     // We checked reduceAmount &lt;= totalReserves above, so this should never revert.     require(totalReservesNew &lt;= totalReserves, "reduce reserves unexpected underflow");      // Store reserves[n+1] = reserves[n] - reduceAmount     totalReserves = totalReservesNew;      // invoke doTransferOut(reduceAmount, admin)     err = doTransferOut(admin, reduceAmount);     // we revert on the failure of this command     require(err == Error.NO_ERROR, "reduce reserves transfer out failed");      emit ReservesReduced(admin, reduceAmount, totalReservesNew);      return uint(Error.NO_ERROR); }  /**  * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh  * @dev Admin function to accrue interest and update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {     uint error = accrueInterest();     if (error != uint(Error.NO_ERROR)) {         // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed         return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);     }     // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.     return _setInterestRateModelFresh(newInterestRateModel); }  /**  * @notice updates the interest rate model (*requires fresh interest accrual)  * @dev Admin function to update the interest rate model  * @param newInterestRateModel the new interest rate model to use  * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)  */ function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {      // Used to store old model for use in the event that is emitted on success     InterestRateModel oldInterestRateModel;      // Check caller is admin     if (msg.sender != admin) {         return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);     }      // We fail gracefully unless market's block number equals current block number     if (accrualBlockNumber != getBlockNumber()) {         // TODO: static_assert + no error code?         return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);     }      // Track the market's current interest rate model     oldInterestRateModel = interestRateModel;      // Ensure invoke newInterestRateModel.isInterestRateModel() returns true     require(newInterestRateModel.isInterestRateModel(), "marker method returned false");      // Set the interest rate model to newInterestRateModel     interestRateModel = newInterestRateModel;      // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)     emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);      return uint(Error.NO_ERROR); }  /*** Safe Token ***/  /**  * @notice Gets balance of this contract in terms of the underlying  * @dev This excludes the value of the current message, if any  * @return The quantity of underlying owned by this contract  */ function getCashPrior() internal view returns (uint);  /**  * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and  *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.  */ function checkTransferIn(address from, uint amount) internal view returns (Error);  /**  * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.  *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.  *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.  */ function doTransferIn(address from, uint amount) internal returns (Error);  /**  * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.  *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.  *  If caller has checked protocol's balance, and verified it is &gt;= amount, this should not revert in normal conditions.  */ function doTransferOut(address payable to, uint amount) internal returns (Error);  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:07:46 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "pragma solidity ^0.5.8;


/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is EIP20Interface, Exponential, TokenErrorReporter, ReentrancyGuard {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */
    uint constant borrowRateMaxMantissa = 5e14;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint public initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of total earned interest since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping (address => uint256) accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping (address => mapping (address => uint256)) transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) accountBorrows;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);


    /**
     * @notice Construct a new money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    constructor(ComptrollerInterface comptroller_,
                InterestRateModel interestRateModel_,
                uint initialExchangeRateMantissa_,
                string memory name_,
                string memory symbol_,
                uint decimals_) internal {
        // Set admin to msg.sender
        admin = msg.sender;

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial exchange rate must be greater than zero.");

        // Set the comptroller
        uint err = _setComptroller(comptroller_);
        require(err == uint(Error.NO_ERROR), "Setting comptroller failed");

        // Initialize block number and borrow index (block number mocks depend on comptroller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = mantissaOne;

        // Set the interest rate model (depends on block number / borrow index)
        err = _setInterestRateModelFresh(interestRateModel_);
        require(err == uint(Error.NO_ERROR), "Setting interest rate model failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(-1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);
        }

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);
        }

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        if (mathErr != MathError.NO_ERROR) {
            return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(-1)) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        /* We call the defense hook (which checks for under-collateralization) */
        comptroller.transferVerify(address(this), src, dst, tokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR);
        return balance;
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by comptroller to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0, 0, 0);
        }

        return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /**
     * @notice Returns the current per-block borrow interest rate for this cToken
     * @return The borrow interest rate per block, scaled by 1e18
     */
    function borrowRatePerBlock() external view returns (uint) {
        (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(opaqueErr == 0, "borrowRatePerBlock: interestRateModel.borrowRate failed"); // semi-opaque
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this cToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() external view returns (uint) {
        /* We calculate the supply rate:
         *  underlying = totalSupply × exchangeRate
         *  borrowsPer = totalBorrows ÷ underlying
         *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer
         */
        uint exchangeRateMantissa = exchangeRateStored();

        (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(e0 == 0, "supplyRatePerBlock: calculating borrowRate failed"); // semi-opaque

        (MathError e1, Exp memory underlying) = mulScalar(Exp({mantissa: exchangeRateMantissa}), totalSupply);
        require(e1 == MathError.NO_ERROR, "supplyRatePerBlock: calculating underlying failed");

        (MathError e2, Exp memory borrowsPer) = divScalarByExp(totalBorrows, underlying);
        require(e2 == MathError.NO_ERROR, "supplyRatePerBlock: calculating borrowsPer failed");

        (MathError e3, Exp memory oneMinusReserveFactor) = subExp(Exp({mantissa: mantissaOne}), Exp({mantissa: reserveFactorMantissa}));
        require(e3 == MathError.NO_ERROR, "supplyRatePerBlock: calculating oneMinusReserveFactor failed");

        (MathError e4, Exp memory supplyRate) = mulExp3(Exp({mantissa: borrowRateMantissa}), oneMinusReserveFactor, borrowsPer);
        require(e4 == MathError.NO_ERROR, "supplyRatePerBlock: calculating supplyRate failed");

        return supplyRate.mantissa;
    }

    /**
     * @notice Returns the current total borrows plus accrued interest
     * @return The total borrows with interest
     */
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return totalBorrows;
    }

    /**
     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
     * @param account The address whose balance should be calculated after updating borrowIndex
     * @return The calculated balance
     */
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return The calculated balance
     */
    function borrowBalanceStored(address account) public view returns (uint) {
        (MathError err, uint result) = borrowBalanceStoredInternal(account);
        require(err == MathError.NO_ERROR, "borrowBalanceStored: borrowBalanceStoredInternal failed");
        return result;
    }

    /**
     * @notice Return the borrow balance of account based on stored data
     * @param account The address whose balance should be calculated
     * @return (error code, the calculated balance or 0 if error code is non-zero)
     */
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "exchangeRateStored: exchangeRateStoredInternal failed");
        return result;
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return (error code, calculated exchange rate scaled by 1e18)
     */
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        if (totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /**
     * @notice Get cash balance of this cToken in the underlying asset
     * @return The quantity of underlying asset owned by this contract
     */
    function getCash() external view returns (uint) {
        return getCashPrior();
    }

    struct AccrueInterestLocalVars {
        MathError mathErr;
        uint opaqueErr;
        uint borrowRateMantissa;
        uint currentBlockNumber;
        uint blockDelta;

        Exp simpleInterestFactor;

        uint interestAccumulated;
        uint totalBorrowsNew;
        uint totalReservesNew;
        uint borrowIndexNew;
    }

    /**
      * @notice Applies accrued interest to total borrows and reserves.
      * @dev This calculates interest accrued from the last checkpointed block
      *      up to the current block and writes new checkpoint to storage.
      */
    function accrueInterest() public returns (uint) {
        AccrueInterestLocalVars memory vars;

        /* Calculate the current borrow interest rate */
        (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);
        require(vars.borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate is absurdly high");
        if (vars.opaqueErr != 0) {
            return failOpaque(Error.INTEREST_RATE_MODEL_ERROR, FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED, vars.opaqueErr);
        }

        /* Remember the initial block number */
        vars.currentBlockNumber = getBlockNumber();

        /* Calculate the number of blocks elapsed since the last accrual */
        (vars.mathErr, vars.blockDelta) = subUInt(vars.currentBlockNumber, accrualBlockNumber);
        assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        (vars.mathErr, vars.simpleInterestFactor) = mulScalar(Exp({mantissa: vars.borrowRateMantissa}), vars.blockDelta);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(vars.simpleInterestFactor, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(vars.interestAccumulated, totalBorrows);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), vars.interestAccumulated, totalReserves);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(vars.simpleInterestFactor, borrowIndex, borrowIndex);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accrualBlockNumber = vars.currentBlockNumber;
        borrowIndex = vars.borrowIndexNew;
        totalBorrows = vars.totalBorrowsNew;
        totalReserves = vars.totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(vars.interestAccumulated, vars.borrowIndexNew, totalBorrows);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender supplies assets into the market and receives cTokens in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);
        }
        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to
        return mintFresh(msg.sender, mintAmount);
    }

    struct MintLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User supplies assets into the market and receives cTokens in exchange
     * @dev Assumes interest has already been accrued up to the current block
     * @param minter The address of the account which is supplying the assets
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mintFresh(address minter, uint mintAmount) internal returns (uint) {
        /* Fail if mint not allowed */
        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);
        }

        MintLocalVars memory vars;

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We get the current exchange rate and calculate the number of cTokens to be minted:
         *  mintTokens = mintAmount / exchangeRate
         */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(mintAmount, Exp({mantissa: vars.exchangeRateMantissa}));
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /*
         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the minter and the mintAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional mintAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(minter, mintAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);
        }

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, mintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */
        comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender redeems cTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of cTokens to redeem into underlying
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, redeemTokens, 0);
    }

    /**
     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to redeem
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed
            return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);
        }
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        return redeemFresh(msg.sender, 0, redeemAmount);
    }

    struct RedeemLocalVars {
        Error err;
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /**
     * @notice User redeems cTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of redeemTokensIn or redeemAmountIn must be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint(vars.mathErr));
        }

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint(vars.mathErr));
            }
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));
            if (vars.mathErr != MathError.NO_ERROR) {
                return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint(vars.mathErr));
            }

            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        uint allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
        }

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* Fail gracefully if protocol has insufficient cash */
        if (getCashPrior() < vars.redeemAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(redeemer, vars.redeemAmount);
        require(vars.err == Error.NO_ERROR, "redeem transfer out failed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
        comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sender borrows assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);
        }
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        return borrowFresh(msg.sender, borrowAmount);
    }

    struct BorrowLocalVars {
        Error err;
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
      * @notice Users borrow assets from the protocol to their own address
      * @param borrowAmount The amount of the underlying asset to borrow
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
        /* Fail if borrow not allowed */
        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);
        }

        /* Fail gracefully if protocol has insufficient underlying cash */
        if (getCashPrior() < borrowAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);
        }

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  If doTransferOut fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferOut(borrower, borrowAmount);
        require(vars.err == Error.NO_ERROR, "borrow transfer out failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a Borrow event */
        emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.borrowVerify(address(this), borrower, borrowAmount);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Sender repays their own borrow
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    /**
     * @notice Sender repays a borrow belonging to borrower
     * @param borrower the account with the debt being payed off
     * @param repayAmount The amount to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed
            return fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);
        }
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        return repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    struct RepayBorrowLocalVars {
        Error err;
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /**
     * @notice Borrows are repaid by another user (possibly the borrower).
     * @param payer the account paying off the borrow
     * @param borrower the account with the debt being payed off
     * @param repayAmount the amount of undelrying tokens being returned
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {
        /* Fail if repayBorrow not allowed */
        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);
        }

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(-1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }

        /* Fail if checkTransferIn fails */
        vars.err = checkTransferIn(payer, vars.repayAmount);
        if (vars.err != Error.NO_ERROR) {
            return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);
        }

        /*
         * We calculate the new borrower and total borrow balances, failing on underflow:
         *  accountBorrowsNew = accountBorrows - repayAmount
         *  totalBorrowsNew = totalBorrows - repayAmount
         */
        (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.repayAmount);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         * We call doTransferIn for the payer and the repayAmount
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken holds an additional repayAmount of cash.
         *  If doTransferIn fails despite the fact we checked pre-conditions,
         *   we revert because we can't be sure if side effects occurred.
         */
        vars.err = doTransferIn(payer, vars.repayAmount);
        require(vars.err == Error.NO_ERROR, "repay borrow transfer in failed");

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.repayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
        comptroller.repayBorrowVerify(address(this), payer, borrower, vars.repayAmount, vars.borrowerIndex);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice The sender liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowInternal(address borrower, uint repayAmount, CToken cTokenCollateral) internal nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);
        }

        error = cTokenCollateral.accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed
            return fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED);
        }

        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to
        return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);
    }

    /**
     * @notice The liquidator liquidates the borrowers collateral.
     *  The collateral seized is transferred to the liquidator.
     * @param borrower The borrower of this cToken to be liquidated
     * @param liquidator The address repaying the borrow and seizing collateral
     * @param cTokenCollateral The market in which to seize collateral from the borrower
     * @param repayAmount The amount of the underlying borrowed asset to repay
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns (uint) {
        /* Fail if liquidate not allowed */
        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed);
        }

        /* Verify market's block number equals current block number */
        if (accrualBlockNumber != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);
        }

        /* Verify cTokenCollateral market's block number equals current block number */
        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER);
        }

        /* Fail if repayAmount = 0 */
        if (repayAmount == 0) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO);
        }

        /* Fail if repayAmount = -1 */
        if (repayAmount == uint(-1)) {
            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX);
        }

        /* We calculate the number of collateral tokens that will be seized */
        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), repayAmount);
        if (amountSeizeError != 0) {
            return failOpaque(Error.COMPTROLLER_CALCULATION_ERROR, FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED, amountSeizeError);
        }

        /* Fail if seizeTokens > borrower collateral token balance */
        if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {
            return fail(Error.TOKEN_INSUFFICIENT_BALANCE, FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH);
        }

        /* Fail if repayBorrow fails */
        uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);
        if (repayBorrowError != uint(Error.NO_ERROR)) {
            return fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED);
        }

        /* Revert if seize tokens fails (since we cannot be sure of side effects) */
        uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);
        require(seizeError == uint(Error.NO_ERROR), "token seizure failed");

        /* We emit a LiquidateBorrow event */
        emit LiquidateBorrow(liquidator, borrower, repayAmount, address(cTokenCollateral), seizeTokens);

        /* We call the defense hook */
        comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount, seizeTokens);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Transfers collateral tokens (this market) to the liquidator.
     * @dev Will fail unless called by another cToken during the process of liquidation.
     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.
     * @param liquidator The account receiving seized collateral
     * @param borrower The account having collateral seized
     * @param seizeTokens The number of cTokens to seize
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), msg.sender, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        MathError mathErr;
        uint borrowerTokensNew;
        uint liquidatorTokensNew;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (mathErr, borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(mathErr));
        }

        (mathErr, liquidatorTokensNew) = addUInt(accountTokens[liquidator], seizeTokens);
        if (mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        accountTokens[borrower] = borrowerTokensNew;
        accountTokens[liquidator] = liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, seizeTokens);

        /* We call the defense hook */
        comptroller.seizeVerify(address(this), msg.sender, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      *
      * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = address(0);

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets a new comptroller for the market
      * @dev Admin function to set a new comptroller
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);
        }

        ComptrollerInterface oldComptroller = comptroller;
        // Ensure invoke comptroller.isComptroller() returns true
        require(newComptroller.isComptroller(), "marker method returned false");

        // Set market's comptroller to newComptroller
        comptroller = newComptroller;

        // Emit NewComptroller(oldComptroller, newComptroller)
        emit NewComptroller(oldComptroller, newComptroller);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh
      * @dev Admin function to accrue interest and set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.
            return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);
        }
        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.
        return _setReserveFactorFresh(newReserveFactorMantissa);
    }

    /**
      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)
      * @dev Admin function to set a new reserve factor
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);
        }

        // Verify market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);
        }

        // Check newReserveFactor ≤ maxReserveFactor
        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {
            return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);
        }

        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;

        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.
            return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);
        }
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        Error err;
        // totalReserves - reduceAmount
        uint totalReservesNew;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)
        if (reduceAmount > totalReserves) {
            return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, "reduce reserves unexpected underflow");

        // Store reserves[n+1] = reserves[n] - reduceAmount
        totalReserves = totalReservesNew;

        // invoke doTransferOut(reduceAmount, admin)
        err = doTransferOut(admin, reduceAmount);
        // we revert on the failure of this command
        require(err == Error.NO_ERROR, "reduce reserves transfer out failed");

        emit ReservesReduced(admin, reduceAmount, totalReservesNew);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh
     * @dev Admin function to accrue interest and update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
        uint error = accrueInterest();
        if (error != uint(Error.NO_ERROR)) {
            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed
            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);
        }
        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.
        return _setInterestRateModelFresh(newInterestRateModel);
    }

    /**
     * @notice updates the interest rate model (*requires fresh interest accrual)
     * @dev Admin function to update the interest rate model
     * @param newInterestRateModel the new interest rate model to use
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {

        // Used to store old model for use in the event that is emitted on success
        InterestRateModel oldInterestRateModel;

        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);
        }

        // We fail gracefully unless market's block number equals current block number
        if (accrualBlockNumber != getBlockNumber()) {
            // TODO: static_assert + no error code?
            return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);
        }

        // Track the market's current interest rate model
        oldInterestRateModel = interestRateModel;

        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true
        require(newInterestRateModel.isInterestRateModel(), "marker method returned false");

        // Set the interest rate model to newInterestRateModel
        interestRateModel = newInterestRateModel;

        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)
        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);

        return uint(Error.NO_ERROR);
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() internal view returns (uint);

    /**
     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and
     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.
     */
    function checkTransferIn(address from, uint amount) internal view returns (Error);

    /**
     * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.
     *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.
     */
    function doTransferIn(address from, uint amount) internal returns (Error);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) internal returns (Error);
}".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

