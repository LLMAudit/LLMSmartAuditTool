[2024-01-09 01:46:39 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901014639)

**Timestamp**: 20240901014639

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}


**project_name**: RealWorld_BA_124_GeneralIndexModule

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_124_GeneralIndexModule_RealWord_20240901014639.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 01:46:40 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Math } from "@openzeppelin/contracts/math/Math.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\n\nimport { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";\nimport { Invoke } from "../../lib/Invoke.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\nimport { Position } from "../../lib/Position.sol";\nimport { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";\nimport { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";\n\n\n/\n * @title GeneralIndexModule\n * @author Set Protocol\n \n * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().\n * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over\n * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed\n * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.\n * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-\n * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance\n * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component\'s\n * target allocation is met any further attempted trades of that component will revert.\n \n * SECURITY ASSUMPTION:\n *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using\n *    this module need to be examined separately)\n /\ncontract GeneralIndexModule is ModuleBase, ReentrancyGuard {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using Position for uint256;\n    using Math for uint256;\n    using Position for ISetToken;\n    using Invoke for ISetToken;\n    using AddressArrayUtils for address[];\n    using AddressArrayUtils for IERC20[];\n    using Uint256ArrayUtils for uint256[];\n\n    / ============ Struct ============ /\n\n    struct TradeExecutionParams {\n        uint256 targetUnit;              // Target unit of component for Set\n        uint256 maxSize;                 // Max trade size in precise units\n        uint256 coolOffPeriod;           // Required time between trades for the asset\n        uint256 lastTradeTimestamp;      // Timestamp of last trade\n        string exchangeName;             // Name of exchange adapter\n        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)\n    }\n\n    struct TradePermissionInfo {\n        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade\n        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal\n        mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade\n    }\n\n    struct RebalanceInfo {\n        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance\n        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)\n        address[] rebalanceComponents;      // Array of components involved in rebalance\n    }\n\n    struct TradeInfo {\n        ISetToken setToken;                         // Instance of SetToken\n        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter\n        address sendToken;                          // Address of token being sold\n        address receiveToken;                       // Address of token being bought\n        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token\n        uint256 setTotalSupply;                     // Total supply of Set (in precise units)\n        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded\n        uint256 sendQuantity;                       // Units of component sent to the exchange\n        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade\n        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought\n        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange\n    }\n\n    / ============ Events ============ /\n\n    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);\n    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);\n    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);\n    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);\n    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);\n    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);\n\n    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);\n    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);\n\n    event TradeExecuted(\n        ISetToken indexed _setToken,\n        address indexed _sellComponent,\n        address indexed _buyComponent,\n        IIndexExchangeAdapter _exchangeAdapter,\n        address _executor,\n        uint256 _netAmountSold,\n        uint256 _netAmountReceived,\n        uint256 _protocolFee\n    );\n\n    event RebalanceStarted(\n        ISetToken indexed _setToken,\n        address[] aggregateComponents,\n        uint256[] aggregateTargetUnits,\n        uint256 indexed positionMultiplier\n    );\n\n    / ============ Constants ============ /\n\n    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller\n\n    / ============ State Variables ============ /\n\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken\n    mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions\n    mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance\n    IWETH public immutable weth;                                                            // Weth contract address\n\n    / ============ Modifiers ============ /\n\n    modifier onlyAllowedTrader(ISetToken setToken) {\n        _validateOnlyAllowedTrader(_setToken);\n        ;\n    }\n\n    modifier onlyEOAIfUnrestricted(ISetToken setToken) {\n        _validateOnlyEOAIfUnrestricted(_setToken);\n        ;\n    }\n\n    / ============ Constructor ============ /\n\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n\n    / ============ External Functions ============ */\n\n    /\n     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager\n     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 1018\n     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the\n     * SetToken. If a component is being removed it\'s index in the _oldComponentsTargetUnits should be set to 0. Additionally, the\n     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs\n     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.\n     \n     * @param _setToken                         Address of the SetToken to be rebalanced\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units\n     *                                               if fees accrued\n     /\n    function startRebalance(\n        ISetToken _setToken,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits,\n        uint256 _positionMultiplier\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(\n            _setToken.getComponents(),\n            _newComponents,\n            _newComponentsTargetUnits,\n            _oldComponentsTargetUnits\n        );\n\n        for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {\n            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");\n            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];\n        }\n\n        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;\n        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;\n\n        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);\n    }\n\n    /\n     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().\n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.\n     \n     * Trade can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Trader can pass\n     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.\n     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default\n     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,\n     * if enabled, are collected in the token received in a trade.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _component            Address of SetToken component to trade\n     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade\n     /\n    function trade(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        _validateTradeParameters(_setToken, _component);\n\n        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);\n\n        _executeTrade(tradeInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n\n    /\n     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be\n     * traded such that resulting inflows won\'t exceed component\'s maxTradeSize nor overshoot the target unit. To be used near the end of rebalances\n     * when a component\'s calculated trade size is greater in value than remaining WETH.\n     \n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade\n     * can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Like with trade()\n     * a minimum component receive amount can be set.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _component                    Address of the SetToken component to trade\n     * @param _minComponentReceived        Min amount of component received during trade\n     /\n    function tradeRemainingWETH(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        require(_noTokensToSell(_setToken), "Sell other set components first");\n        require(\n            executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),\n            "WETH is below target unit"\n        );\n\n        _validateTradeParameters(_setToken, _component);\n\n        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);\n\n        _executeTrade(tradeInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n\n        require(\n            netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,\n            "Trade amount &gt; max trade size"\n        );\n\n        _validateComponentPositionUnit(_setToken, _component);\n\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n\n    /\n     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying\n     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,\n     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error\n     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components\n     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is\n     * spent buying the components to meet their new target.\n     \n     * @param _setToken             Address of the SetToken\n     /\n    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {\n        require(\n            _allTargetsMet(_setToken)\n            &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),\n            "Targets not met or ETH =~ 0"\n        );\n\n        // positionMultiplier / (10^18 + raiseTargetPercentage)\n        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087\n        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(\n            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)\n        );\n        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);\n    }\n\n    /\n     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.\n     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by\n     * default and trades will not execute if a component\'s trade size is greater than the maximum.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _tradeMaximums        Array of trade maximums mapping to correct component\n     /\n    function setTradeMaximums(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _tradeMaximums\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_tradeMaximums);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];\n            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeNames        Array of exchange names mapping to correct component\n     /\n    function setExchanges(\n        ISetToken _setToken,\n        address[] memory _components,\n        string[] memory _exchangeNames\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeNames);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            if (_components[i] != address(weth)) {\n\n                require(\n                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),\n                    "Unrecognized exchange name"\n                );\n\n                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];\n                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);\n            }\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _coolOffPeriods       Array of cool off periods to correct component\n     /\n    function setCoolOffPeriods(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _coolOffPeriods\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_coolOffPeriods);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];\n            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying\n     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeData         Array of exchange specific arbitrary bytes data\n     /\n    function setExchangeData(\n        ISetToken _setToken,\n        address[] memory _components,\n        bytes[] memory _exchangeData\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeData);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];\n            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set amount by which all component\'s targets units would be raised. Can be called at any time.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _raiseTargetPercentage        Amount to raise all component\'s unit targets by (in precise units)\n     /\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n\n    /\n     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.\n     \n     * @param _setToken          Address of the SetToken\n     * @param _traders           Array trader addresses to toggle status\n     * @param _statuses          Booleans indicating if matching trader can trade\n     /\n    function setTraderStatus(\n        ISetToken _setToken,\n        address[] memory _traders,\n        bool[] memory _statuses\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _traders.validatePairsWithArray(_statuses);\n\n        for (uint256 i = 0; i &lt; _traders.length; i++) {\n            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);\n            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];\n            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _status           Boolean indicating if anyone can trade\n     /\n    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {\n        permissionInfo[_setToken].anyoneTrade = _status;\n        emit AnyoneTradeUpdated(_setToken, _status);\n    }\n\n    /\n     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.\n     * Grabs the current units for each asset in the Set and set\'s the targetUnit to that unit in order to prevent any\n     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any\n     * position multiplier changes don\'t unintentionally open the Set for rebalancing.\n     \n     * @param _setToken         Address of the Set Token\n     /\n    function initialize(ISetToken _setToken)\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n\n        for (uint256 i = 0; i &lt; positions.length; i++) {\n            ISetToken.Position memory position = positions[i];\n            require(position.positionState == 0, "External positions not allowed");\n            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();\n            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;\n        }\n\n        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();\n        _setToken.initializeModule();\n    }\n\n    /\n     * Called by a SetToken to notify that this module was removed from the SetToken.\n     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.\n     * IMPORTANT: SetToken\'s execution settings, including trade maximums and exchange names,\n     * are NOT DELETED. Restoring a previously removed module requires that care is taken to\n     * initialize execution settings appropriately.\n     /\n    function removeModule() external override {\n        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];\n\n        for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {\n            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;\n        }\n\n        delete rebalanceInfo[ISetToken(msg.sender)];\n        delete permissionInfo[ISetToken(msg.sender)];\n    }\n\n    / ============ External View Functions ============ /\n\n    /\n     * Get the array of SetToken components involved in rebalance.\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]        Array of _setToken components involved in rebalance\n     /\n    function getRebalanceComponents(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return rebalanceInfo[_setToken].rebalanceComponents;\n    }\n\n    /\n     * Calculates the amount of a component that is going to be traded and whether the component is being bought\n     * or sold. If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return componentQuantity        Amount of component being traded\n     */\n    function getComponentTradeQuantityAndDirection(\n        ISetToken _setToken,\n        IERC20 _component\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool, uint256)\n    {\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not recognized"\n        );\n        uint256 totalSupply = _setToken.totalSupply();\n        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);\n    }\n\n\n    /\n     * Get if a given address is an allowed trader.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _trader           Address of the trader\n     \n     * @return bool             True if _trader is allowed to trade, else false\n     /\n    function getIsAllowedTrader(ISetToken _setToken, address _trader)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool)\n    {\n        return _isAllowedTrader(_setToken, _trader);\n    }\n\n    /\n     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]\n     /\n    function getAllowedTraders(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return permissionInfo[_setToken].tradersHistory;\n    }\n\n    / ============ Internal Functions ============ /\n\n    /\n     * A rebalance is a multi-step process in which current Set components are sold for a\n     * bridge asset (WETH) before buying target components in the correct amount to achieve\n     * the desired balance between elements in the set.\n     \n     *        Step 1        |       Step 2\n     * -------------------------------------------\n     * Component --&gt; WETH   |   WETH --&gt; Component\n     * -------------------------------------------\n     \n     * The syntax we use frames this as trading from a "fixed" amount of one component to a\n     * "fixed" amount of another via a "floating limit" which is either the maximum size of\n     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum\n     * amount of tokens we expect to receive. The different meanings of the floating limit map to\n     * the trade sequence as below:\n     \n     * Step 1: Component --&gt; WETH\n     * ----------------------------------------------------------\n     *                     | Fixed  |     Floating limit        |\n     * ----------------------------------------------------------\n     * send  (Component)   |  YES   |                           |\n     * recieve (WETH)      |        |   Min WETH to receive     |\n     * ----------------------------------------------------------\n     \n     * Step 2: WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     |  Fixed  |    Floating limit        |\n     * ----------------------------------------------------------\n     * send  (WETH)        |   NO    |  Max WETH to send        |\n     * recieve (Component) |   YES   |                          |\n     * ----------------------------------------------------------\n     \n     * Additionally, there is an edge case where price volatility during a rebalance\n     * results in remaining WETH which needs to be allocated proportionately. In this case\n     * the values are as below:\n     \n     * Edge case: Remaining WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     | Fixed  |    Floating limit         |\n     * ----------------------------------------------------------\n     * send  (WETH)        |  YES   |                           |\n     * recieve (Component) |        | Min component to receive  |\n     * ----------------------------------------------------------\n    */\n\n    /\n     * Create and return TradeInfo struct. This function reverts if the target has already been met.\n     * If this is a trade from component into WETH, sell the total fixed component quantity\n     * and expect to receive an ETH amount the user has specified (or more). If it\'s a trade from\n     * WETH into a component, sell the lesser of: the user\'s WETH limit OR the SetToken\'s\n     * remaining WETH balance and expect to receive a fixed component quantity.\n     \n     * @param _setToken             Instance of the SetToken to rebalance\n     * @param _component            IERC20 component to trade\n     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade\n     \n     * @return tradeInfo            Struct containing data for trade\n     /\n    function _createTradeInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        internal\n        view\n        virtual\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);\n\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;\n            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;\n        } else {\n            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);\n            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;\n        }\n    }\n\n    /\n     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param _minComponentReceived         Min amount of component received during trade\n     \n     * @return tradeInfo                    Struct containing data for tradeRemaining info\n     /\n    function _createTradeRemainingInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);\n\n        (,,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);\n\n        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);\n        tradeInfo.floatingQuantityLimit = _minComponentReceived;\n        tradeInfo.isSendTokenFixed = true;\n    }\n\n    /\n     * Create and returns a partial TradeInfo struct with all fields that overlap between trade\n     * and tradeRemaining info constructors filled in. Values for sendQuantity and floatingQuantityLimit\n     * are derived separately, outside this method. trade requires that trade size and direction are\n     * calculated, whereas tradeRemaining automatically sets WETH as the sendToken and _component\n     * as receiveToken.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction\n     \n     * @return tradeInfo                    Struct containing partial data for trade\n     */\n    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo.setToken = _setToken;\n        tradeInfo.setTotalSupply = _setToken.totalSupply();\n        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);\n        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;\n\n        if(calculateTradeDirection){\n            (\n                tradeInfo.isSendTokenFixed,\n                tradeInfo.totalFixedQuantity\n            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);\n        }\n\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendToken = address(_component);\n            tradeInfo.receiveToken = address(weth);\n        } else {\n            tradeInfo.sendToken = address(weth);\n            tradeInfo.receiveToken = address(_component);\n        }\n\n        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));\n        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));\n    }\n\n    /\n     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed\n     * quantity of a token in return for a non-fixed (floating) quantity of a token. If isSendTokenFixed is true then the adapter\n     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for\n     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.\n     \n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     /\n    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {\n        _tradeInfo.setToken.invokeApprove(\n            _tradeInfo.sendToken,\n            _tradeInfo.exchangeAdapter.getSpender(),\n            _tradeInfo.sendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(\n            _tradeInfo.sendToken,\n            _tradeInfo.receiveToken,\n            address(_tradeInfo.setToken),\n            _tradeInfo.isSendTokenFixed,\n            _tradeInfo.sendQuantity,\n            _tradeInfo.floatingQuantityLimit,\n            _tradeInfo.exchangeData\n        );\n\n        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);\n    }\n\n    /\n     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.\n     * The protocol fee is collected from the amount of received token in the trade.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     \n     * @return protocolFee              Amount of receive token taken as protocol fee\n     */\n    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {\n        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)\n            .balanceOf(address(_tradeInfo.setToken))\n            .sub(_tradeInfo.preTradeReceiveTokenBalance);\n\n        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);\n        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);\n    }\n\n    /\n     * Update SetToken positions and executionInfo\'s last trade timestamp. This function is intended\n     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     * @param _component                IERC20 component which was traded\n     \n     * @return netSendAmount            Amount of sendTokens used in the trade\n     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)\n     /\n    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)\n        internal\n        returns (uint256 netSendAmount, uint256 netReceiveAmount)\n    {\n        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.sendToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeSendTokenBalance\n        );\n        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.receiveToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeReceiveTokenBalance\n        );\n\n        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);\n        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);\n\n        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;\n    }\n\n    /\n     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It\'s\n     * necessary to verify that traderHistory contains the address because AddressArrayUtils will\n     * throw when attempting to remove a non-element and it\'s possible someone can set a new\n     * trader\'s status to false.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _trader                           Trader whose permission is being set\n     * @param _status                           Boolean permission being set\n\n     /\n    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {\n        if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.push(_trader);\n        } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);\n        }\n    }\n\n    /\n     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.\n     * If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     * @param _totalSupply              Total supply of _setToken\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return totalFixedQuantity       Amount of fixed token to send or receive\n     /\n    function _calculateTradeSizeAndDirection(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _totalSupply\n    )\n        internal\n        view\n        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)\n    {\n        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);\n        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;\n\n        (\n            uint256 currentUnit,\n            uint256 targetUnit,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);\n\n        require(currentUnit != targetUnit, "Target already met");\n\n        isSendTokenFixed = targetNotional &lt; currentNotional;\n\n        // In order to account for fees taken by protocol when buying the notional difference between currentUnit\n        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to\n        // do so would lead to never being able to meet target of components that need to be bought.\n        //\n        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))\n        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)\n        totalFixedQuantity = isSendTokenFixed\n            ? componentMaxSize.min(currentNotional.sub(targetNotional))\n            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));\n    }\n\n    /\n     * Check if all targets are met.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if all component\'s target units have been met, otherwise false\n     */\n    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }\n        }\n        return true;\n    }\n\n    /\n     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise\n     * needs to be approved.\n     \n     * @param _setToken             Instance of SetToken to be rebalanced\n     * @param  _trader              Address of the trader who called contract function\n     \n     * @return bool                 True if trader is an approved trader for the SetToken\n     /\n    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {\n        TradePermissionInfo storage permissions = permissionInfo[_setToken];\n        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];\n    }\n\n    /\n     * Checks if sell conditions are met. The component cannot be WETH and its normalized target\n     * unit must be less than its default position real unit\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component evaluated for sale\n     \n     * @return bool                             True if sell allowed, false otherwise\n     /\n    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {\n        return (\n            _component != address(weth) &amp;&amp;\n            (\n                _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;\n                _getDefaultPositionRealUnit(_setToken,IERC20(_component))\n            )\n        );\n    }\n\n    /\n     * Check if there are any more tokens to sell. Since we allow WETH to float around it\'s target during rebalances it is not checked.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if there is not any component that can be sold, otherwise false\n     */\n    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }\n        }\n        return true;\n    }\n\n    /\n     * Determines if a target is met. Due to small rounding errors converting between virtual and\n     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to\n     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not\n     * checked as it is allowed to float around its target.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component whose target is evaluated\n     \n     * @return bool                             True if component\'s target units are met, false otherwise\n     /\n    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {\n        if (_component == address(weth)) return false;\n\n        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));\n\n        return (normalizedTargetUnit &gt; 0)\n            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))\n            : normalizedTargetUnit != currentUnit;\n    }\n\n    /\n     * Validate component position unit has not exceeded it\'s target unit. This is used during tradeRemainingWETH() to make sure\n     * the amount of component bought does not exceed the targetUnit.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component whose position units are to be validated\n     /\n    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n        require(currentUnit &lt;= targetUnit, "Can not exceed target unit");\n    }\n\n    /\n     * Validate that component is a valid component and enough time has elapsed since component\'s last trade. Traders\n     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to be validated\n     /\n    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {\n        require(address(_component) != address(weth), "Can not explicitly trade WETH");\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not part of rebalance"\n        );\n\n        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];\n        require(\n            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,\n            "Component cool off in progress"\n        );\n\n        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");\n    }\n\n    /\n     * Extends and/or updates the current component set and its target units with new components and targets,\n     * Validates inputs, requiring that that new components and new target units arrays are the same size, and\n     * that the number of old components target units matches the number of current components. Throws if\n     * a duplicate component has been added.\n     \n     * @param  _currentComponents               Complete set of current SetToken components\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     \n     * @return aggregateComponents              Array of current components extended by new components, without duplicates\n     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates\n     /\n    function _getAggregateComponentsAndUnits(\n        address[] memory _currentComponents,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits\n    )\n        internal\n        pure\n        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)\n    {\n        // Don\'t use validate arrays because empty arrays are valid\n        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");\n        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");\n\n        aggregateComponents = _currentComponents.extend(_newComponents);\n        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);\n\n        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");\n    }\n\n    /\n     * Get the SetToken\'s default position as uint256\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to fetch the default position for\n     \n     * return uint256           Real unit position\n     */\n    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {\n        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();\n    }\n\n    /\n     * Gets exchange adapter address for a component after checking that it exists in the\n     * IntegrationRegistry. This method is called during a trade and must validate the adapter\n     * because its state may have changed since it was set in a separate transaction.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        IERC20 component whose exchange adapter is fetched\n     \n     * @return IExchangeAdapter                 Adapter address\n     /\n    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {\n        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));\n    }\n\n    /\n     * Calculates and returns the normalized target unit value.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     * @param _component            IERC20 component whose normalized target unit is required\n     \n     * @return uint256                          Normalized target unit of the component\n     /\n    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {\n        // (targetUnit * current position multiplier) / position multiplier when rebalance started\n        return executionInfo[_setToken][_component]\n            .targetUnit\n            .mul(_setToken.positionMultiplier().toUint256())\n            .div(rebalanceInfo[_setToken].positionMultiplier);\n    }\n\n    /\n     * Gets unit and notional amount values for current position and target. These are necessary\n     * to calculate the trade size and direction for regular trades and the sendQuantity for\n     * remainingWEth trades.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to calculate notional amounts for\n     * @param _totalSupply              SetToken total supply\n     \n     * @return uint256              Current default position real unit of component\n     * @return uint256              Normalized unit of the trade target\n     * @return uint256              Current notional amount: total notional amount of SetToken default position\n     * @return uint256              Target notional amount: Total SetToken supply * targetUnit\n     /\n    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)\n        internal\n        view\n        returns (uint256, uint256, uint256, uint256)\n    {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n\n        return (\n            currentUnit,\n            targetUnit,\n            _totalSupply.getDefaultTotalNotional(currentUnit),\n            _totalSupply.preciseMulCeil(targetUnit)\n        );\n    }\n\n    / ============== Modifier Helpers ===============\n     * Internal functions used to reduce bytecode size\n     /\n\n    /\n     * Trader must be permissioned for SetToken\n     /\n    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {\n        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");\n    }\n\n    /\n     * Trade must be an EOA if anyoneTrade has been enabled for SetToken on the module.\n     */\n    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {\n        if(permissionInfo[_setToken].anyoneTrade) {\n            require(msg.sender == tx.origin, "Caller must be EOA Address");\n        }\n    }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 01:46:40 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 01:46:40 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 01:46:43 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 01:46:43 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 23179
completion_tokens: 1
total_tokens: 23180
cost: $-1.000000


[2024-01-09 01:46:43 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Let's

[2024-01-09 01:46:46 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: /\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Math } from "@openzeppelin/contracts/math/Math.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\nimport { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";\nimport { Invoke } from "../../lib/Invoke.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\nimport { Position } from "../../lib/Position.sol";\nimport { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";\nimport { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";\n\n/\n * @title GeneralIndexModule\n * @author Set Protocol\n \n * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().\n * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over\n * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed\n * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.\n * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-\n * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance\n * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component\'s\n * target allocation is met any further attempted trades of that component will revert.\n \n * SECURITY ASSUMPTION:\n *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using\n *    this module need to be examined separately)\n /\ncontract GeneralIndexModule is ModuleBase, ReentrancyGuard {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using Position for uint256;\n    using Math for uint256;\n    using Position for ISetToken;\n    using Invoke for ISetToken;\n    using AddressArrayUtils for address[];\n    using AddressArrayUtils for IERC20[];\n    using Uint256ArrayUtils for uint256[];\n    / ============ Struct ============ /\n    struct TradeExecutionParams {\n        uint256 targetUnit;              // Target unit of component for Set\n        uint256 maxSize;                 // Max trade size in precise units\n        uint256 coolOffPeriod;           // Required time between trades for the asset\n        uint256 lastTradeTimestamp;      // Timestamp of last trade\n        string exchangeName;             // Name of exchange adapter\n        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)\n    }\n    struct TradePermissionInfo {\n        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade\n        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal\n        mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade\n    }\n    struct RebalanceInfo {\n        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance\n        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)\n        address[] rebalanceComponents;      // Array of components involved in rebalance\n    }\n    struct TradeInfo {\n        ISetToken setToken;                         // Instance of SetToken\n        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter\n        address sendToken;                          // Address of token being sold\n        address receiveToken;                       // Address of token being bought\n        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token\n        uint256 setTotalSupply;                     // Total supply of Set (in precise units)\n        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded\n        uint256 sendQuantity;                       // Units of component sent to the exchange\n        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade\n        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought\n        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange\n    }\n    / ============ Events ============ /\n    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);\n    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);\n    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);\n    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);\n    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);\n    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);\n    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);\n    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);\n    event TradeExecuted(\n        ISetToken indexed _setToken,\n        address indexed _sellComponent,\n        address indexed _buyComponent,\n        IIndexExchangeAdapter _exchangeAdapter,\n        address _executor,\n        uint256 _netAmountSold,\n        uint256 _netAmountReceived,\n        uint256 _protocolFee\n    );\n    event RebalanceStarted(\n        ISetToken indexed _setToken,\n        address[] aggregateComponents,\n        uint256[] aggregateTargetUnits,\n        uint256 indexed positionMultiplier\n    );\n    / ============ Constants ============ /\n    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller\n    / ============ State Variables ============ /\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken\n    mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions\n    mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance\n    IWETH public immutable weth;                                                            // Weth contract address\n    / ============ Modifiers ============ /\n    modifier onlyAllowedTrader(ISetToken setToken) {\n        _validateOnlyAllowedTrader(_setToken);\n        ;\n    }\n    modifier onlyEOAIfUnrestricted(ISetToken setToken) {\n        _validateOnlyEOAIfUnrestricted(_setToken);\n        ;\n    }\n    / ============ Constructor ============ /\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n    / ============ External Functions ============ */\n    /\n     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager\n     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 1018\n     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the\n     * SetToken. If a component is being removed it\'s index in the _oldComponentsTargetUnits should be set to 0. Additionally, the\n     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs\n     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.\n     \n     * @param _setToken                         Address of the SetToken to be rebalanced\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units\n     *                                               if fees accrued\n     /\n    function startRebalance(\n        ISetToken _setToken,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits,\n        uint256 _positionMultiplier\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(\n            _setToken.getComponents(),\n            _newComponents,\n            _newComponentsTargetUnits,\n            _oldComponentsTargetUnits\n        );\n        for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {\n            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");\n            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];\n        }\n        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;\n        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;\n        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);\n    }\n    /\n     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().\n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.\n     \n     * Trade can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Trader can pass\n     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.\n     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default\n     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,\n     * if enabled, are collected in the token received in a trade.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _component            Address of SetToken component to trade\n     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade\n     /\n    function trade(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        _validateTradeParameters(_setToken, _component);\n        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);\n        _executeTrade(tradeInfo);\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n    /\n     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be\n     * traded such that resulting inflows won\'t exceed component\'s maxTradeSize nor overshoot the target unit. To be used near the end of rebalances\n     * when a component\'s calculated trade size is greater in value than remaining WETH.\n     \n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade\n     * can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Like with trade()\n     * a minimum component receive amount can be set.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _component                    Address of the SetToken component to trade\n     * @param _minComponentReceived        Min amount of component received during trade\n     /\n    function tradeRemainingWETH(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        require(_noTokensToSell(_setToken), "Sell other set components first");\n        require(\n            executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),\n            "WETH is below target unit"\n        );\n        _validateTradeParameters(_setToken, _component);\n        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);\n        _executeTrade(tradeInfo);\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n        require(\n            netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,\n            "Trade amount &gt; max trade size"\n        );\n        _validateComponentPositionUnit(_setToken, _component);\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n    /\n     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying\n     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,\n     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error\n     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components\n     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is\n     * spent buying the components to meet their new target.\n     \n     * @param _setToken             Address of the SetToken\n     /\n    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {\n        require(\n            _allTargetsMet(_setToken)\n            &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),\n            "Targets not met or ETH =~ 0"\n        );\n        // positionMultiplier / (10^18 + raiseTargetPercentage)\n        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087\n        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(\n            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)\n        );\n        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);\n    }\n    /\n     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.\n     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by\n     * default and trades will not execute if a component\'s trade size is greater than the maximum.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _tradeMaximums        Array of trade maximums mapping to correct component\n     /\n    function setTradeMaximums(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _tradeMaximums\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_tradeMaximums);\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];\n            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);\n        }\n    }\n    /\n     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeNames        Array of exchange names mapping to correct component\n     /\n    function setExchanges(\n        ISetToken _setToken,\n        address[] memory _components,\n        string[] memory _exchangeNames\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeNames);\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            if (_components[i] != address(weth)) {\n                require(\n                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),\n                    "Unrecognized exchange name"\n                );\n                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];\n                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);\n            }\n        }\n    }\n    /\n     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _coolOffPeriods       Array of cool off periods to correct component\n     /\n    function setCoolOffPeriods(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _coolOffPeriods\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_coolOffPeriods);\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];\n            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);\n        }\n    }\n    /\n     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying\n     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeData         Array of exchange specific arbitrary bytes data\n     /\n    function setExchangeData(\n        ISetToken _setToken,\n        address[] memory _components,\n        bytes[] memory _exchangeData\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeData);\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];\n            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);\n        }\n    }\n    /\n     * MANAGER ONLY: Set amount by which all component\'s targets units would be raised. Can be called at any time.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _raiseTargetPercentage        Amount to raise all component\'s unit targets by (in precise units)\n     /\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n    /\n     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.\n     \n     * @param _setToken          Address of the SetToken\n     * @param _traders           Array trader addresses to toggle status\n     * @param _statuses          Booleans indicating if matching trader can trade\n     /\n    function setTraderStatus(\n        ISetToken _setToken,\n        address[] memory _traders,\n        bool[] memory _statuses\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _traders.validatePairsWithArray(_statuses);\n        for (uint256 i = 0; i &lt; _traders.length; i++) {\n            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);\n            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];\n            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);\n        }\n    }\n    /\n     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _status           Boolean indicating if anyone can trade\n     /\n    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {\n        permissionInfo[_setToken].anyoneTrade = _status;\n        emit AnyoneTradeUpdated(_setToken, _status);\n    }\n    /\n     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.\n     * Grabs the current units for each asset in the Set and set\'s the targetUnit to that unit in order to prevent any\n     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any\n     * position multiplier changes don\'t unintentionally open the Set for rebalancing.\n     \n     * @param _setToken         Address of the Set Token\n     /\n    function initialize(ISetToken _setToken)\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n        for (uint256 i = 0; i &lt; positions.length; i++) {\n            ISetToken.Position memory position = positions[i];\n            require(position.positionState == 0, "External positions not allowed");\n            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();\n            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;\n        }\n        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();\n        _setToken.initializeModule();\n    }\n    /\n     * Called by a SetToken to notify that this module was removed from the SetToken.\n     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.\n     * IMPORTANT: SetToken\'s execution settings, including trade maximums and exchange names,\n     * are NOT DELETED. Restoring a previously removed module requires that care is taken to\n     * initialize execution settings appropriately.\n     /\n    function removeModule() external override {\n        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];\n        for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {\n            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;\n        }\n        delete rebalanceInfo[ISetToken(msg.sender)];\n        delete permissionInfo[ISetToken(msg.sender)];\n    }\n    / ============ External View Functions ============ /\n    /\n     * Get the array of SetToken components involved in rebalance.\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]        Array of _setToken components involved in rebalance\n     /\n    function getRebalanceComponents(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return rebalanceInfo[_setToken].rebalanceComponents;\n    }\n    /\n     * Calculates the amount of a component that is going to be traded and whether the component is being bought\n     * or sold. If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return componentQuantity        Amount of component being traded\n     */\n    function getComponentTradeQuantityAndDirection(\n        ISetToken _setToken,\n        IERC20 _component\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool, uint256)\n    {\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not recognized"\n        );\n        uint256 totalSupply = _setToken.totalSupply();\n        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);\n    }\n\n    /\n     * Get if a given address is an allowed trader.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _trader           Address of the trader\n     \n     * @return bool             True if _trader is allowed to trade, else false\n     /\n    function getIsAllowedTrader(ISetToken _setToken, address _trader)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool)\n    {\n        return _isAllowedTrader(_setToken, _trader);\n    }\n    /\n     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]\n     /\n    function getAllowedTraders(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return permissionInfo[_setToken].tradersHistory;\n    }\n    / ============ Internal Functions ============ /\n    /\n     * A rebalance is a multi-step process in which current Set components are sold for a\n     * bridge asset (WETH) before buying target components in the correct amount to achieve\n     * the desired balance between elements in the set.\n     \n     *        Step 1        |       Step 2\n     * -------------------------------------------\n     * Component --&gt; WETH   |   WETH --&gt; Component\n     * -------------------------------------------\n     \n     * The syntax we use frames this as trading from a "fixed" amount of one component to a\n     * "fixed" amount of another via a "floating limit" which is either the maximum size of\n     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum\n     * amount of tokens we expect to receive. The different meanings of the floating limit map to\n     * the trade sequence as below:\n     \n     * Step 1: Component --&gt; WETH\n     * ----------------------------------------------------------\n     *                     | Fixed  |     Floating limit        |\n     * ----------------------------------------------------------\n     * send  (Component)   |  YES   |                           |\n     * recieve (WETH)      |        |   Min WETH to receive     |\n     * ----------------------------------------------------------\n     \n     * Step 2: WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     |  Fixed  |    Floating limit        |\n     * ----------------------------------------------------------\n     * send  (WETH)        |   NO    |  Max WETH to send        |\n     * recieve (Component) |   YES   |                          |\n     * ----------------------------------------------------------\n     \n     * Additionally, there is an edge case where price volatility during a rebalance\n     * results in remaining WETH which needs to be allocated proportionately. In this case\n     * the values are as below:\n     \n     * Edge case: Remaining WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     | Fixed  |    Floating limit         |\n     * ----------------------------------------------------------\n     * send  (WETH)        |  YES   |                           |\n     * recieve (Component) |        | Min component to receive  |\n     * ----------------------------------------------------------\n    */\n    /\n     * Create and return TradeInfo struct. This function reverts if the target has already been met.\n     * If this is a trade from component into WETH, sell the total fixed component quantity\n     * and expect to receive an ETH amount the user has specified (or more). If it\'s a trade from\n     * WETH into a component, sell the lesser of: the user\'s WETH limit OR the SetToken\'s\n     * remaining WETH balance and expect to receive a fixed component quantity.\n     \n     * @param _setToken             Instance of the SetToken to rebalance\n     * @param _component            IERC20 component to trade\n     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade\n     \n     * @return tradeInfo            Struct containing data for trade\n     /\n    function _createTradeInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        internal\n        view\n        virtual\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;\n            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;\n        } else {\n            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);\n            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;\n        }\n    }\n    /\n     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param _minComponentReceived         Min amount of component received during trade\n     \n     * @return tradeInfo                    Struct containing data for tradeRemaining info\n     /\n    function _createTradeRemainingInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);\n        (,,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);\n        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);\n        tradeInfo.floatingQuantityLimit = _minComponentReceived;\n        tradeInfo.isSendTokenFixed = true;\n    }\n    /\n     * Create and returns a partial TradeInfo struct with all fields that overlap between trade\n     * and tradeRemaining info constructors filled in. Values for sendQuantity and floatingQuantityLimit\n     * are derived separately, outside this method. trade requires that trade size and direction are\n     * calculated, whereas tradeRemaining automatically sets WETH as the sendToken and _component\n     * as receiveToken.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction\n     \n     * @return tradeInfo                    Struct containing partial data for trade\n     */\n    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo.setToken = _setToken;\n        tradeInfo.setTotalSupply = _setToken.totalSupply();\n        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);\n        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;\n        if(calculateTradeDirection){\n            (\n                tradeInfo.isSendTokenFixed,\n                tradeInfo.totalFixedQuantity\n            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);\n        }\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendToken = address(_component);\n            tradeInfo.receiveToken = address(weth);\n        } else {\n            tradeInfo.sendToken = address(weth);\n            tradeInfo.receiveToken = address(_component);\n        }\n        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));\n        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));\n    }\n    /\n     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed\n     * quantity of a token in return for a non-fixed (floating) quantity of a token. If isSendTokenFixed is true then the adapter\n     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for\n     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.\n     \n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     /\n    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {\n        _tradeInfo.setToken.invokeApprove(\n            _tradeInfo.sendToken,\n            _tradeInfo.exchangeAdapter.getSpender(),\n            _tradeInfo.sendQuantity\n        );\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(\n            _tradeInfo.sendToken,\n            _tradeInfo.receiveToken,\n            address(_tradeInfo.setToken),\n            _tradeInfo.isSendTokenFixed,\n            _tradeInfo.sendQuantity,\n            _tradeInfo.floatingQuantityLimit,\n            _tradeInfo.exchangeData\n        );\n        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);\n    }\n    /\n     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.\n     * The protocol fee is collected from the amount of received token in the trade.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     \n     * @return protocolFee              Amount of receive token taken as protocol fee\n     */\n    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {\n        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)\n            .balanceOf(address(_tradeInfo.setToken))\n            .sub(_tradeInfo.preTradeReceiveTokenBalance);\n        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);\n        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);\n    }\n    /\n     * Update SetToken positions and executionInfo\'s last trade timestamp. This function is intended\n     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     * @param _component                IERC20 component which was traded\n     \n     * @return netSendAmount            Amount of sendTokens used in the trade\n     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)\n     /\n    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)\n        internal\n        returns (uint256 netSendAmount, uint256 netReceiveAmount)\n    {\n        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.sendToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeSendTokenBalance\n        );\n        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.receiveToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeReceiveTokenBalance\n        );\n        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);\n        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);\n        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;\n    }\n    /\n     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It\'s\n     * necessary to verify that traderHistory contains the address because AddressArrayUtils will\n     * throw when attempting to remove a non-element and it\'s possible someone can set a new\n     * trader\'s status to false.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _trader                           Trader whose permission is being set\n     * @param _status                           Boolean permission being set\n     /\n    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {\n        if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.push(_trader);\n        } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);\n        }\n    }\n    /\n     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.\n     * If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     * @param _totalSupply              Total supply of _setToken\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return totalFixedQuantity       Amount of fixed token to send or receive\n     /\n    function _calculateTradeSizeAndDirection(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _totalSupply\n    )\n        internal\n        view\n        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)\n    {\n        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);\n        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;\n        (\n            uint256 currentUnit,\n            uint256 targetUnit,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);\n        require(currentUnit != targetUnit, "Target already met");\n        isSendTokenFixed = targetNotional &lt; currentNotional;\n        // In order to account for fees taken by protocol when buying the notional difference between currentUnit\n        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to\n        // do so would lead to never being able to meet target of components that need to be bought.\n        //\n        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))\n        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)\n        totalFixedQuantity = isSendTokenFixed\n            ? componentMaxSize.min(currentNotional.sub(targetNotional))\n            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));\n    }\n    /\n     * Check if all targets are met.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if all component\'s target units have been met, otherwise false\n     */\n    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }\n        }\n        return true;\n    }\n    /\n     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise\n     * needs to be approved.\n     \n     * @param _setToken             Instance of SetToken to be rebalanced\n     * @param  _trader              Address of the trader who called contract function\n     \n     * @return bool                 True if trader is an approved trader for the SetToken\n     /\n    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {\n        TradePermissionInfo storage permissions = permissionInfo[_setToken];\n        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];\n    }\n    /\n     * Checks if sell conditions are met. The component cannot be WETH and its normalized target\n     * unit must be less than its default position real unit\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component evaluated for sale\n     \n     * @return bool                             True if sell allowed, false otherwise\n     /\n    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {\n        return (\n            _component != address(weth) &amp;&amp;\n            (\n                _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;\n                _getDefaultPositionRealUnit(_setToken,IERC20(_component))\n            )\n        );\n    }\n    /\n     * Check if there are any more tokens to sell. Since we allow WETH to float around it\'s target during rebalances it is not checked.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if there is not any component that can be sold, otherwise false\n     */\n    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }\n        }\n        return true;\n    }\n    /\n     * Determines if a target is met. Due to small rounding errors converting between virtual and\n     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to\n     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not\n     * checked as it is allowed to float around its target.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component whose target is evaluated\n     \n     * @return bool                             True if component\'s target units are met, false otherwise\n     /\n    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {\n        if (_component == address(weth)) return false;\n        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));\n        return (normalizedTargetUnit &gt; 0)\n            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))\n            : normalizedTargetUnit != currentUnit;\n    }\n    /\n     * Validate component position unit has not exceeded it\'s target unit. This is used during tradeRemainingWETH() to make sure\n     * the amount of component bought does not exceed the targetUnit.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component whose position units are to be validated\n     /\n    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n        require(currentUnit &lt;= targetUnit, "Can not exceed target unit");\n    }\n    /\n     * Validate that component is a valid component and enough time has elapsed since component\'s last trade. Traders\n     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to be validated\n     /\n    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {\n        require(address(_component) != address(weth), "Can not explicitly trade WETH");\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not part of rebalance"\n        );\n        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];\n        require(\n            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,\n            "Component cool off in progress"\n        );\n        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");\n    }\n    /\n     * Extends and/or updates the current component set and its target units with new components and targets,\n     * Validates inputs, requiring that that new components and new target units arrays are the same size, and\n     * that the number of old components target units matches the number of current components. Throws if\n     * a duplicate component has been added.\n     \n     * @param  _currentComponents               Complete set of current SetToken components\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     \n     * @return aggregateComponents              Array of current components extended by new components, without duplicates\n     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates\n     /\n    function _getAggregateComponentsAndUnits(\n        address[] memory _currentComponents,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits\n    )\n        internal\n        pure\n        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)\n    {\n        // Don\'t use validate arrays because empty arrays are valid\n        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");\n        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");\n        aggregateComponents = _currentComponents.extend(_newComponents);\n        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);\n        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");\n    }\n    /\n     * Get the SetToken\'s default position as uint256\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to fetch the default position for\n     \n     * return uint256           Real unit position\n     */\n    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {\n        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();\n    }\n    /\n     * Gets exchange adapter address for a component after checking that it exists in the\n     * IntegrationRegistry. This method is called during a trade and must validate the adapter\n     * because its state may have changed since it was set in a separate transaction.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        IERC20 component whose exchange adapter is fetched\n     \n     * @return IExchangeAdapter                 Adapter address\n     /\n    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {\n        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));\n    }\n    /\n     * Calculates and returns the normalized target unit value.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     * @param _component            IERC20 component whose normalized target unit is required\n     \n     * @return uint256                          Normalized target unit of the component\n     /\n    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {\n        // (targetUnit * current position multiplier) / position multiplier when rebalance started\n        return executionInfo[_setToken][_component]\n            .targetUnit\n            .mul(_setToken.positionMultiplier().toUint256())\n            .div(rebalanceInfo[_setToken].positionMultiplier);\n    }\n    /\n     * Gets unit and notional amount values for current position and target. These are necessary\n     * to calculate the trade size and direction for regular trades and the sendQuantity for\n     * remainingWEth trades.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to calculate notional amounts for\n     * @param _totalSupply              SetToken total supply\n     \n     * @return uint256              Current default position real unit of component\n     * @return uint256              Normalized unit of the trade target\n     * @return uint256              Current notional amount: total notional amount of SetToken default position\n     * @return uint256              Target notional amount: Total SetToken supply * targetUnit\n     /\n    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)\n        internal\n        view\n        returns (uint256, uint256, uint256, uint256)\n    {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n        return (\n            currentUnit,\n            targetUnit,\n            _totalSupply.getDefaultTotalNotional(currentUnit),\n            _totalSupply.preciseMulCeil(targetUnit)\n        );\n    }\n    / ============== Modifier Helpers ===============\n     * Internal functions used to reduce bytecode size\n     /\n    /\n     * Trader must be permissioned for SetToken\n     /\n    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {\n        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");\n    }\n    /\n     * Trade must be an EOA if anyoneTrade has been enabled for SetToken on the module.\n     /\n    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {\n        if(permissionInfo[_setToken].anyoneTrade) {\n            require(msg.sender == tx.origin, "Caller must be EOA Address");\n        }\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "/\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Math } from "@openzeppelin/contracts/math/Math.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\nimport { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";\nimport { Invoke } from "../../lib/Invoke.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\nimport { Position } from "../../lib/Position.sol";\nimport { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";\nimport { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";\n\n/\n * @title GeneralIndexModule\n * @author Set Protocol\n \n * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().\n * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over\n * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed\n * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.\n * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-\n * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance\n * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component\'s\n * target allocation is met any further attempted trades of that component will revert.\n \n * SECURITY ASSUMPTION:\n *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using\n *    this module need to be examined separately)\n /\ncontract GeneralIndexModule is ModuleBase, ReentrancyGuard {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using Position for uint256;\n    using Math for uint256;\n    using Position for ISetToken;\n    using Invoke for ISetToken;\n    using AddressArrayUtils for address[];\n    using AddressArrayUtils for IERC20[];\n    using Uint256ArrayUtils for uint256[];\n    / ============ Struct ============ /\n    struct TradeExecutionParams {\n        uint256 targetUnit;              // Target unit of component for Set\n        uint256 maxSize;                 // Max trade size in precise units\n        uint256 coolOffPeriod;           // Required time between trades for the asset\n        uint256 lastTradeTimestamp;      // Timestamp of last trade\n        string exchangeName;             // Name of exchange adapter\n        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)\n    }\n    struct TradePermissionInfo {\n        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade\n        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal\n        mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade\n    }\n    struct RebalanceInfo {\n        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance\n        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)\n        address[] rebalanceComponents;      // Array of components involved in rebalance\n    }\n    struct TradeInfo {\n        ISetToken setToken;                         // Instance of SetToken\n        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter\n        address sendToken;                          // Address of token being sold\n        address receiveToken;                       // Address of token being bought\n        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token\n        uint256 setTotalSupply;                     // Total supply of Set (in precise units)\n        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded\n        uint256 sendQuantity;                       // Units of component sent to the exchange\n        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade\n        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought\n        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange\n    }\n    / ============ Events ============ /\n    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);\n    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);\n    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);\n    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);\n    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);\n    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);\n    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);\n    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);\n    event TradeExecuted(\n        ISetToken indexed _setToken,\n        address indexed _sellComponent,\n        address indexed _buyComponent,\n        IIndexExchangeAdapter _exchangeAdapter,\n        address _executor,\n        uint256 _netAmountSold,\n        uint256 _netAmountReceived,\n        uint256 _protocolFee\n    );\n    event RebalanceStarted(\n        ISetToken indexed _setToken,\n        address[] aggregateComponents,\n        uint256[] aggregateTargetUnits,\n        uint256 indexed positionMultiplier\n    );\n    / ============ Constants ============ /\n    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller\n    / ============ State Variables ============ /\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken\n    mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions\n    mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance\n    IWETH public immutable weth;                                                            // Weth contract address\n    / ============ Modifiers ============ /\n    modifier onlyAllowedTrader(ISetToken setToken) {\n        _validateOnlyAllowedTrader(_setToken);\n        ;\n    }\n    modifier onlyEOAIfUnrestricted(ISetToken setToken) {\n        _validateOnlyEOAIfUnrestricted(_setToken);\n        ;\n    }\n    / ============ Constructor ============ /\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n    / ============ External Functions ============ /\n    /\n     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager\n     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 1018\n     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the\n     * SetToken. If a component is being removed it\'s index in the _oldComponentsTargetUnits should be set to 0. Additionally, the\n     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs\n     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.\n     \n     * @param _setToken                         Address of the SetToken to be rebalanced\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units\n     *                                               if fees accrued\n     /\n    function startRebalance(\n        ISetToken _setToken,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits,\n        uint256 _positionMultiplier\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(\n            _setToken.getComponents(),\n            _newComponents,\n            _newComponentsTargetUnits,\n            _oldComponentsTargetUnits\n        );\n        for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {\n            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");\n            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];\n        }\n        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;\n        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;\n        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);\n    }\n    /\n     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().\n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.\n     \n     * Trade can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Trader can pass\n     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.\n     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default\n     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,\n     * if enabled, are collected in the token received in a trade.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _component            Address of SetToken component to trade\n     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade\n     /\n    function trade(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        _validateTradeParameters(_setToken, _component);\n        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);\n        _executeTrade(tradeInfo);\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n    /\n     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be\n     * traded such that resulting inflows won\'t exceed component\'s maxTradeSize nor overshoot the target unit. To be used near the end of rebalances\n     * when a component\'s calculated trade size is greater in value than remaining WETH.\n     \n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade\n     * can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Like with trade()\n     * a minimum component receive amount can be set.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _component                    Address of the SetToken component to trade\n     * @param _minComponentReceived        Min amount of component received during trade\n     */\n    function tradeRemainingWETH(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        require(_noTokensToSell(_setToken), "Sell other set components first");\n        require(\n            executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),\n            "WETH is below target unit"\n        );\n        _validateTradeParameters(_setToken, _component);\n        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);\n        _executeTrade(tradeInfo);\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n        require(\n            netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,\n            "Trade amount &gt; max trade size"\n        );\n        _validateComponentPositionUnit(_setToken, _component);\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n    /\n     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying\n     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,\n     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error\n     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components\n     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is\n     * spent buying the components to meet their new target.\n     \n     * @param _setToken             Address of the SetToken\n     /\n    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {\n        require(\n            _allTargetsMet(_setToken)\n            &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),\n            "Targets not met or ETH =~ 0"\n        );\n        // positionMultiplier / (10^18 + raiseTargetPercentage)\n        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087\n        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(\n            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)\n        );\n        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);\n    }\n    /\n     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.\n     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by\n     * default and trades will not execute if a component\'s trade size is greater than the maximum.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _tradeMaximums        Array of trade maximums mapping to correct component\n     /\n    function setTradeMaximums(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _tradeMaximums\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_tradeMaximums);\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];\n            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);\n        }\n    }\n    /\n     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeNames        Array of exchange names mapping to correct component\n     /\n    function setExchanges(\n        ISetToken _setToken,\n        address[] memory _components,\n        string[] memory _exchangeNames\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeNames);\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            if (_components[i] != address(weth)) {\n                require(\n                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),\n                    "Unrecognized exchange name"\n                );\n                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];\n                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);\n            }\n        }\n    }\n    /\n     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _coolOffPeriods       Array of cool off periods to correct component\n     /\n    function setCoolOffPeriods(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _coolOffPeriods\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_coolOffPeriods);\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];\n            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);\n        }\n    }\n    /\n     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying\n     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeData         Array of exchange specific arbitrary bytes data\n     /\n    function setExchangeData(\n        ISetToken _setToken,\n        address[] memory _components,\n        bytes[] memory _exchangeData\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeData);\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];\n            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);\n        }\n    }\n    /\n     * MANAGER ONLY: Set amount by which all component\'s targets units would be raised. Can be called at any time.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _raiseTargetPercentage        Amount to raise all component\'s unit targets by (in precise units)\n     /\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n    /\n     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.\n     \n     * @param _setToken          Address of the SetToken\n     * @param _traders           Array trader addresses to toggle status\n     * @param _statuses          Booleans indicating if matching trader can trade\n     /\n    function setTraderStatus(\n        ISetToken _setToken,\n        address[] memory _traders,\n        bool[] memory _statuses\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _traders.validatePairsWithArray(_statuses);\n        for (uint256 i = 0; i &lt; _traders.length; i++) {\n            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);\n            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];\n            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);\n        }\n    }\n    /\n     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _status           Boolean indicating if anyone can trade\n     /\n    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {\n        permissionInfo[_setToken].anyoneTrade = _status;\n        emit AnyoneTradeUpdated(_setToken, _status);\n    }\n    /\n     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.\n     * Grabs the current units for each asset in the Set and set\'s the targetUnit to that unit in order to prevent any\n     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any\n     * position multiplier changes don\'t unintentionally open the Set for rebalancing.\n     \n     * @param _setToken         Address of the Set Token\n     /\n    function initialize(ISetToken _setToken)\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n        for (uint256 i = 0; i &lt; positions.length; i++) {\n            ISetToken.Position memory position = positions[i];\n            require(position.positionState == 0, "External positions not allowed");\n            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();\n            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;\n        }\n        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();\n        _setToken.initializeModule();\n    }\n    /\n     * Called by a SetToken to notify that this module was removed from the SetToken.\n     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.\n     * IMPORTANT: SetToken\'s execution settings, including trade maximums and exchange names,\n     * are NOT DELETED. Restoring a previously removed module requires that care is taken to\n     * initialize execution settings appropriately.\n     /\n    function removeModule() external override {\n        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];\n        for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {\n            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;\n        }\n        delete rebalanceInfo[ISetToken(msg.sender)];\n        delete permissionInfo[ISetToken(msg.sender)];\n    }\n    / ============ External View Functions ============ */\n    /\n     * Get the array of SetToken components involved in rebalance.\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]        Array of _setToken components involved in rebalance\n     /\n    function getRebalanceComponents(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return rebalanceInfo[_setToken].rebalanceComponents;\n    }\n    /\n     * Calculates the amount of a component that is going to be traded and whether the component is being bought\n     * or sold. If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return componentQuantity        Amount of component being traded\n     /\n    function getComponentTradeQuantityAndDirection(\n        ISetToken _setToken,\n        IERC20 _component\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool, uint256)\n    {\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not recognized"\n        );\n        uint256 totalSupply = _setToken.totalSupply();\n        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);\n    }\n\n    /\n     * Get if a given address is an allowed trader.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _trader           Address of the trader\n     \n     * @return bool             True if _trader is allowed to trade, else false\n     */\n    function getIsAllowedTrader(ISetToken _setToken, address _trader)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool)\n    {\n        return _isAllowedTrader(_setToken, _trader);\n    }\n    /\n     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]\n     /\n    function getAllowedTraders(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return permissionInfo[_setToken].tradersHistory;\n    }\n    / ============ Internal Functions ============ /\n    /\n     * A rebalance is a multi-step process in which current Set components are sold for a\n     * bridge asset (WETH) before buying target components in the correct amount to achieve\n     * the desired balance between elements in the set.\n     \n     *        Step 1        |       Step 2\n     * -------------------------------------------\n     * Component --&gt; WETH   |   WETH --&gt; Component\n     * -------------------------------------------\n     \n     * The syntax we use frames this as trading from a "fixed" amount of one component to a\n     * "fixed" amount of another via a "floating limit" which is either the maximum size of\n     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum\n     * amount of tokens we expect to receive. The different meanings of the floating limit map to\n     * the trade sequence as below:\n     \n     * Step 1: Component --&gt; WETH\n     * ----------------------------------------------------------\n     *                     | Fixed  |     Floating limit        |\n     * ----------------------------------------------------------\n     * send  (Component)   |  YES   |                           |\n     * recieve (WETH)      |        |   Min WETH to receive     |\n     * ----------------------------------------------------------\n     \n     * Step 2: WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     |  Fixed  |    Floating limit        |\n     * ----------------------------------------------------------\n     * send  (WETH)        |   NO    |  Max WETH to send        |\n     * recieve (Component) |   YES   |                          |\n     * ----------------------------------------------------------\n     \n     * Additionally, there is an edge case where price volatility during a rebalance\n     * results in remaining WETH which needs to be allocated proportionately. In this case\n     * the values are as below:\n     \n     * Edge case: Remaining WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     | Fixed  |    Floating limit         |\n     * ----------------------------------------------------------\n     * send  (WETH)        |  YES   |                           |\n     * recieve (Component) |        | Min component to receive  |\n     * ----------------------------------------------------------\n    /\n    /\n     * Create and return TradeInfo struct. This function reverts if the target has already been met.\n     * If this is a trade from component into WETH, sell the total fixed component quantity\n     * and expect to receive an ETH amount the user has specified (or more). If it\'s a trade from\n     * WETH into a component, sell the lesser of: the user\'s WETH limit OR the SetToken\'s\n     * remaining WETH balance and expect to receive a fixed component quantity.\n     \n     * @param _setToken             Instance of the SetToken to rebalance\n     * @param _component            IERC20 component to trade\n     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade\n     \n     * @return tradeInfo            Struct containing data for trade\n     */\n    function _createTradeInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        internal\n        view\n        virtual\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;\n            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;\n        } else {\n            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);\n            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;\n        }\n    }\n    /\n     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param _minComponentReceived         Min amount of component received during trade\n     \n     * @return tradeInfo                    Struct containing data for tradeRemaining info\n     /\n    function _createTradeRemainingInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);\n        (,,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);\n        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);\n        tradeInfo.floatingQuantityLimit = _minComponentReceived;\n        tradeInfo.isSendTokenFixed = true;\n    }\n    /\n     * Create and returns a partial TradeInfo struct with all fields that overlap between trade\n     * and tradeRemaining info constructors filled in. Values for sendQuantity and floatingQuantityLimit\n     * are derived separately, outside this method. trade requires that trade size and direction are\n     * calculated, whereas tradeRemaining automatically sets WETH as the sendToken and _component\n     * as receiveToken.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction\n     \n     * @return tradeInfo                    Struct containing partial data for trade\n     /\n    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo.setToken = _setToken;\n        tradeInfo.setTotalSupply = _setToken.totalSupply();\n        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);\n        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;\n        if(calculateTradeDirection){\n            (\n                tradeInfo.isSendTokenFixed,\n                tradeInfo.totalFixedQuantity\n            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);\n        }\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendToken = address(_component);\n            tradeInfo.receiveToken = address(weth);\n        } else {\n            tradeInfo.sendToken = address(weth);\n            tradeInfo.receiveToken = address(_component);\n        }\n        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));\n        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));\n    }\n    /\n     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed\n     * quantity of a token in return for a non-fixed (floating) quantity of a token. If isSendTokenFixed is true then the adapter\n     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for\n     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.\n     \n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     /\n    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {\n        _tradeInfo.setToken.invokeApprove(\n            _tradeInfo.sendToken,\n            _tradeInfo.exchangeAdapter.getSpender(),\n            _tradeInfo.sendQuantity\n        );\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(\n            _tradeInfo.sendToken,\n            _tradeInfo.receiveToken,\n            address(_tradeInfo.setToken),\n            _tradeInfo.isSendTokenFixed,\n            _tradeInfo.sendQuantity,\n            _tradeInfo.floatingQuantityLimit,\n            _tradeInfo.exchangeData\n        );\n        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);\n    }\n    /\n     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.\n     * The protocol fee is collected from the amount of received token in the trade.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     \n     * @return protocolFee              Amount of receive token taken as protocol fee\n     /\n    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {\n        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)\n            .balanceOf(address(_tradeInfo.setToken))\n            .sub(_tradeInfo.preTradeReceiveTokenBalance);\n        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);\n        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);\n    }\n    /\n     * Update SetToken positions and executionInfo\'s last trade timestamp. This function is intended\n     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     * @param _component                IERC20 component which was traded\n     \n     * @return netSendAmount            Amount of sendTokens used in the trade\n     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)\n     /\n    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)\n        internal\n        returns (uint256 netSendAmount, uint256 netReceiveAmount)\n    {\n        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.sendToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeSendTokenBalance\n        );\n        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.receiveToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeReceiveTokenBalance\n        );\n        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);\n        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);\n        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;\n    }\n    /\n     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It\'s\n     * necessary to verify that traderHistory contains the address because AddressArrayUtils will\n     * throw when attempting to remove a non-element and it\'s possible someone can set a new\n     * trader\'s status to false.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _trader                           Trader whose permission is being set\n     * @param _status                           Boolean permission being set\n     /\n    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {\n        if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.push(_trader);\n        } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);\n        }\n    }\n    /\n     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.\n     * If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     * @param _totalSupply              Total supply of _setToken\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return totalFixedQuantity       Amount of fixed token to send or receive\n     /\n    function _calculateTradeSizeAndDirection(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _totalSupply\n    )\n        internal\n        view\n        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)\n    {\n        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);\n        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;\n        (\n            uint256 currentUnit,\n            uint256 targetUnit,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);\n        require(currentUnit != targetUnit, "Target already met");\n        isSendTokenFixed = targetNotional &lt; currentNotional;\n        // In order to account for fees taken by protocol when buying the notional difference between currentUnit\n        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to\n        // do so would lead to never being able to meet target of components that need to be bought.\n        //\n        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))\n        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)\n        totalFixedQuantity = isSendTokenFixed\n            ? componentMaxSize.min(currentNotional.sub(targetNotional))\n            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));\n    }\n    /\n     * Check if all targets are met.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if all component\'s target units have been met, otherwise false\n     /\n    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }\n        }\n        return true;\n    }\n    /\n     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise\n     * needs to be approved.\n     \n     * @param _setToken             Instance of SetToken to be rebalanced\n     * @param  _trader              Address of the trader who called contract function\n     \n     * @return bool                 True if trader is an approved trader for the SetToken\n     */\n    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {\n        TradePermissionInfo storage permissions = permissionInfo[_setToken];\n        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];\n    }\n    /\n     * Checks if sell conditions are met. The component cannot be WETH and its normalized target\n     * unit must be less than its default position real unit\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component evaluated for sale\n     \n     * @return bool                             True if sell allowed, false otherwise\n     /\n    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {\n        return (\n            _component != address(weth) &amp;&amp;\n            (\n                _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;\n                _getDefaultPositionRealUnit(_setToken,IERC20(_component))\n            )\n        );\n    }\n    /\n     * Check if there are any more tokens to sell. Since we allow WETH to float around it\'s target during rebalances it is not checked.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if there is not any component that can be sold, otherwise false\n     /\n    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }\n        }\n        return true;\n    }\n    /\n     * Determines if a target is met. Due to small rounding errors converting between virtual and\n     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to\n     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not\n     * checked as it is allowed to float around its target.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component whose target is evaluated\n     \n     * @return bool                             True if component\'s target units are met, false otherwise\n     */\n    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {\n        if (_component == address(weth)) return false;\n        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));\n        return (normalizedTargetUnit &gt; 0)\n            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))\n            : normalizedTargetUnit != currentUnit;\n    }\n    /\n     * Validate component position unit has not exceeded it\'s target unit. This is used during tradeRemainingWETH() to make sure\n     * the amount of component bought does not exceed the targetUnit.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component whose position units are to be validated\n     /\n    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n        require(currentUnit &lt;= targetUnit, "Can not exceed target unit");\n    }\n    /\n     * Validate that component is a valid component and enough time has elapsed since component\'s last trade. Traders\n     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to be validated\n     /\n    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {\n        require(address(_component) != address(weth), "Can not explicitly trade WETH");\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not part of rebalance"\n        );\n        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];\n        require(\n            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,\n            "Component cool off in progress"\n        );\n        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");\n    }\n    /\n     * Extends and/or updates the current component set and its target units with new components and targets,\n     * Validates inputs, requiring that that new components and new target units arrays are the same size, and\n     * that the number of old components target units matches the number of current components. Throws if\n     * a duplicate component has been added.\n     \n     * @param  _currentComponents               Complete set of current SetToken components\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     \n     * @return aggregateComponents              Array of current components extended by new components, without duplicates\n     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates\n     /\n    function _getAggregateComponentsAndUnits(\n        address[] memory _currentComponents,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits\n    )\n        internal\n        pure\n        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)\n    {\n        // Don\'t use validate arrays because empty arrays are valid\n        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");\n        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");\n        aggregateComponents = _currentComponents.extend(_newComponents);\n        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);\n        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");\n    }\n    /\n     * Get the SetToken\'s default position as uint256\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to fetch the default position for\n     \n     * return uint256           Real unit position\n     /\n    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {\n        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();\n    }\n    /\n     * Gets exchange adapter address for a component after checking that it exists in the\n     * IntegrationRegistry. This method is called during a trade and must validate the adapter\n     * because its state may have changed since it was set in a separate transaction.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        IERC20 component whose exchange adapter is fetched\n     \n     * @return IExchangeAdapter                 Adapter address\n     */\n    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {\n        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));\n    }\n    /\n     * Calculates and returns the normalized target unit value.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     * @param _component            IERC20 component whose normalized target unit is required\n     \n     * @return uint256                          Normalized target unit of the component\n     /\n    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {\n        // (targetUnit * current position multiplier) / position multiplier when rebalance started\n        return executionInfo[_setToken][_component]\n            .targetUnit\n            .mul(_setToken.positionMultiplier().toUint256())\n            .div(rebalanceInfo[_setToken].positionMultiplier);\n    }\n    /\n     * Gets unit and notional amount values for current position and target. These are necessary\n     * to calculate the trade size and direction for regular trades and the sendQuantity for\n     * remainingWEth trades.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to calculate notional amounts for\n     * @param _totalSupply              SetToken total supply\n     \n     * @return uint256              Current default position real unit of component\n     * @return uint256              Normalized unit of the trade target\n     * @return uint256              Current notional amount: total notional amount of SetToken default position\n     * @return uint256              Target notional amount: Total SetToken supply * targetUnit\n     /\n    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)\n        internal\n        view\n        returns (uint256, uint256, uint256, uint256)\n    {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n        return (\n            currentUnit,\n            targetUnit,\n            _totalSupply.getDefaultTotalNotional(currentUnit),\n            _totalSupply.preciseMulCeil(targetUnit)\n        );\n    }\n    / ============== Modifier Helpers ===============\n     * Internal functions used to reduce bytecode size\n     /\n    /\n     * Trader must be permissioned for SetToken\n     /\n    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {\n        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");\n    }\n    /\n     * Trade must be an EOA if anyoneTrade has been enabled for SetToken on the module.\n     /\n    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {\n        if(permissionInfo[_setToken].anyoneTrade) {\n            require(msg.sender == tx.origin, "Caller must be EOA Address");\n        }\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 01:46:46 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 01:46:46 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/
pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";

/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];
    /* ============ Struct ============ */
    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }
    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }
    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }
    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }
    /* ============ Events ============ */
    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);
    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);
    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );
    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );
    /* ============ Constants ============ */
    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller
    /* ============ State Variables ============ */
    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address
    /* ============ Modifiers ============ */
    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }
    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }
    /* ============ Constructor ============ */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }
    /* ============ External Functions ============ */
    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );
        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }
        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;
        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }
    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);
        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);
        _executeTrade(tradeInfo);
        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);
        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }
    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );
        _validateTradeParameters(_setToken, _component);
        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);
        _executeTrade(tradeInfo);
        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);
        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );
        _validateComponentPositionUnit(_setToken, _component);
        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }
    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );
        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }
    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);
        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }
    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);
        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {
                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );
                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }
    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);
        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }
    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);
        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }
    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }
    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);
        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }
    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }
    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();
        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }
        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }
    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];
        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }
        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }
    /* ============ External View Functions ============ */
    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }
    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }

    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }
    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }
    /* ============ Internal Functions ============ */
    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */
    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);
        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }
    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);
        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);
        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }
    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;
        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }
        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }
        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }
    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );
        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );
        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }
    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);
        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }
    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );
        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);
        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }
    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set
     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }
    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;
        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);
        require(currentUnit != targetUnit, "Target already met");
        isSendTokenFixed = targetNotional < currentNotional;
        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }
    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;
        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }
    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }
    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }
    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;
        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }
    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;
        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));
        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }
    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }
    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );
        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );
        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }
    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");
        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);
        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }
    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }
    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }
    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }
    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }
    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */
    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }
    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "/*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/
pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";
import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";

/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];
    /* ============ Struct ============ */
    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }
    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }
    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }
    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }
    /* ============ Events ============ */
    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);
    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);
    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );
    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );
    /* ============ Constants ============ */
    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller
    /* ============ State Variables ============ */
    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address
    /* ============ Modifiers ============ */
    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }
    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }
    /* ============ Constructor ============ */
    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }
    /* ============ External Functions ============ */
    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );
        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }
        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;
        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }
    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);
        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);
        _executeTrade(tradeInfo);
        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);
        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }
    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );
        _validateTradeParameters(_setToken, _component);
        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);
        _executeTrade(tradeInfo);
        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);
        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );
        _validateComponentPositionUnit(_setToken, _component);
        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }
    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );
        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }
    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);
        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }
    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);
        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {
                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );
                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }
    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);
        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }
    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);
        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }
    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }
    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);
        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }
    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }
    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();
        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }
        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }
    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];
        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }
        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }
    /* ============ External View Functions ============ */
    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }
    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }

    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }
    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }
    /* ============ Internal Functions ============ */
    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */
    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);
        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }
    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);
        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);
        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }
    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;
        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }
        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }
        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }
    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );
        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );
        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }
    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);
        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }
    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );
        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);
        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }
    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set
     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }
    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;
        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);
        require(currentUnit != targetUnit, "Target already met");
        isSendTokenFixed = targetNotional < currentNotional;
        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }
    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;
        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }
    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }
    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }
    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;
        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }
    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;
        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));
        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }
    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }
    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );
        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );
        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }
    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");
        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);
        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }
    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }
    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }
    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }
    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }
    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */
    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }
    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 01:46:50 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 01:46:50 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 34821
completion_tokens: 1
total_tokens: 34822
cost: $-1.000000


[2024-01-09 01:46:50 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Security

[2024-01-09 01:46:50 INFO] **[Seminar Conclusion]**:

 Security

[2024-01-09 01:46:50 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-01-09 01:46:50 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 01:46:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Math } from "@openzeppelin/contracts/math/Math.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\n\nimport { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";\nimport { Invoke } from "../../lib/Invoke.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\nimport { Position } from "../../lib/Position.sol";\nimport { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";\nimport { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";\n\n\n/\n * @title GeneralIndexModule\n * @author Set Protocol\n \n * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().\n * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over\n * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed\n * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.\n * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-\n * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance\n * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component\'s\n * target allocation is met any further attempted trades of that component will revert.\n \n * SECURITY ASSUMPTION:\n *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using\n *    this module need to be examined separately)\n /\ncontract GeneralIndexModule is ModuleBase, ReentrancyGuard {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using Position for uint256;\n    using Math for uint256;\n    using Position for ISetToken;\n    using Invoke for ISetToken;\n    using AddressArrayUtils for address[];\n    using AddressArrayUtils for IERC20[];\n    using Uint256ArrayUtils for uint256[];\n\n    / ============ Struct ============ /\n\n    struct TradeExecutionParams {\n        uint256 targetUnit;              // Target unit of component for Set\n        uint256 maxSize;                 // Max trade size in precise units\n        uint256 coolOffPeriod;           // Required time between trades for the asset\n        uint256 lastTradeTimestamp;      // Timestamp of last trade\n        string exchangeName;             // Name of exchange adapter\n        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)\n    }\n\n    struct TradePermissionInfo {\n        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade\n        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal\n        mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade\n    }\n\n    struct RebalanceInfo {\n        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance\n        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)\n        address[] rebalanceComponents;      // Array of components involved in rebalance\n    }\n\n    struct TradeInfo {\n        ISetToken setToken;                         // Instance of SetToken\n        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter\n        address sendToken;                          // Address of token being sold\n        address receiveToken;                       // Address of token being bought\n        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token\n        uint256 setTotalSupply;                     // Total supply of Set (in precise units)\n        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded\n        uint256 sendQuantity;                       // Units of component sent to the exchange\n        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade\n        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought\n        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange\n    }\n\n    / ============ Events ============ /\n\n    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);\n    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);\n    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);\n    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);\n    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);\n    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);\n\n    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);\n    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);\n\n    event TradeExecuted(\n        ISetToken indexed _setToken,\n        address indexed _sellComponent,\n        address indexed _buyComponent,\n        IIndexExchangeAdapter _exchangeAdapter,\n        address _executor,\n        uint256 _netAmountSold,\n        uint256 _netAmountReceived,\n        uint256 _protocolFee\n    );\n\n    event RebalanceStarted(\n        ISetToken indexed _setToken,\n        address[] aggregateComponents,\n        uint256[] aggregateTargetUnits,\n        uint256 indexed positionMultiplier\n    );\n\n    / ============ Constants ============ /\n\n    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller\n\n    / ============ State Variables ============ /\n\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken\n    mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions\n    mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance\n    IWETH public immutable weth;                                                            // Weth contract address\n\n    / ============ Modifiers ============ /\n\n    modifier onlyAllowedTrader(ISetToken setToken) {\n        _validateOnlyAllowedTrader(_setToken);\n        ;\n    }\n\n    modifier onlyEOAIfUnrestricted(ISetToken setToken) {\n        _validateOnlyEOAIfUnrestricted(_setToken);\n        ;\n    }\n\n    / ============ Constructor ============ /\n\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n\n    / ============ External Functions ============ */\n\n    /\n     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager\n     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 1018\n     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the\n     * SetToken. If a component is being removed it\'s index in the _oldComponentsTargetUnits should be set to 0. Additionally, the\n     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs\n     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.\n     \n     * @param _setToken                         Address of the SetToken to be rebalanced\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units\n     *                                               if fees accrued\n     /\n    function startRebalance(\n        ISetToken _setToken,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits,\n        uint256 _positionMultiplier\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(\n            _setToken.getComponents(),\n            _newComponents,\n            _newComponentsTargetUnits,\n            _oldComponentsTargetUnits\n        );\n\n        for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {\n            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");\n            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];\n        }\n\n        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;\n        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;\n\n        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);\n    }\n\n    /\n     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().\n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.\n     \n     * Trade can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Trader can pass\n     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.\n     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default\n     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,\n     * if enabled, are collected in the token received in a trade.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _component            Address of SetToken component to trade\n     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade\n     /\n    function trade(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        _validateTradeParameters(_setToken, _component);\n\n        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);\n\n        _executeTrade(tradeInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n\n    /\n     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be\n     * traded such that resulting inflows won\'t exceed component\'s maxTradeSize nor overshoot the target unit. To be used near the end of rebalances\n     * when a component\'s calculated trade size is greater in value than remaining WETH.\n     \n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade\n     * can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Like with trade()\n     * a minimum component receive amount can be set.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _component                    Address of the SetToken component to trade\n     * @param _minComponentReceived        Min amount of component received during trade\n     /\n    function tradeRemainingWETH(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        require(_noTokensToSell(_setToken), "Sell other set components first");\n        require(\n            executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),\n            "WETH is below target unit"\n        );\n\n        _validateTradeParameters(_setToken, _component);\n\n        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);\n\n        _executeTrade(tradeInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n\n        require(\n            netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,\n            "Trade amount &gt; max trade size"\n        );\n\n        _validateComponentPositionUnit(_setToken, _component);\n\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n\n    /\n     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying\n     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,\n     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error\n     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components\n     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is\n     * spent buying the components to meet their new target.\n     \n     * @param _setToken             Address of the SetToken\n     /\n    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {\n        require(\n            _allTargetsMet(_setToken)\n            &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),\n            "Targets not met or ETH =~ 0"\n        );\n\n        // positionMultiplier / (10^18 + raiseTargetPercentage)\n        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087\n        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(\n            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)\n        );\n        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);\n    }\n\n    /\n     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.\n     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by\n     * default and trades will not execute if a component\'s trade size is greater than the maximum.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _tradeMaximums        Array of trade maximums mapping to correct component\n     /\n    function setTradeMaximums(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _tradeMaximums\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_tradeMaximums);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];\n            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeNames        Array of exchange names mapping to correct component\n     /\n    function setExchanges(\n        ISetToken _setToken,\n        address[] memory _components,\n        string[] memory _exchangeNames\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeNames);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            if (_components[i] != address(weth)) {\n\n                require(\n                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),\n                    "Unrecognized exchange name"\n                );\n\n                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];\n                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);\n            }\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _coolOffPeriods       Array of cool off periods to correct component\n     /\n    function setCoolOffPeriods(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _coolOffPeriods\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_coolOffPeriods);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];\n            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying\n     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeData         Array of exchange specific arbitrary bytes data\n     /\n    function setExchangeData(\n        ISetToken _setToken,\n        address[] memory _components,\n        bytes[] memory _exchangeData\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeData);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];\n            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set amount by which all component\'s targets units would be raised. Can be called at any time.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _raiseTargetPercentage        Amount to raise all component\'s unit targets by (in precise units)\n     /\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n\n    /\n     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.\n     \n     * @param _setToken          Address of the SetToken\n     * @param _traders           Array trader addresses to toggle status\n     * @param _statuses          Booleans indicating if matching trader can trade\n     /\n    function setTraderStatus(\n        ISetToken _setToken,\n        address[] memory _traders,\n        bool[] memory _statuses\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _traders.validatePairsWithArray(_statuses);\n\n        for (uint256 i = 0; i &lt; _traders.length; i++) {\n            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);\n            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];\n            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _status           Boolean indicating if anyone can trade\n     /\n    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {\n        permissionInfo[_setToken].anyoneTrade = _status;\n        emit AnyoneTradeUpdated(_setToken, _status);\n    }\n\n    /\n     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.\n     * Grabs the current units for each asset in the Set and set\'s the targetUnit to that unit in order to prevent any\n     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any\n     * position multiplier changes don\'t unintentionally open the Set for rebalancing.\n     \n     * @param _setToken         Address of the Set Token\n     /\n    function initialize(ISetToken _setToken)\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n\n        for (uint256 i = 0; i &lt; positions.length; i++) {\n            ISetToken.Position memory position = positions[i];\n            require(position.positionState == 0, "External positions not allowed");\n            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();\n            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;\n        }\n\n        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();\n        _setToken.initializeModule();\n    }\n\n    /\n     * Called by a SetToken to notify that this module was removed from the SetToken.\n     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.\n     * IMPORTANT: SetToken\'s execution settings, including trade maximums and exchange names,\n     * are NOT DELETED. Restoring a previously removed module requires that care is taken to\n     * initialize execution settings appropriately.\n     /\n    function removeModule() external override {\n        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];\n\n        for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {\n            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;\n        }\n\n        delete rebalanceInfo[ISetToken(msg.sender)];\n        delete permissionInfo[ISetToken(msg.sender)];\n    }\n\n    / ============ External View Functions ============ /\n\n    /\n     * Get the array of SetToken components involved in rebalance.\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]        Array of _setToken components involved in rebalance\n     /\n    function getRebalanceComponents(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return rebalanceInfo[_setToken].rebalanceComponents;\n    }\n\n    /\n     * Calculates the amount of a component that is going to be traded and whether the component is being bought\n     * or sold. If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return componentQuantity        Amount of component being traded\n     */\n    function getComponentTradeQuantityAndDirection(\n        ISetToken _setToken,\n        IERC20 _component\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool, uint256)\n    {\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not recognized"\n        );\n        uint256 totalSupply = _setToken.totalSupply();\n        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);\n    }\n\n\n    /\n     * Get if a given address is an allowed trader.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _trader           Address of the trader\n     \n     * @return bool             True if _trader is allowed to trade, else false\n     /\n    function getIsAllowedTrader(ISetToken _setToken, address _trader)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool)\n    {\n        return _isAllowedTrader(_setToken, _trader);\n    }\n\n    /\n     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]\n     /\n    function getAllowedTraders(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return permissionInfo[_setToken].tradersHistory;\n    }\n\n    / ============ Internal Functions ============ /\n\n    /\n     * A rebalance is a multi-step process in which current Set components are sold for a\n     * bridge asset (WETH) before buying target components in the correct amount to achieve\n     * the desired balance between elements in the set.\n     \n     *        Step 1        |       Step 2\n     * -------------------------------------------\n     * Component --&gt; WETH   |   WETH --&gt; Component\n     * -------------------------------------------\n     \n     * The syntax we use frames this as trading from a "fixed" amount of one component to a\n     * "fixed" amount of another via a "floating limit" which is either the maximum size of\n     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum\n     * amount of tokens we expect to receive. The different meanings of the floating limit map to\n     * the trade sequence as below:\n     \n     * Step 1: Component --&gt; WETH\n     * ----------------------------------------------------------\n     *                     | Fixed  |     Floating limit        |\n     * ----------------------------------------------------------\n     * send  (Component)   |  YES   |                           |\n     * recieve (WETH)      |        |   Min WETH to receive     |\n     * ----------------------------------------------------------\n     \n     * Step 2: WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     |  Fixed  |    Floating limit        |\n     * ----------------------------------------------------------\n     * send  (WETH)        |   NO    |  Max WETH to send        |\n     * recieve (Component) |   YES   |                          |\n     * ----------------------------------------------------------\n     \n     * Additionally, there is an edge case where price volatility during a rebalance\n     * results in remaining WETH which needs to be allocated proportionately. In this case\n     * the values are as below:\n     \n     * Edge case: Remaining WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     | Fixed  |    Floating limit         |\n     * ----------------------------------------------------------\n     * send  (WETH)        |  YES   |                           |\n     * recieve (Component) |        | Min component to receive  |\n     * ----------------------------------------------------------\n    */\n\n    /\n     * Create and return TradeInfo struct. This function reverts if the target has already been met.\n     * If this is a trade from component into WETH, sell the total fixed component quantity\n     * and expect to receive an ETH amount the user has specified (or more). If it\'s a trade from\n     * WETH into a component, sell the lesser of: the user\'s WETH limit OR the SetToken\'s\n     * remaining WETH balance and expect to receive a fixed component quantity.\n     \n     * @param _setToken             Instance of the SetToken to rebalance\n     * @param _component            IERC20 component to trade\n     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade\n     \n     * @return tradeInfo            Struct containing data for trade\n     /\n    function _createTradeInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        internal\n        view\n        virtual\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);\n\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;\n            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;\n        } else {\n            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);\n            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;\n        }\n    }\n\n    /\n     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param _minComponentReceived         Min amount of component received during trade\n     \n     * @return tradeInfo                    Struct containing data for tradeRemaining info\n     /\n    function _createTradeRemainingInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);\n\n        (,,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);\n\n        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);\n        tradeInfo.floatingQuantityLimit = _minComponentReceived;\n        tradeInfo.isSendTokenFixed = true;\n    }\n\n    /\n     * Create and returns a partial TradeInfo struct with all fields that overlap between trade\n     * and tradeRemaining info constructors filled in. Values for sendQuantity and floatingQuantityLimit\n     * are derived separately, outside this method. trade requires that trade size and direction are\n     * calculated, whereas tradeRemaining automatically sets WETH as the sendToken and _component\n     * as receiveToken.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction\n     \n     * @return tradeInfo                    Struct containing partial data for trade\n     */\n    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo.setToken = _setToken;\n        tradeInfo.setTotalSupply = _setToken.totalSupply();\n        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);\n        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;\n\n        if(calculateTradeDirection){\n            (\n                tradeInfo.isSendTokenFixed,\n                tradeInfo.totalFixedQuantity\n            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);\n        }\n\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendToken = address(_component);\n            tradeInfo.receiveToken = address(weth);\n        } else {\n            tradeInfo.sendToken = address(weth);\n            tradeInfo.receiveToken = address(_component);\n        }\n\n        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));\n        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));\n    }\n\n    /\n     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed\n     * quantity of a token in return for a non-fixed (floating) quantity of a token. If isSendTokenFixed is true then the adapter\n     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for\n     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.\n     \n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     /\n    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {\n        _tradeInfo.setToken.invokeApprove(\n            _tradeInfo.sendToken,\n            _tradeInfo.exchangeAdapter.getSpender(),\n            _tradeInfo.sendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(\n            _tradeInfo.sendToken,\n            _tradeInfo.receiveToken,\n            address(_tradeInfo.setToken),\n            _tradeInfo.isSendTokenFixed,\n            _tradeInfo.sendQuantity,\n            _tradeInfo.floatingQuantityLimit,\n            _tradeInfo.exchangeData\n        );\n\n        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);\n    }\n\n    /\n     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.\n     * The protocol fee is collected from the amount of received token in the trade.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     \n     * @return protocolFee              Amount of receive token taken as protocol fee\n     */\n    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {\n        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)\n            .balanceOf(address(_tradeInfo.setToken))\n            .sub(_tradeInfo.preTradeReceiveTokenBalance);\n\n        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);\n        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);\n    }\n\n    /\n     * Update SetToken positions and executionInfo\'s last trade timestamp. This function is intended\n     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     * @param _component                IERC20 component which was traded\n     \n     * @return netSendAmount            Amount of sendTokens used in the trade\n     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)\n     /\n    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)\n        internal\n        returns (uint256 netSendAmount, uint256 netReceiveAmount)\n    {\n        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.sendToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeSendTokenBalance\n        );\n        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.receiveToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeReceiveTokenBalance\n        );\n\n        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);\n        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);\n\n        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;\n    }\n\n    /\n     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It\'s\n     * necessary to verify that traderHistory contains the address because AddressArrayUtils will\n     * throw when attempting to remove a non-element and it\'s possible someone can set a new\n     * trader\'s status to false.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _trader                           Trader whose permission is being set\n     * @param _status                           Boolean permission being set\n\n     /\n    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {\n        if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.push(_trader);\n        } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);\n        }\n    }\n\n    /\n     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.\n     * If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     * @param _totalSupply              Total supply of _setToken\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return totalFixedQuantity       Amount of fixed token to send or receive\n     /\n    function _calculateTradeSizeAndDirection(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _totalSupply\n    )\n        internal\n        view\n        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)\n    {\n        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);\n        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;\n\n        (\n            uint256 currentUnit,\n            uint256 targetUnit,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);\n\n        require(currentUnit != targetUnit, "Target already met");\n\n        isSendTokenFixed = targetNotional &lt; currentNotional;\n\n        // In order to account for fees taken by protocol when buying the notional difference between currentUnit\n        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to\n        // do so would lead to never being able to meet target of components that need to be bought.\n        //\n        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))\n        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)\n        totalFixedQuantity = isSendTokenFixed\n            ? componentMaxSize.min(currentNotional.sub(targetNotional))\n            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));\n    }\n\n    /\n     * Check if all targets are met.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if all component\'s target units have been met, otherwise false\n     */\n    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }\n        }\n        return true;\n    }\n\n    /\n     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise\n     * needs to be approved.\n     \n     * @param _setToken             Instance of SetToken to be rebalanced\n     * @param  _trader              Address of the trader who called contract function\n     \n     * @return bool                 True if trader is an approved trader for the SetToken\n     /\n    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {\n        TradePermissionInfo storage permissions = permissionInfo[_setToken];\n        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];\n    }\n\n    /\n     * Checks if sell conditions are met. The component cannot be WETH and its normalized target\n     * unit must be less than its default position real unit\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component evaluated for sale\n     \n     * @return bool                             True if sell allowed, false otherwise\n     /\n    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {\n        return (\n            _component != address(weth) &amp;&amp;\n            (\n                _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;\n                _getDefaultPositionRealUnit(_setToken,IERC20(_component))\n            )\n        );\n    }\n\n    /\n     * Check if there are any more tokens to sell. Since we allow WETH to float around it\'s target during rebalances it is not checked.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if there is not any component that can be sold, otherwise false\n     */\n    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }\n        }\n        return true;\n    }\n\n    /\n     * Determines if a target is met. Due to small rounding errors converting between virtual and\n     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to\n     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not\n     * checked as it is allowed to float around its target.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component whose target is evaluated\n     \n     * @return bool                             True if component\'s target units are met, false otherwise\n     /\n    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {\n        if (_component == address(weth)) return false;\n\n        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));\n\n        return (normalizedTargetUnit &gt; 0)\n            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))\n            : normalizedTargetUnit != currentUnit;\n    }\n\n    /\n     * Validate component position unit has not exceeded it\'s target unit. This is used during tradeRemainingWETH() to make sure\n     * the amount of component bought does not exceed the targetUnit.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component whose position units are to be validated\n     /\n    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n        require(currentUnit &lt;= targetUnit, "Can not exceed target unit");\n    }\n\n    /\n     * Validate that component is a valid component and enough time has elapsed since component\'s last trade. Traders\n     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to be validated\n     /\n    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {\n        require(address(_component) != address(weth), "Can not explicitly trade WETH");\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not part of rebalance"\n        );\n\n        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];\n        require(\n            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,\n            "Component cool off in progress"\n        );\n\n        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");\n    }\n\n    /\n     * Extends and/or updates the current component set and its target units with new components and targets,\n     * Validates inputs, requiring that that new components and new target units arrays are the same size, and\n     * that the number of old components target units matches the number of current components. Throws if\n     * a duplicate component has been added.\n     \n     * @param  _currentComponents               Complete set of current SetToken components\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     \n     * @return aggregateComponents              Array of current components extended by new components, without duplicates\n     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates\n     /\n    function _getAggregateComponentsAndUnits(\n        address[] memory _currentComponents,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits\n    )\n        internal\n        pure\n        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)\n    {\n        // Don\'t use validate arrays because empty arrays are valid\n        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");\n        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");\n\n        aggregateComponents = _currentComponents.extend(_newComponents);\n        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);\n\n        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");\n    }\n\n    /\n     * Get the SetToken\'s default position as uint256\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to fetch the default position for\n     \n     * return uint256           Real unit position\n     */\n    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {\n        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();\n    }\n\n    /\n     * Gets exchange adapter address for a component after checking that it exists in the\n     * IntegrationRegistry. This method is called during a trade and must validate the adapter\n     * because its state may have changed since it was set in a separate transaction.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        IERC20 component whose exchange adapter is fetched\n     \n     * @return IExchangeAdapter                 Adapter address\n     /\n    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {\n        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));\n    }\n\n    /\n     * Calculates and returns the normalized target unit value.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     * @param _component            IERC20 component whose normalized target unit is required\n     \n     * @return uint256                          Normalized target unit of the component\n     /\n    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {\n        // (targetUnit * current position multiplier) / position multiplier when rebalance started\n        return executionInfo[_setToken][_component]\n            .targetUnit\n            .mul(_setToken.positionMultiplier().toUint256())\n            .div(rebalanceInfo[_setToken].positionMultiplier);\n    }\n\n    /\n     * Gets unit and notional amount values for current position and target. These are necessary\n     * to calculate the trade size and direction for regular trades and the sendQuantity for\n     * remainingWEth trades.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to calculate notional amounts for\n     * @param _totalSupply              SetToken total supply\n     \n     * @return uint256              Current default position real unit of component\n     * @return uint256              Normalized unit of the trade target\n     * @return uint256              Current notional amount: total notional amount of SetToken default position\n     * @return uint256              Target notional amount: Total SetToken supply * targetUnit\n     /\n    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)\n        internal\n        view\n        returns (uint256, uint256, uint256, uint256)\n    {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n\n        return (\n            currentUnit,\n            targetUnit,\n            _totalSupply.getDefaultTotalNotional(currentUnit),\n            _totalSupply.preciseMulCeil(targetUnit)\n        );\n    }\n\n    / ============== Modifier Helpers ===============\n     * Internal functions used to reduce bytecode size\n     /\n\n    /\n     * Trader must be permissioned for SetToken\n     /\n    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {\n        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");\n    }\n\n    /\n     * Trade must be an EOA if anyoneTrade has been enabled for SetToken on the module.\n     */\n    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {\n        if(permissionInfo[_setToken].anyoneTrade) {\n            require(msg.sender == tx.origin, "Caller must be EOA Address");\n        }\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 01:46:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 01:46:51 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 01:46:54 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 01:46:54 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 23170
completion_tokens: 1
total_tokens: 23171
cost: $-1.000000


[2024-01-09 01:46:54 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

###

[2024-01-09 01:46:54 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 01:46:54 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 01:46:54 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 01:46:54 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 01:46:54 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 01:47:04 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 01:47:04 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 11644
completion_tokens: 751
total_tokens: 12395
cost: $-1.000000


[2024-01-09 01:47:04 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

### Summary of Security Vulnerabilities in the Smart Contract

1. **Reentrancy Vulnerability**:
   - The contract uses external calls to execute trades, which could potentially allow a malicious actor to re-enter the contract during the execution of a trade, leading to unexpected behavior or loss of funds. Although `ReentrancyGuard` is used, it is crucial to ensure that all external calls are properly managed.

2. **Timestamp Dependence**:
   - The contract relies on `block.timestamp` for managing trade cool-off periods. This can be manipulated by miners to some extent, which may allow them to influence the timing of trades and exploit the cool-off mechanism.

3. **Access Control Issues**:
   - While there are modifiers to restrict access to certain functions, there may be scenarios where the access control logic could be bypassed, especially if the contract is not properly initialized or if the manager's privileges are not adequately protected.

4. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath` for arithmetic operations, it is essential to ensure that all calculations are properly guarded against overflow and underflow, especially in critical functions that manage balances and trade sizes.

5. **Improper Input Validation**:
   - The contract lacks comprehensive input validation in several functions, which could lead to unexpected behavior or state changes. For example, checks for valid addresses and ensuring that arrays are of the correct length should be enforced more rigorously.

6. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which can hinder the ability to track changes and debug issues. It is essential to emit events for all significant state changes to maintain transparency and traceability.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, where a malicious actor could observe pending transactions and execute their own transactions to profit at the expense of others.

8. **Protocol Fee Management**:
   - The handling of protocol fees may not be adequately secured, leading to potential loss of funds if the fee calculation or transfer logic is exploited.

### Comprehensive Analysis Report

The `GeneralIndexModule` contract presents a sophisticated mechanism for managing index rebalances, but it is not without its vulnerabilities. The identified issues, particularly concerning reentrancy, timestamp dependence, and access control, pose significant risks to the integrity and security of the contract. 

To mitigate these vulnerabilities, the following recommendations are proposed:

- **Enhance Reentrancy Protection**: Ensure that all external calls are made after state changes and consider using checks-effects-interactions pattern to prevent reentrancy attacks.
  
- **Implement Robust Access Control**: Review and strengthen access control mechanisms to ensure that only authorized users can perform sensitive operations. Consider using role-based access control for better granularity.

- **Improve Input Validation**: Implement comprehensive checks for all inputs to functions, ensuring that they meet expected formats and constraints.

- **Utilize Events for State Changes**: Ensure that all critical state changes are accompanied by event emissions to facilitate tracking and debugging.

- **Address Front-Running Risks**: Consider implementing mechanisms such as commit-reveal schemes or time-locks to mitigate front-running risks.

- **Review Protocol Fee Logic**: Conduct a thorough review of the protocol fee management logic to ensure that it is secure and does not allow for exploitation.

In conclusion, while the `GeneralIndexModule` contract provides valuable functionality for managing index rebalances, addressing the identified vulnerabilities is crucial to ensuring the security and reliability of the contract in a production environment. Regular audits and updates, along with adherence to best practices in smart contract development, will further enhance the contract's resilience against potential attacks.

[2024-01-09 01:47:04 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the Smart Contract

1. **Reentrancy Vulnerability**:
   - The contract uses external calls to execute trades, which could potentially allow a malicious actor to re-enter the contract during the execution of a trade, leading to unexpected behavior or loss of funds. Although `ReentrancyGuard` is used, it is crucial to ensure that all external calls are properly managed.

2. **Timestamp Dependence**:
   - The contract relies on `block.timestamp` for managing trade cool-off periods. This can be manipulated by miners to some extent, which may allow them to influence the timing of trades and exploit the cool-off mechanism.

3. **Access Control Issues**:
   - While there are modifiers to restrict access to certain functions, there may be scenarios where the access control logic could be bypassed, especially if the contract is not properly initialized or if the manager's privileges are not adequately protected.

4. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath` for arithmetic operations, it is essential to ensure that all calculations are properly guarded against overflow and underflow, especially in critical functions that manage balances and trade sizes.

5. **Improper Input Validation**:
   - The contract lacks comprehensive input validation in several functions, which could lead to unexpected behavior or state changes. For example, checks for valid addresses and ensuring that arrays are of the correct length should be enforced more rigorously.

6. **Lack of Event Emission**:
   - Certain state-changing functions do not emit events, which can hinder the ability to track changes and debug issues. It is essential to emit events for all significant state changes to maintain transparency and traceability.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, where a malicious actor could observe pending transactions and execute their own transactions to profit at the expense of others.

8. **Protocol Fee Management**:
   - The handling of protocol fees may not be adequately secured, leading to potential loss of funds if the fee calculation or transfer logic is exploited.

### Comprehensive Analysis Report

The `GeneralIndexModule` contract presents a sophisticated mechanism for managing index rebalances, but it is not without its vulnerabilities. The identified issues, particularly concerning reentrancy, timestamp dependence, and access control, pose significant risks to the integrity and security of the contract. 

To mitigate these vulnerabilities, the following recommendations are proposed:

- **Enhance Reentrancy Protection**: Ensure that all external calls are made after state changes and consider using checks-effects-interactions pattern to prevent reentrancy attacks.
  
- **Implement Robust Access Control**: Review and strengthen access control mechanisms to ensure that only authorized users can perform sensitive operations. Consider using role-based access control for better granularity.

- **Improve Input Validation**: Implement comprehensive checks for all inputs to functions, ensuring that they meet expected formats and constraints.

- **Utilize Events for State Changes**: Ensure that all critical state changes are accompanied by event emissions to facilitate tracking and debugging.

- **Address Front-Running Risks**: Consider implementing mechanisms such as commit-reveal schemes or time-locks to mitigate front-running risks.

- **Review Protocol Fee Logic**: Conduct a thorough review of the protocol fee management logic to ensure that it is secure and does not allow for exploitation.

In conclusion, while the `GeneralIndexModule` contract provides valuable functionality for managing index rebalances, addressing the identified vulnerabilities is crucial to ensuring the security and reliability of the contract in a production environment. Regular audits and updates, along with adherence to best practices in smart contract development, will further enhance the contract's resilience against potential attacks.

[2024-01-09 01:47:04 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 01:47:05 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Math } from "@openzeppelin/contracts/math/Math.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\n\nimport { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";\nimport { Invoke } from "../../lib/Invoke.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\nimport { Position } from "../../lib/Position.sol";\nimport { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";\nimport { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";\n\n\n/\n * @title GeneralIndexModule\n * @author Set Protocol\n \n * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().\n * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over\n * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed\n * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.\n * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-\n * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance\n * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component\'s\n * target allocation is met any further attempted trades of that component will revert.\n \n * SECURITY ASSUMPTION:\n *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using\n *    this module need to be examined separately)\n /\ncontract GeneralIndexModule is ModuleBase, ReentrancyGuard {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using Position for uint256;\n    using Math for uint256;\n    using Position for ISetToken;\n    using Invoke for ISetToken;\n    using AddressArrayUtils for address[];\n    using AddressArrayUtils for IERC20[];\n    using Uint256ArrayUtils for uint256[];\n\n    / ============ Struct ============ /\n\n    struct TradeExecutionParams {\n        uint256 targetUnit;              // Target unit of component for Set\n        uint256 maxSize;                 // Max trade size in precise units\n        uint256 coolOffPeriod;           // Required time between trades for the asset\n        uint256 lastTradeTimestamp;      // Timestamp of last trade\n        string exchangeName;             // Name of exchange adapter\n        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)\n    }\n\n    struct TradePermissionInfo {\n        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade\n        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal\n        mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade\n    }\n\n    struct RebalanceInfo {\n        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance\n        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)\n        address[] rebalanceComponents;      // Array of components involved in rebalance\n    }\n\n    struct TradeInfo {\n        ISetToken setToken;                         // Instance of SetToken\n        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter\n        address sendToken;                          // Address of token being sold\n        address receiveToken;                       // Address of token being bought\n        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token\n        uint256 setTotalSupply;                     // Total supply of Set (in precise units)\n        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded\n        uint256 sendQuantity;                       // Units of component sent to the exchange\n        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade\n        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought\n        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange\n    }\n\n    / ============ Events ============ /\n\n    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);\n    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);\n    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);\n    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);\n    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);\n    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);\n\n    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);\n    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);\n\n    event TradeExecuted(\n        ISetToken indexed _setToken,\n        address indexed _sellComponent,\n        address indexed _buyComponent,\n        IIndexExchangeAdapter _exchangeAdapter,\n        address _executor,\n        uint256 _netAmountSold,\n        uint256 _netAmountReceived,\n        uint256 _protocolFee\n    );\n\n    event RebalanceStarted(\n        ISetToken indexed _setToken,\n        address[] aggregateComponents,\n        uint256[] aggregateTargetUnits,\n        uint256 indexed positionMultiplier\n    );\n\n    / ============ Constants ============ /\n\n    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller\n\n    / ============ State Variables ============ /\n\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken\n    mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions\n    mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance\n    IWETH public immutable weth;                                                            // Weth contract address\n\n    / ============ Modifiers ============ /\n\n    modifier onlyAllowedTrader(ISetToken setToken) {\n        _validateOnlyAllowedTrader(_setToken);\n        ;\n    }\n\n    modifier onlyEOAIfUnrestricted(ISetToken setToken) {\n        _validateOnlyEOAIfUnrestricted(_setToken);\n        ;\n    }\n\n    / ============ Constructor ============ /\n\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n\n    / ============ External Functions ============ */\n\n    /\n     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager\n     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 1018\n     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the\n     * SetToken. If a component is being removed it\'s index in the _oldComponentsTargetUnits should be set to 0. Additionally, the\n     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs\n     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.\n     \n     * @param _setToken                         Address of the SetToken to be rebalanced\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units\n     *                                               if fees accrued\n     /\n    function startRebalance(\n        ISetToken _setToken,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits,\n        uint256 _positionMultiplier\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(\n            _setToken.getComponents(),\n            _newComponents,\n            _newComponentsTargetUnits,\n            _oldComponentsTargetUnits\n        );\n\n        for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {\n            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");\n            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];\n        }\n\n        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;\n        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;\n\n        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);\n    }\n\n    /\n     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().\n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.\n     \n     * Trade can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Trader can pass\n     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.\n     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default\n     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,\n     * if enabled, are collected in the token received in a trade.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _component            Address of SetToken component to trade\n     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade\n     /\n    function trade(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        _validateTradeParameters(_setToken, _component);\n\n        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);\n\n        _executeTrade(tradeInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n\n    /\n     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be\n     * traded such that resulting inflows won\'t exceed component\'s maxTradeSize nor overshoot the target unit. To be used near the end of rebalances\n     * when a component\'s calculated trade size is greater in value than remaining WETH.\n     \n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade\n     * can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Like with trade()\n     * a minimum component receive amount can be set.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _component                    Address of the SetToken component to trade\n     * @param _minComponentReceived        Min amount of component received during trade\n     /\n    function tradeRemainingWETH(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        require(_noTokensToSell(_setToken), "Sell other set components first");\n        require(\n            executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),\n            "WETH is below target unit"\n        );\n\n        _validateTradeParameters(_setToken, _component);\n\n        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);\n\n        _executeTrade(tradeInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n\n        require(\n            netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,\n            "Trade amount &gt; max trade size"\n        );\n\n        _validateComponentPositionUnit(_setToken, _component);\n\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n\n    /\n     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying\n     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,\n     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error\n     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components\n     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is\n     * spent buying the components to meet their new target.\n     \n     * @param _setToken             Address of the SetToken\n     /\n    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {\n        require(\n            _allTargetsMet(_setToken)\n            &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),\n            "Targets not met or ETH =~ 0"\n        );\n\n        // positionMultiplier / (10^18 + raiseTargetPercentage)\n        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087\n        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(\n            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)\n        );\n        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);\n    }\n\n    /\n     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.\n     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by\n     * default and trades will not execute if a component\'s trade size is greater than the maximum.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _tradeMaximums        Array of trade maximums mapping to correct component\n     /\n    function setTradeMaximums(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _tradeMaximums\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_tradeMaximums);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];\n            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeNames        Array of exchange names mapping to correct component\n     /\n    function setExchanges(\n        ISetToken _setToken,\n        address[] memory _components,\n        string[] memory _exchangeNames\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeNames);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            if (_components[i] != address(weth)) {\n\n                require(\n                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),\n                    "Unrecognized exchange name"\n                );\n\n                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];\n                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);\n            }\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _coolOffPeriods       Array of cool off periods to correct component\n     /\n    function setCoolOffPeriods(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _coolOffPeriods\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_coolOffPeriods);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];\n            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying\n     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeData         Array of exchange specific arbitrary bytes data\n     /\n    function setExchangeData(\n        ISetToken _setToken,\n        address[] memory _components,\n        bytes[] memory _exchangeData\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeData);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];\n            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set amount by which all component\'s targets units would be raised. Can be called at any time.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _raiseTargetPercentage        Amount to raise all component\'s unit targets by (in precise units)\n     /\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n\n    /\n     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.\n     \n     * @param _setToken          Address of the SetToken\n     * @param _traders           Array trader addresses to toggle status\n     * @param _statuses          Booleans indicating if matching trader can trade\n     /\n    function setTraderStatus(\n        ISetToken _setToken,\n        address[] memory _traders,\n        bool[] memory _statuses\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _traders.validatePairsWithArray(_statuses);\n\n        for (uint256 i = 0; i &lt; _traders.length; i++) {\n            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);\n            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];\n            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _status           Boolean indicating if anyone can trade\n     /\n    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {\n        permissionInfo[_setToken].anyoneTrade = _status;\n        emit AnyoneTradeUpdated(_setToken, _status);\n    }\n\n    /\n     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.\n     * Grabs the current units for each asset in the Set and set\'s the targetUnit to that unit in order to prevent any\n     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any\n     * position multiplier changes don\'t unintentionally open the Set for rebalancing.\n     \n     * @param _setToken         Address of the Set Token\n     /\n    function initialize(ISetToken _setToken)\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n\n        for (uint256 i = 0; i &lt; positions.length; i++) {\n            ISetToken.Position memory position = positions[i];\n            require(position.positionState == 0, "External positions not allowed");\n            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();\n            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;\n        }\n\n        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();\n        _setToken.initializeModule();\n    }\n\n    /\n     * Called by a SetToken to notify that this module was removed from the SetToken.\n     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.\n     * IMPORTANT: SetToken\'s execution settings, including trade maximums and exchange names,\n     * are NOT DELETED. Restoring a previously removed module requires that care is taken to\n     * initialize execution settings appropriately.\n     /\n    function removeModule() external override {\n        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];\n\n        for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {\n            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;\n        }\n\n        delete rebalanceInfo[ISetToken(msg.sender)];\n        delete permissionInfo[ISetToken(msg.sender)];\n    }\n\n    / ============ External View Functions ============ /\n\n    /\n     * Get the array of SetToken components involved in rebalance.\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]        Array of _setToken components involved in rebalance\n     /\n    function getRebalanceComponents(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return rebalanceInfo[_setToken].rebalanceComponents;\n    }\n\n    /\n     * Calculates the amount of a component that is going to be traded and whether the component is being bought\n     * or sold. If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return componentQuantity        Amount of component being traded\n     */\n    function getComponentTradeQuantityAndDirection(\n        ISetToken _setToken,\n        IERC20 _component\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool, uint256)\n    {\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not recognized"\n        );\n        uint256 totalSupply = _setToken.totalSupply();\n        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);\n    }\n\n\n    /\n     * Get if a given address is an allowed trader.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _trader           Address of the trader\n     \n     * @return bool             True if _trader is allowed to trade, else false\n     /\n    function getIsAllowedTrader(ISetToken _setToken, address _trader)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool)\n    {\n        return _isAllowedTrader(_setToken, _trader);\n    }\n\n    /\n     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]\n     /\n    function getAllowedTraders(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return permissionInfo[_setToken].tradersHistory;\n    }\n\n    / ============ Internal Functions ============ /\n\n    /\n     * A rebalance is a multi-step process in which current Set components are sold for a\n     * bridge asset (WETH) before buying target components in the correct amount to achieve\n     * the desired balance between elements in the set.\n     \n     *        Step 1        |       Step 2\n     * -------------------------------------------\n     * Component --&gt; WETH   |   WETH --&gt; Component\n     * -------------------------------------------\n     \n     * The syntax we use frames this as trading from a "fixed" amount of one component to a\n     * "fixed" amount of another via a "floating limit" which is either the maximum size of\n     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum\n     * amount of tokens we expect to receive. The different meanings of the floating limit map to\n     * the trade sequence as below:\n     \n     * Step 1: Component --&gt; WETH\n     * ----------------------------------------------------------\n     *                     | Fixed  |     Floating limit        |\n     * ----------------------------------------------------------\n     * send  (Component)   |  YES   |                           |\n     * recieve (WETH)      |        |   Min WETH to receive     |\n     * ----------------------------------------------------------\n     \n     * Step 2: WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     |  Fixed  |    Floating limit        |\n     * ----------------------------------------------------------\n     * send  (WETH)        |   NO    |  Max WETH to send        |\n     * recieve (Component) |   YES   |                          |\n     * ----------------------------------------------------------\n     \n     * Additionally, there is an edge case where price volatility during a rebalance\n     * results in remaining WETH which needs to be allocated proportionately. In this case\n     * the values are as below:\n     \n     * Edge case: Remaining WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     | Fixed  |    Floating limit         |\n     * ----------------------------------------------------------\n     * send  (WETH)        |  YES   |                           |\n     * recieve (Component) |        | Min component to receive  |\n     * ----------------------------------------------------------\n    */\n\n    /\n     * Create and return TradeInfo struct. This function reverts if the target has already been met.\n     * If this is a trade from component into WETH, sell the total fixed component quantity\n     * and expect to receive an ETH amount the user has specified (or more). If it\'s a trade from\n     * WETH into a component, sell the lesser of: the user\'s WETH limit OR the SetToken\'s\n     * remaining WETH balance and expect to receive a fixed component quantity.\n     \n     * @param _setToken             Instance of the SetToken to rebalance\n     * @param _component            IERC20 component to trade\n     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade\n     \n     * @return tradeInfo            Struct containing data for trade\n     /\n    function _createTradeInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        internal\n        view\n        virtual\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);\n\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;\n            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;\n        } else {\n            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);\n            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;\n        }\n    }\n\n    /\n     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param _minComponentReceived         Min amount of component received during trade\n     \n     * @return tradeInfo                    Struct containing data for tradeRemaining info\n     /\n    function _createTradeRemainingInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);\n\n        (,,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);\n\n        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);\n        tradeInfo.floatingQuantityLimit = _minComponentReceived;\n        tradeInfo.isSendTokenFixed = true;\n    }\n\n    /\n     * Create and returns a partial TradeInfo struct with all fields that overlap between trade\n     * and tradeRemaining info constructors filled in. Values for sendQuantity and floatingQuantityLimit\n     * are derived separately, outside this method. trade requires that trade size and direction are\n     * calculated, whereas tradeRemaining automatically sets WETH as the sendToken and _component\n     * as receiveToken.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction\n     \n     * @return tradeInfo                    Struct containing partial data for trade\n     */\n    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo.setToken = _setToken;\n        tradeInfo.setTotalSupply = _setToken.totalSupply();\n        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);\n        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;\n\n        if(calculateTradeDirection){\n            (\n                tradeInfo.isSendTokenFixed,\n                tradeInfo.totalFixedQuantity\n            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);\n        }\n\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendToken = address(_component);\n            tradeInfo.receiveToken = address(weth);\n        } else {\n            tradeInfo.sendToken = address(weth);\n            tradeInfo.receiveToken = address(_component);\n        }\n\n        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));\n        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));\n    }\n\n    /\n     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed\n     * quantity of a token in return for a non-fixed (floating) quantity of a token. If isSendTokenFixed is true then the adapter\n     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for\n     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.\n     \n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     /\n    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {\n        _tradeInfo.setToken.invokeApprove(\n            _tradeInfo.sendToken,\n            _tradeInfo.exchangeAdapter.getSpender(),\n            _tradeInfo.sendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(\n            _tradeInfo.sendToken,\n            _tradeInfo.receiveToken,\n            address(_tradeInfo.setToken),\n            _tradeInfo.isSendTokenFixed,\n            _tradeInfo.sendQuantity,\n            _tradeInfo.floatingQuantityLimit,\n            _tradeInfo.exchangeData\n        );\n\n        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);\n    }\n\n    /\n     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.\n     * The protocol fee is collected from the amount of received token in the trade.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     \n     * @return protocolFee              Amount of receive token taken as protocol fee\n     */\n    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {\n        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)\n            .balanceOf(address(_tradeInfo.setToken))\n            .sub(_tradeInfo.preTradeReceiveTokenBalance);\n\n        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);\n        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);\n    }\n\n    /\n     * Update SetToken positions and executionInfo\'s last trade timestamp. This function is intended\n     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     * @param _component                IERC20 component which was traded\n     \n     * @return netSendAmount            Amount of sendTokens used in the trade\n     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)\n     /\n    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)\n        internal\n        returns (uint256 netSendAmount, uint256 netReceiveAmount)\n    {\n        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.sendToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeSendTokenBalance\n        );\n        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.receiveToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeReceiveTokenBalance\n        );\n\n        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);\n        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);\n\n        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;\n    }\n\n    /\n     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It\'s\n     * necessary to verify that traderHistory contains the address because AddressArrayUtils will\n     * throw when attempting to remove a non-element and it\'s possible someone can set a new\n     * trader\'s status to false.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _trader                           Trader whose permission is being set\n     * @param _status                           Boolean permission being set\n\n     /\n    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {\n        if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.push(_trader);\n        } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);\n        }\n    }\n\n    /\n     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.\n     * If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     * @param _totalSupply              Total supply of _setToken\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return totalFixedQuantity       Amount of fixed token to send or receive\n     /\n    function _calculateTradeSizeAndDirection(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _totalSupply\n    )\n        internal\n        view\n        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)\n    {\n        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);\n        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;\n\n        (\n            uint256 currentUnit,\n            uint256 targetUnit,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);\n\n        require(currentUnit != targetUnit, "Target already met");\n\n        isSendTokenFixed = targetNotional &lt; currentNotional;\n\n        // In order to account for fees taken by protocol when buying the notional difference between currentUnit\n        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to\n        // do so would lead to never being able to meet target of components that need to be bought.\n        //\n        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))\n        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)\n        totalFixedQuantity = isSendTokenFixed\n            ? componentMaxSize.min(currentNotional.sub(targetNotional))\n            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));\n    }\n\n    /\n     * Check if all targets are met.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if all component\'s target units have been met, otherwise false\n     */\n    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }\n        }\n        return true;\n    }\n\n    /\n     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise\n     * needs to be approved.\n     \n     * @param _setToken             Instance of SetToken to be rebalanced\n     * @param  _trader              Address of the trader who called contract function\n     \n     * @return bool                 True if trader is an approved trader for the SetToken\n     /\n    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {\n        TradePermissionInfo storage permissions = permissionInfo[_setToken];\n        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];\n    }\n\n    /\n     * Checks if sell conditions are met. The component cannot be WETH and its normalized target\n     * unit must be less than its default position real unit\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component evaluated for sale\n     \n     * @return bool                             True if sell allowed, false otherwise\n     /\n    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {\n        return (\n            _component != address(weth) &amp;&amp;\n            (\n                _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;\n                _getDefaultPositionRealUnit(_setToken,IERC20(_component))\n            )\n        );\n    }\n\n    /\n     * Check if there are any more tokens to sell. Since we allow WETH to float around it\'s target during rebalances it is not checked.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if there is not any component that can be sold, otherwise false\n     */\n    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }\n        }\n        return true;\n    }\n\n    /\n     * Determines if a target is met. Due to small rounding errors converting between virtual and\n     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to\n     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not\n     * checked as it is allowed to float around its target.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component whose target is evaluated\n     \n     * @return bool                             True if component\'s target units are met, false otherwise\n     /\n    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {\n        if (_component == address(weth)) return false;\n\n        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));\n\n        return (normalizedTargetUnit &gt; 0)\n            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))\n            : normalizedTargetUnit != currentUnit;\n    }\n\n    /\n     * Validate component position unit has not exceeded it\'s target unit. This is used during tradeRemainingWETH() to make sure\n     * the amount of component bought does not exceed the targetUnit.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component whose position units are to be validated\n     /\n    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n        require(currentUnit &lt;= targetUnit, "Can not exceed target unit");\n    }\n\n    /\n     * Validate that component is a valid component and enough time has elapsed since component\'s last trade. Traders\n     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to be validated\n     /\n    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {\n        require(address(_component) != address(weth), "Can not explicitly trade WETH");\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not part of rebalance"\n        );\n\n        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];\n        require(\n            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,\n            "Component cool off in progress"\n        );\n\n        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");\n    }\n\n    /\n     * Extends and/or updates the current component set and its target units with new components and targets,\n     * Validates inputs, requiring that that new components and new target units arrays are the same size, and\n     * that the number of old components target units matches the number of current components. Throws if\n     * a duplicate component has been added.\n     \n     * @param  _currentComponents               Complete set of current SetToken components\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     \n     * @return aggregateComponents              Array of current components extended by new components, without duplicates\n     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates\n     /\n    function _getAggregateComponentsAndUnits(\n        address[] memory _currentComponents,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits\n    )\n        internal\n        pure\n        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)\n    {\n        // Don\'t use validate arrays because empty arrays are valid\n        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");\n        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");\n\n        aggregateComponents = _currentComponents.extend(_newComponents);\n        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);\n\n        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");\n    }\n\n    /\n     * Get the SetToken\'s default position as uint256\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to fetch the default position for\n     \n     * return uint256           Real unit position\n     */\n    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {\n        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();\n    }\n\n    /\n     * Gets exchange adapter address for a component after checking that it exists in the\n     * IntegrationRegistry. This method is called during a trade and must validate the adapter\n     * because its state may have changed since it was set in a separate transaction.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        IERC20 component whose exchange adapter is fetched\n     \n     * @return IExchangeAdapter                 Adapter address\n     /\n    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {\n        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));\n    }\n\n    /\n     * Calculates and returns the normalized target unit value.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     * @param _component            IERC20 component whose normalized target unit is required\n     \n     * @return uint256                          Normalized target unit of the component\n     /\n    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {\n        // (targetUnit * current position multiplier) / position multiplier when rebalance started\n        return executionInfo[_setToken][_component]\n            .targetUnit\n            .mul(_setToken.positionMultiplier().toUint256())\n            .div(rebalanceInfo[_setToken].positionMultiplier);\n    }\n\n    /\n     * Gets unit and notional amount values for current position and target. These are necessary\n     * to calculate the trade size and direction for regular trades and the sendQuantity for\n     * remainingWEth trades.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to calculate notional amounts for\n     * @param _totalSupply              SetToken total supply\n     \n     * @return uint256              Current default position real unit of component\n     * @return uint256              Normalized unit of the trade target\n     * @return uint256              Current notional amount: total notional amount of SetToken default position\n     * @return uint256              Target notional amount: Total SetToken supply * targetUnit\n     /\n    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)\n        internal\n        view\n        returns (uint256, uint256, uint256, uint256)\n    {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n\n        return (\n            currentUnit,\n            targetUnit,\n            _totalSupply.getDefaultTotalNotional(currentUnit),\n            _totalSupply.preciseMulCeil(targetUnit)\n        );\n    }\n\n    / ============== Modifier Helpers ===============\n     * Internal functions used to reduce bytecode size\n     /\n\n    /\n     * Trader must be permissioned for SetToken\n     /\n    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {\n        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");\n    }\n\n    /\n     * Trade must be an EOA if anyoneTrade has been enabled for SetToken on the module.\n     */\n    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {\n        if(permissionInfo[_setToken].anyoneTrade) {\n            require(msg.sender == tx.origin, "Caller must be EOA Address");\n        }\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 01:47:05 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 01:47:05 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 01:47:08 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 01:47:08 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 23170
completion_tokens: 1
total_tokens: 23171
cost: $-1.000000


[2024-01-09 01:47:08 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

###

[2024-01-09 01:47:08 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 01:47:08 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 01:47:08 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 01:47:08 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 01:47:08 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 01:47:19 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 01:47:19 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 11644
completion_tokens: 862
total_tokens: 12506
cost: $-1.000000


[2024-01-09 01:47:19 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Based on the provided smart contract code for the `GeneralIndexModule`, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract uses external calls to execute trades, which can potentially lead to reentrancy attacks if not properly managed. Although `ReentrancyGuard` is used, it is crucial to ensure that all external calls are made after state changes to mitigate this risk.

2. **Timestamp Dependency**:
   - The contract relies on `block.timestamp` for managing trade cool-off periods. This can be manipulated by miners, leading to potential exploitation where a trader could bypass the cool-off period.

3. **Access Control Issues**:
   - The `onlyAllowedTrader` modifier allows for traders to be added or removed dynamically. If the management of trader permissions is not handled carefully, it could lead to unauthorized trading actions.

4. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is essential to ensure that all arithmetic operations are consistently protected against overflow and underflow, especially in calculations involving trade sizes and balances.

5. **External Position Handling**:
   - The contract checks for external positions but does not provide a clear mechanism for handling them if they are detected. This could lead to unexpected behavior if external positions are inadvertently introduced.

6. **Protocol Fee Calculation**:
   - The protocol fee is calculated based on the exchanged quantity, which could lead to discrepancies if not properly validated. If the fee calculation logic is flawed, it could result in incorrect fee distributions.

7. **Lack of Input Validation**:
   - Some functions do not adequately validate input parameters, such as ensuring that arrays passed to functions are of the correct length or that components are valid before executing trades.

8. **Potential for Sandwich Attacks**:
   - The contract allows traders to specify maximum/minimum amounts for trades, but without proper checks, this could lead to sandwich attacks where a malicious actor could manipulate the market price before and after a trade.

### Comprehensive Analysis Report

The `GeneralIndexModule` contract is designed to facilitate rebalances for indices, allowing managers to update allocations and traders to execute trades. However, several security vulnerabilities have been identified that could pose significant risks to the integrity and functionality of the contract.

1. **Reentrancy**: While the use of `ReentrancyGuard` is a positive measure, the potential for reentrancy attacks remains a concern, especially given the reliance on external calls. It is recommended to follow best practices by ensuring that all state changes occur before any external calls.

2. **Timestamp Manipulation**: The reliance on `block.timestamp` for managing trade cool-off periods introduces a vulnerability that could be exploited by miners. Consider using block numbers or implementing a more robust time management system.

3. **Access Control**: The dynamic management of trader permissions necessitates rigorous oversight to prevent unauthorized access. Implementing a more granular access control mechanism could enhance security.

4. **Arithmetic Safety**: Although `SafeMath` is employed, it is vital to ensure that all arithmetic operations are consistently protected. A thorough review of all calculations is recommended to prevent potential overflow or underflow issues.

5. **Handling External Positions**: The contract's handling of external positions needs to be clearly defined to avoid unexpected behaviors. Implementing strict checks and balances for external positions is crucial.

6. **Protocol Fee Logic**: The calculation of protocol fees should be carefully validated to ensure accuracy and fairness in fee distribution. A review of the fee calculation logic is warranted.

7. **Input Validation**: Strengthening input validation across all functions will help mitigate risks associated with incorrect or malicious inputs. This includes validating array lengths and ensuring that components are legitimate.

8. **Sandwich Attack Mitigation**: To protect against sandwich attacks, additional checks should be implemented to validate trade parameters and ensure that trades cannot be manipulated by external actors.

In conclusion, while the `GeneralIndexModule` contract provides essential functionality for managing indices, it is imperative to address the identified vulnerabilities to ensure the security and reliability of the contract. A comprehensive security audit and ongoing monitoring will be essential to safeguard against potential exploits and maintain the integrity of the system.

[2024-01-09 01:47:19 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `GeneralIndexModule`, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract uses external calls to execute trades, which can potentially lead to reentrancy attacks if not properly managed. Although `ReentrancyGuard` is used, it is crucial to ensure that all external calls are made after state changes to mitigate this risk.

2. **Timestamp Dependency**:
   - The contract relies on `block.timestamp` for managing trade cool-off periods. This can be manipulated by miners, leading to potential exploitation where a trader could bypass the cool-off period.

3. **Access Control Issues**:
   - The `onlyAllowedTrader` modifier allows for traders to be added or removed dynamically. If the management of trader permissions is not handled carefully, it could lead to unauthorized trading actions.

4. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is essential to ensure that all arithmetic operations are consistently protected against overflow and underflow, especially in calculations involving trade sizes and balances.

5. **External Position Handling**:
   - The contract checks for external positions but does not provide a clear mechanism for handling them if they are detected. This could lead to unexpected behavior if external positions are inadvertently introduced.

6. **Protocol Fee Calculation**:
   - The protocol fee is calculated based on the exchanged quantity, which could lead to discrepancies if not properly validated. If the fee calculation logic is flawed, it could result in incorrect fee distributions.

7. **Lack of Input Validation**:
   - Some functions do not adequately validate input parameters, such as ensuring that arrays passed to functions are of the correct length or that components are valid before executing trades.

8. **Potential for Sandwich Attacks**:
   - The contract allows traders to specify maximum/minimum amounts for trades, but without proper checks, this could lead to sandwich attacks where a malicious actor could manipulate the market price before and after a trade.

### Comprehensive Analysis Report

The `GeneralIndexModule` contract is designed to facilitate rebalances for indices, allowing managers to update allocations and traders to execute trades. However, several security vulnerabilities have been identified that could pose significant risks to the integrity and functionality of the contract.

1. **Reentrancy**: While the use of `ReentrancyGuard` is a positive measure, the potential for reentrancy attacks remains a concern, especially given the reliance on external calls. It is recommended to follow best practices by ensuring that all state changes occur before any external calls.

2. **Timestamp Manipulation**: The reliance on `block.timestamp` for managing trade cool-off periods introduces a vulnerability that could be exploited by miners. Consider using block numbers or implementing a more robust time management system.

3. **Access Control**: The dynamic management of trader permissions necessitates rigorous oversight to prevent unauthorized access. Implementing a more granular access control mechanism could enhance security.

4. **Arithmetic Safety**: Although `SafeMath` is employed, it is vital to ensure that all arithmetic operations are consistently protected. A thorough review of all calculations is recommended to prevent potential overflow or underflow issues.

5. **Handling External Positions**: The contract's handling of external positions needs to be clearly defined to avoid unexpected behaviors. Implementing strict checks and balances for external positions is crucial.

6. **Protocol Fee Logic**: The calculation of protocol fees should be carefully validated to ensure accuracy and fairness in fee distribution. A review of the fee calculation logic is warranted.

7. **Input Validation**: Strengthening input validation across all functions will help mitigate risks associated with incorrect or malicious inputs. This includes validating array lengths and ensuring that components are legitimate.

8. **Sandwich Attack Mitigation**: To protect against sandwich attacks, additional checks should be implemented to validate trade parameters and ensure that trades cannot be manipulated by external actors.

In conclusion, while the `GeneralIndexModule` contract provides essential functionality for managing indices, it is imperative to address the identified vulnerabilities to ensure the security and reliability of the contract. A comprehensive security audit and ongoing monitoring will be essential to safeguard against potential exploits and maintain the integrity of the system.

[2024-01-09 01:47:19 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 01:47:20 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Math } from "@openzeppelin/contracts/math/Math.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\n\nimport { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";\nimport { Invoke } from "../../lib/Invoke.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\nimport { Position } from "../../lib/Position.sol";\nimport { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";\nimport { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";\n\n\n/\n * @title GeneralIndexModule\n * @author Set Protocol\n \n * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().\n * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over\n * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed\n * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.\n * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-\n * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance\n * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component\'s\n * target allocation is met any further attempted trades of that component will revert.\n \n * SECURITY ASSUMPTION:\n *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using\n *    this module need to be examined separately)\n /\ncontract GeneralIndexModule is ModuleBase, ReentrancyGuard {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using Position for uint256;\n    using Math for uint256;\n    using Position for ISetToken;\n    using Invoke for ISetToken;\n    using AddressArrayUtils for address[];\n    using AddressArrayUtils for IERC20[];\n    using Uint256ArrayUtils for uint256[];\n\n    / ============ Struct ============ /\n\n    struct TradeExecutionParams {\n        uint256 targetUnit;              // Target unit of component for Set\n        uint256 maxSize;                 // Max trade size in precise units\n        uint256 coolOffPeriod;           // Required time between trades for the asset\n        uint256 lastTradeTimestamp;      // Timestamp of last trade\n        string exchangeName;             // Name of exchange adapter\n        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)\n    }\n\n    struct TradePermissionInfo {\n        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade\n        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal\n        mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade\n    }\n\n    struct RebalanceInfo {\n        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance\n        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)\n        address[] rebalanceComponents;      // Array of components involved in rebalance\n    }\n\n    struct TradeInfo {\n        ISetToken setToken;                         // Instance of SetToken\n        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter\n        address sendToken;                          // Address of token being sold\n        address receiveToken;                       // Address of token being bought\n        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token\n        uint256 setTotalSupply;                     // Total supply of Set (in precise units)\n        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded\n        uint256 sendQuantity;                       // Units of component sent to the exchange\n        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade\n        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought\n        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange\n    }\n\n    / ============ Events ============ /\n\n    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);\n    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);\n    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);\n    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);\n    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);\n    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);\n\n    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);\n    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);\n\n    event TradeExecuted(\n        ISetToken indexed _setToken,\n        address indexed _sellComponent,\n        address indexed _buyComponent,\n        IIndexExchangeAdapter _exchangeAdapter,\n        address _executor,\n        uint256 _netAmountSold,\n        uint256 _netAmountReceived,\n        uint256 _protocolFee\n    );\n\n    event RebalanceStarted(\n        ISetToken indexed _setToken,\n        address[] aggregateComponents,\n        uint256[] aggregateTargetUnits,\n        uint256 indexed positionMultiplier\n    );\n\n    / ============ Constants ============ /\n\n    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller\n\n    / ============ State Variables ============ /\n\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken\n    mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions\n    mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance\n    IWETH public immutable weth;                                                            // Weth contract address\n\n    / ============ Modifiers ============ /\n\n    modifier onlyAllowedTrader(ISetToken setToken) {\n        _validateOnlyAllowedTrader(_setToken);\n        ;\n    }\n\n    modifier onlyEOAIfUnrestricted(ISetToken setToken) {\n        _validateOnlyEOAIfUnrestricted(_setToken);\n        ;\n    }\n\n    / ============ Constructor ============ /\n\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n\n    / ============ External Functions ============ */\n\n    /\n     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager\n     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 1018\n     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the\n     * SetToken. If a component is being removed it\'s index in the _oldComponentsTargetUnits should be set to 0. Additionally, the\n     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs\n     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.\n     \n     * @param _setToken                         Address of the SetToken to be rebalanced\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units\n     *                                               if fees accrued\n     /\n    function startRebalance(\n        ISetToken _setToken,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits,\n        uint256 _positionMultiplier\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(\n            _setToken.getComponents(),\n            _newComponents,\n            _newComponentsTargetUnits,\n            _oldComponentsTargetUnits\n        );\n\n        for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {\n            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");\n            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];\n        }\n\n        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;\n        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;\n\n        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);\n    }\n\n    /\n     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().\n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.\n     \n     * Trade can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Trader can pass\n     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.\n     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default\n     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,\n     * if enabled, are collected in the token received in a trade.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _component            Address of SetToken component to trade\n     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade\n     /\n    function trade(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        _validateTradeParameters(_setToken, _component);\n\n        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);\n\n        _executeTrade(tradeInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n\n    /\n     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be\n     * traded such that resulting inflows won\'t exceed component\'s maxTradeSize nor overshoot the target unit. To be used near the end of rebalances\n     * when a component\'s calculated trade size is greater in value than remaining WETH.\n     \n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade\n     * can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Like with trade()\n     * a minimum component receive amount can be set.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _component                    Address of the SetToken component to trade\n     * @param _minComponentReceived        Min amount of component received during trade\n     /\n    function tradeRemainingWETH(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        require(_noTokensToSell(_setToken), "Sell other set components first");\n        require(\n            executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),\n            "WETH is below target unit"\n        );\n\n        _validateTradeParameters(_setToken, _component);\n\n        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);\n\n        _executeTrade(tradeInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n\n        require(\n            netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,\n            "Trade amount &gt; max trade size"\n        );\n\n        _validateComponentPositionUnit(_setToken, _component);\n\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n\n    /\n     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying\n     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,\n     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error\n     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components\n     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is\n     * spent buying the components to meet their new target.\n     \n     * @param _setToken             Address of the SetToken\n     /\n    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {\n        require(\n            _allTargetsMet(_setToken)\n            &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),\n            "Targets not met or ETH =~ 0"\n        );\n\n        // positionMultiplier / (10^18 + raiseTargetPercentage)\n        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087\n        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(\n            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)\n        );\n        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);\n    }\n\n    /\n     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.\n     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by\n     * default and trades will not execute if a component\'s trade size is greater than the maximum.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _tradeMaximums        Array of trade maximums mapping to correct component\n     /\n    function setTradeMaximums(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _tradeMaximums\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_tradeMaximums);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];\n            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeNames        Array of exchange names mapping to correct component\n     /\n    function setExchanges(\n        ISetToken _setToken,\n        address[] memory _components,\n        string[] memory _exchangeNames\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeNames);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            if (_components[i] != address(weth)) {\n\n                require(\n                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),\n                    "Unrecognized exchange name"\n                );\n\n                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];\n                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);\n            }\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _coolOffPeriods       Array of cool off periods to correct component\n     /\n    function setCoolOffPeriods(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _coolOffPeriods\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_coolOffPeriods);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];\n            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying\n     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeData         Array of exchange specific arbitrary bytes data\n     /\n    function setExchangeData(\n        ISetToken _setToken,\n        address[] memory _components,\n        bytes[] memory _exchangeData\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeData);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];\n            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set amount by which all component\'s targets units would be raised. Can be called at any time.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _raiseTargetPercentage        Amount to raise all component\'s unit targets by (in precise units)\n     /\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n\n    /\n     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.\n     \n     * @param _setToken          Address of the SetToken\n     * @param _traders           Array trader addresses to toggle status\n     * @param _statuses          Booleans indicating if matching trader can trade\n     /\n    function setTraderStatus(\n        ISetToken _setToken,\n        address[] memory _traders,\n        bool[] memory _statuses\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _traders.validatePairsWithArray(_statuses);\n\n        for (uint256 i = 0; i &lt; _traders.length; i++) {\n            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);\n            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];\n            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _status           Boolean indicating if anyone can trade\n     /\n    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {\n        permissionInfo[_setToken].anyoneTrade = _status;\n        emit AnyoneTradeUpdated(_setToken, _status);\n    }\n\n    /\n     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.\n     * Grabs the current units for each asset in the Set and set\'s the targetUnit to that unit in order to prevent any\n     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any\n     * position multiplier changes don\'t unintentionally open the Set for rebalancing.\n     \n     * @param _setToken         Address of the Set Token\n     /\n    function initialize(ISetToken _setToken)\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n\n        for (uint256 i = 0; i &lt; positions.length; i++) {\n            ISetToken.Position memory position = positions[i];\n            require(position.positionState == 0, "External positions not allowed");\n            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();\n            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;\n        }\n\n        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();\n        _setToken.initializeModule();\n    }\n\n    /\n     * Called by a SetToken to notify that this module was removed from the SetToken.\n     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.\n     * IMPORTANT: SetToken\'s execution settings, including trade maximums and exchange names,\n     * are NOT DELETED. Restoring a previously removed module requires that care is taken to\n     * initialize execution settings appropriately.\n     /\n    function removeModule() external override {\n        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];\n\n        for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {\n            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;\n        }\n\n        delete rebalanceInfo[ISetToken(msg.sender)];\n        delete permissionInfo[ISetToken(msg.sender)];\n    }\n\n    / ============ External View Functions ============ /\n\n    /\n     * Get the array of SetToken components involved in rebalance.\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]        Array of _setToken components involved in rebalance\n     /\n    function getRebalanceComponents(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return rebalanceInfo[_setToken].rebalanceComponents;\n    }\n\n    /\n     * Calculates the amount of a component that is going to be traded and whether the component is being bought\n     * or sold. If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return componentQuantity        Amount of component being traded\n     */\n    function getComponentTradeQuantityAndDirection(\n        ISetToken _setToken,\n        IERC20 _component\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool, uint256)\n    {\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not recognized"\n        );\n        uint256 totalSupply = _setToken.totalSupply();\n        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);\n    }\n\n\n    /\n     * Get if a given address is an allowed trader.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _trader           Address of the trader\n     \n     * @return bool             True if _trader is allowed to trade, else false\n     /\n    function getIsAllowedTrader(ISetToken _setToken, address _trader)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool)\n    {\n        return _isAllowedTrader(_setToken, _trader);\n    }\n\n    /\n     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]\n     /\n    function getAllowedTraders(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return permissionInfo[_setToken].tradersHistory;\n    }\n\n    / ============ Internal Functions ============ /\n\n    /\n     * A rebalance is a multi-step process in which current Set components are sold for a\n     * bridge asset (WETH) before buying target components in the correct amount to achieve\n     * the desired balance between elements in the set.\n     \n     *        Step 1        |       Step 2\n     * -------------------------------------------\n     * Component --&gt; WETH   |   WETH --&gt; Component\n     * -------------------------------------------\n     \n     * The syntax we use frames this as trading from a "fixed" amount of one component to a\n     * "fixed" amount of another via a "floating limit" which is either the maximum size of\n     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum\n     * amount of tokens we expect to receive. The different meanings of the floating limit map to\n     * the trade sequence as below:\n     \n     * Step 1: Component --&gt; WETH\n     * ----------------------------------------------------------\n     *                     | Fixed  |     Floating limit        |\n     * ----------------------------------------------------------\n     * send  (Component)   |  YES   |                           |\n     * recieve (WETH)      |        |   Min WETH to receive     |\n     * ----------------------------------------------------------\n     \n     * Step 2: WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     |  Fixed  |    Floating limit        |\n     * ----------------------------------------------------------\n     * send  (WETH)        |   NO    |  Max WETH to send        |\n     * recieve (Component) |   YES   |                          |\n     * ----------------------------------------------------------\n     \n     * Additionally, there is an edge case where price volatility during a rebalance\n     * results in remaining WETH which needs to be allocated proportionately. In this case\n     * the values are as below:\n     \n     * Edge case: Remaining WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     | Fixed  |    Floating limit         |\n     * ----------------------------------------------------------\n     * send  (WETH)        |  YES   |                           |\n     * recieve (Component) |        | Min component to receive  |\n     * ----------------------------------------------------------\n    */\n\n    /\n     * Create and return TradeInfo struct. This function reverts if the target has already been met.\n     * If this is a trade from component into WETH, sell the total fixed component quantity\n     * and expect to receive an ETH amount the user has specified (or more). If it\'s a trade from\n     * WETH into a component, sell the lesser of: the user\'s WETH limit OR the SetToken\'s\n     * remaining WETH balance and expect to receive a fixed component quantity.\n     \n     * @param _setToken             Instance of the SetToken to rebalance\n     * @param _component            IERC20 component to trade\n     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade\n     \n     * @return tradeInfo            Struct containing data for trade\n     /\n    function _createTradeInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        internal\n        view\n        virtual\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);\n\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;\n            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;\n        } else {\n            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);\n            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;\n        }\n    }\n\n    /\n     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param _minComponentReceived         Min amount of component received during trade\n     \n     * @return tradeInfo                    Struct containing data for tradeRemaining info\n     /\n    function _createTradeRemainingInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);\n\n        (,,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);\n\n        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);\n        tradeInfo.floatingQuantityLimit = _minComponentReceived;\n        tradeInfo.isSendTokenFixed = true;\n    }\n\n    /\n     * Create and returns a partial TradeInfo struct with all fields that overlap between trade\n     * and tradeRemaining info constructors filled in. Values for sendQuantity and floatingQuantityLimit\n     * are derived separately, outside this method. trade requires that trade size and direction are\n     * calculated, whereas tradeRemaining automatically sets WETH as the sendToken and _component\n     * as receiveToken.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction\n     \n     * @return tradeInfo                    Struct containing partial data for trade\n     */\n    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo.setToken = _setToken;\n        tradeInfo.setTotalSupply = _setToken.totalSupply();\n        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);\n        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;\n\n        if(calculateTradeDirection){\n            (\n                tradeInfo.isSendTokenFixed,\n                tradeInfo.totalFixedQuantity\n            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);\n        }\n\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendToken = address(_component);\n            tradeInfo.receiveToken = address(weth);\n        } else {\n            tradeInfo.sendToken = address(weth);\n            tradeInfo.receiveToken = address(_component);\n        }\n\n        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));\n        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));\n    }\n\n    /\n     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed\n     * quantity of a token in return for a non-fixed (floating) quantity of a token. If isSendTokenFixed is true then the adapter\n     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for\n     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.\n     \n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     /\n    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {\n        _tradeInfo.setToken.invokeApprove(\n            _tradeInfo.sendToken,\n            _tradeInfo.exchangeAdapter.getSpender(),\n            _tradeInfo.sendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(\n            _tradeInfo.sendToken,\n            _tradeInfo.receiveToken,\n            address(_tradeInfo.setToken),\n            _tradeInfo.isSendTokenFixed,\n            _tradeInfo.sendQuantity,\n            _tradeInfo.floatingQuantityLimit,\n            _tradeInfo.exchangeData\n        );\n\n        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);\n    }\n\n    /\n     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.\n     * The protocol fee is collected from the amount of received token in the trade.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     \n     * @return protocolFee              Amount of receive token taken as protocol fee\n     */\n    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {\n        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)\n            .balanceOf(address(_tradeInfo.setToken))\n            .sub(_tradeInfo.preTradeReceiveTokenBalance);\n\n        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);\n        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);\n    }\n\n    /\n     * Update SetToken positions and executionInfo\'s last trade timestamp. This function is intended\n     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     * @param _component                IERC20 component which was traded\n     \n     * @return netSendAmount            Amount of sendTokens used in the trade\n     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)\n     /\n    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)\n        internal\n        returns (uint256 netSendAmount, uint256 netReceiveAmount)\n    {\n        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.sendToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeSendTokenBalance\n        );\n        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.receiveToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeReceiveTokenBalance\n        );\n\n        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);\n        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);\n\n        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;\n    }\n\n    /\n     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It\'s\n     * necessary to verify that traderHistory contains the address because AddressArrayUtils will\n     * throw when attempting to remove a non-element and it\'s possible someone can set a new\n     * trader\'s status to false.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _trader                           Trader whose permission is being set\n     * @param _status                           Boolean permission being set\n\n     /\n    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {\n        if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.push(_trader);\n        } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);\n        }\n    }\n\n    /\n     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.\n     * If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     * @param _totalSupply              Total supply of _setToken\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return totalFixedQuantity       Amount of fixed token to send or receive\n     /\n    function _calculateTradeSizeAndDirection(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _totalSupply\n    )\n        internal\n        view\n        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)\n    {\n        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);\n        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;\n\n        (\n            uint256 currentUnit,\n            uint256 targetUnit,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);\n\n        require(currentUnit != targetUnit, "Target already met");\n\n        isSendTokenFixed = targetNotional &lt; currentNotional;\n\n        // In order to account for fees taken by protocol when buying the notional difference between currentUnit\n        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to\n        // do so would lead to never being able to meet target of components that need to be bought.\n        //\n        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))\n        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)\n        totalFixedQuantity = isSendTokenFixed\n            ? componentMaxSize.min(currentNotional.sub(targetNotional))\n            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));\n    }\n\n    /\n     * Check if all targets are met.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if all component\'s target units have been met, otherwise false\n     */\n    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }\n        }\n        return true;\n    }\n\n    /\n     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise\n     * needs to be approved.\n     \n     * @param _setToken             Instance of SetToken to be rebalanced\n     * @param  _trader              Address of the trader who called contract function\n     \n     * @return bool                 True if trader is an approved trader for the SetToken\n     /\n    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {\n        TradePermissionInfo storage permissions = permissionInfo[_setToken];\n        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];\n    }\n\n    /\n     * Checks if sell conditions are met. The component cannot be WETH and its normalized target\n     * unit must be less than its default position real unit\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component evaluated for sale\n     \n     * @return bool                             True if sell allowed, false otherwise\n     /\n    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {\n        return (\n            _component != address(weth) &amp;&amp;\n            (\n                _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;\n                _getDefaultPositionRealUnit(_setToken,IERC20(_component))\n            )\n        );\n    }\n\n    /\n     * Check if there are any more tokens to sell. Since we allow WETH to float around it\'s target during rebalances it is not checked.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if there is not any component that can be sold, otherwise false\n     */\n    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }\n        }\n        return true;\n    }\n\n    /\n     * Determines if a target is met. Due to small rounding errors converting between virtual and\n     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to\n     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not\n     * checked as it is allowed to float around its target.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component whose target is evaluated\n     \n     * @return bool                             True if component\'s target units are met, false otherwise\n     /\n    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {\n        if (_component == address(weth)) return false;\n\n        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));\n\n        return (normalizedTargetUnit &gt; 0)\n            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))\n            : normalizedTargetUnit != currentUnit;\n    }\n\n    /\n     * Validate component position unit has not exceeded it\'s target unit. This is used during tradeRemainingWETH() to make sure\n     * the amount of component bought does not exceed the targetUnit.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component whose position units are to be validated\n     /\n    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n        require(currentUnit &lt;= targetUnit, "Can not exceed target unit");\n    }\n\n    /\n     * Validate that component is a valid component and enough time has elapsed since component\'s last trade. Traders\n     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to be validated\n     /\n    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {\n        require(address(_component) != address(weth), "Can not explicitly trade WETH");\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not part of rebalance"\n        );\n\n        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];\n        require(\n            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,\n            "Component cool off in progress"\n        );\n\n        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");\n    }\n\n    /\n     * Extends and/or updates the current component set and its target units with new components and targets,\n     * Validates inputs, requiring that that new components and new target units arrays are the same size, and\n     * that the number of old components target units matches the number of current components. Throws if\n     * a duplicate component has been added.\n     \n     * @param  _currentComponents               Complete set of current SetToken components\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     \n     * @return aggregateComponents              Array of current components extended by new components, without duplicates\n     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates\n     /\n    function _getAggregateComponentsAndUnits(\n        address[] memory _currentComponents,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits\n    )\n        internal\n        pure\n        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)\n    {\n        // Don\'t use validate arrays because empty arrays are valid\n        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");\n        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");\n\n        aggregateComponents = _currentComponents.extend(_newComponents);\n        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);\n\n        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");\n    }\n\n    /\n     * Get the SetToken\'s default position as uint256\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to fetch the default position for\n     \n     * return uint256           Real unit position\n     */\n    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {\n        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();\n    }\n\n    /\n     * Gets exchange adapter address for a component after checking that it exists in the\n     * IntegrationRegistry. This method is called during a trade and must validate the adapter\n     * because its state may have changed since it was set in a separate transaction.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        IERC20 component whose exchange adapter is fetched\n     \n     * @return IExchangeAdapter                 Adapter address\n     /\n    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {\n        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));\n    }\n\n    /\n     * Calculates and returns the normalized target unit value.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     * @param _component            IERC20 component whose normalized target unit is required\n     \n     * @return uint256                          Normalized target unit of the component\n     /\n    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {\n        // (targetUnit * current position multiplier) / position multiplier when rebalance started\n        return executionInfo[_setToken][_component]\n            .targetUnit\n            .mul(_setToken.positionMultiplier().toUint256())\n            .div(rebalanceInfo[_setToken].positionMultiplier);\n    }\n\n    /\n     * Gets unit and notional amount values for current position and target. These are necessary\n     * to calculate the trade size and direction for regular trades and the sendQuantity for\n     * remainingWEth trades.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to calculate notional amounts for\n     * @param _totalSupply              SetToken total supply\n     \n     * @return uint256              Current default position real unit of component\n     * @return uint256              Normalized unit of the trade target\n     * @return uint256              Current notional amount: total notional amount of SetToken default position\n     * @return uint256              Target notional amount: Total SetToken supply * targetUnit\n     /\n    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)\n        internal\n        view\n        returns (uint256, uint256, uint256, uint256)\n    {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n\n        return (\n            currentUnit,\n            targetUnit,\n            _totalSupply.getDefaultTotalNotional(currentUnit),\n            _totalSupply.preciseMulCeil(targetUnit)\n        );\n    }\n\n    / ============== Modifier Helpers ===============\n     * Internal functions used to reduce bytecode size\n     /\n\n    /\n     * Trader must be permissioned for SetToken\n     /\n    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {\n        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");\n    }\n\n    /\n     * Trade must be an EOA if anyoneTrade has been enabled for SetToken on the module.\n     */\n    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {\n        if(permissionInfo[_setToken].anyoneTrade) {\n            require(msg.sender == tx.origin, "Caller must be EOA Address");\n        }\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 01:47:20 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 01:47:20 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 01:47:23 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 01:47:23 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 23170
completion_tokens: 1
total_tokens: 23171
cost: $-1.000000


[2024-01-09 01:47:23 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

###

[2024-01-09 01:47:23 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 01:47:23 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 01:47:23 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 01:47:23 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 01:47:23 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 01:47:34 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 01:47:34 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 11644
completion_tokens: 836
total_tokens: 12480
cost: $-1.000000


[2024-01-09 01:47:34 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Based on the provided smart contract code for the `GeneralIndexModule`, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, it is essential to ensure that all external calls (especially in `_executeTrade`) are carefully managed to prevent reentrancy attacks. The use of external calls can still pose a risk if not handled correctly.

2. **Access Control Issues**:
   - The contract relies on modifiers like `onlyManagerAndValidSet`, `onlyAllowedTrader`, and `onlyEOAIfUnrestricted` to control access. However, if these modifiers are not implemented correctly or if the manager's address is compromised, unauthorized access could occur.

3. **Integer Overflow/Underflow**:
   - While the contract uses `SafeMath`, it is crucial to ensure that all arithmetic operations are consistently wrapped with `SafeMath` functions to prevent any potential overflow or underflow issues.

4. **Improper Input Validation**:
   - Functions like `startRebalance`, `trade`, and others rely on input parameters that must be validated. If the input arrays (e.g., `_newComponents`, `_newComponentsTargetUnits`) are not properly validated for length and content, it could lead to unexpected behavior or state corruption.

5. **Gas Limit and Block Size Issues**:
   - The contract performs operations that could potentially exceed the gas limit, especially in loops (e.g., iterating through components). This could lead to transaction failures if the gas limit is exceeded.

6. **Protocol Fee Calculation**:
   - The protocol fee is calculated based on the exchanged quantity. If the fee structure changes or if there is a bug in the fee calculation logic, it could lead to incorrect fee deductions.

7. **Lack of Event Emission for Critical State Changes**:
   - While there are events emitted for various state changes, it is essential to ensure that all critical state changes, especially those affecting permissions and trading status, are logged to provide an audit trail.

8. **Potential for Front-Running Attacks**:
   - The trading mechanism could be susceptible to front-running attacks, where malicious actors could observe pending transactions and execute their trades first, potentially leading to loss of funds for users.

### Comprehensive Analysis Report:

The `GeneralIndexModule` contract is designed to facilitate rebalances for indices, allowing managers to update allocations and traders to execute trades. While the contract employs several best practices, including the use of `SafeMath` and `ReentrancyGuard`, there are notable security vulnerabilities that need to be addressed to ensure the integrity and security of the contract.

1. **Reentrancy Protection**: Although the contract uses `ReentrancyGuard`, it is vital to ensure that all external calls are safe. It is recommended to adopt the Checks-Effects-Interactions pattern to minimize reentrancy risks.

2. **Access Control**: The reliance on manager and trader permissions necessitates a thorough review of the access control mechanisms. Any compromise of the manager's address could lead to unauthorized actions, so implementing a multi-signature wallet for critical functions could enhance security.

3. **Input Validation**: Robust input validation is crucial to prevent unexpected behavior. All functions that accept external inputs should validate the length and content of arrays and parameters to avoid state corruption.

4. **Gas Optimization**: The contract should be optimized to avoid excessive gas consumption, especially in loops. Consider breaking down large operations into smaller, manageable transactions.

5. **Event Logging**: Ensure that all critical state changes are logged with events to provide transparency and an audit trail for actions taken within the contract.

6. **Front-Running Mitigation**: Implement mechanisms to mitigate front-running risks, such as using commit-reveal schemes or time-locks for trades.

In conclusion, while the `GeneralIndexModule` contract has a solid foundation, addressing the identified vulnerabilities is essential to enhance its security posture. A thorough audit and testing phase should be conducted before deployment to ensure that all potential risks are mitigated.

[2024-01-09 01:47:34 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `GeneralIndexModule`, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, it is essential to ensure that all external calls (especially in `_executeTrade`) are carefully managed to prevent reentrancy attacks. The use of external calls can still pose a risk if not handled correctly.

2. **Access Control Issues**:
   - The contract relies on modifiers like `onlyManagerAndValidSet`, `onlyAllowedTrader`, and `onlyEOAIfUnrestricted` to control access. However, if these modifiers are not implemented correctly or if the manager's address is compromised, unauthorized access could occur.

3. **Integer Overflow/Underflow**:
   - While the contract uses `SafeMath`, it is crucial to ensure that all arithmetic operations are consistently wrapped with `SafeMath` functions to prevent any potential overflow or underflow issues.

4. **Improper Input Validation**:
   - Functions like `startRebalance`, `trade`, and others rely on input parameters that must be validated. If the input arrays (e.g., `_newComponents`, `_newComponentsTargetUnits`) are not properly validated for length and content, it could lead to unexpected behavior or state corruption.

5. **Gas Limit and Block Size Issues**:
   - The contract performs operations that could potentially exceed the gas limit, especially in loops (e.g., iterating through components). This could lead to transaction failures if the gas limit is exceeded.

6. **Protocol Fee Calculation**:
   - The protocol fee is calculated based on the exchanged quantity. If the fee structure changes or if there is a bug in the fee calculation logic, it could lead to incorrect fee deductions.

7. **Lack of Event Emission for Critical State Changes**:
   - While there are events emitted for various state changes, it is essential to ensure that all critical state changes, especially those affecting permissions and trading status, are logged to provide an audit trail.

8. **Potential for Front-Running Attacks**:
   - The trading mechanism could be susceptible to front-running attacks, where malicious actors could observe pending transactions and execute their trades first, potentially leading to loss of funds for users.

### Comprehensive Analysis Report:

The `GeneralIndexModule` contract is designed to facilitate rebalances for indices, allowing managers to update allocations and traders to execute trades. While the contract employs several best practices, including the use of `SafeMath` and `ReentrancyGuard`, there are notable security vulnerabilities that need to be addressed to ensure the integrity and security of the contract.

1. **Reentrancy Protection**: Although the contract uses `ReentrancyGuard`, it is vital to ensure that all external calls are safe. It is recommended to adopt the Checks-Effects-Interactions pattern to minimize reentrancy risks.

2. **Access Control**: The reliance on manager and trader permissions necessitates a thorough review of the access control mechanisms. Any compromise of the manager's address could lead to unauthorized actions, so implementing a multi-signature wallet for critical functions could enhance security.

3. **Input Validation**: Robust input validation is crucial to prevent unexpected behavior. All functions that accept external inputs should validate the length and content of arrays and parameters to avoid state corruption.

4. **Gas Optimization**: The contract should be optimized to avoid excessive gas consumption, especially in loops. Consider breaking down large operations into smaller, manageable transactions.

5. **Event Logging**: Ensure that all critical state changes are logged with events to provide transparency and an audit trail for actions taken within the contract.

6. **Front-Running Mitigation**: Implement mechanisms to mitigate front-running risks, such as using commit-reveal schemes or time-locks for trades.

In conclusion, while the `GeneralIndexModule` contract has a solid foundation, addressing the identified vulnerabilities is essential to enhance its security posture. A thorough audit and testing phase should be conducted before deployment to ensure that all potential risks are mitigated.

[2024-01-09 01:47:37 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Math } from "@openzeppelin/contracts/math/Math.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";\nimport { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\n\nimport { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";\nimport { Invoke } from "../../lib/Invoke.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IWETH } from "../../../interfaces/external/IWETH.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\nimport { Position } from "../../lib/Position.sol";\nimport { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";\nimport { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";\n\n\n/\n * @title GeneralIndexModule\n * @author Set Protocol\n \n * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().\n * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over\n * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed\n * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.\n * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-\n * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance\n * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component\'s\n * target allocation is met any further attempted trades of that component will revert.\n \n * SECURITY ASSUMPTION:\n *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using\n *    this module need to be examined separately)\n /\ncontract GeneralIndexModule is ModuleBase, ReentrancyGuard {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using Position for uint256;\n    using Math for uint256;\n    using Position for ISetToken;\n    using Invoke for ISetToken;\n    using AddressArrayUtils for address[];\n    using AddressArrayUtils for IERC20[];\n    using Uint256ArrayUtils for uint256[];\n\n    / ============ Struct ============ /\n\n    struct TradeExecutionParams {\n        uint256 targetUnit;              // Target unit of component for Set\n        uint256 maxSize;                 // Max trade size in precise units\n        uint256 coolOffPeriod;           // Required time between trades for the asset\n        uint256 lastTradeTimestamp;      // Timestamp of last trade\n        string exchangeName;             // Name of exchange adapter\n        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)\n    }\n\n    struct TradePermissionInfo {\n        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade\n        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal\n        mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade\n    }\n\n    struct RebalanceInfo {\n        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance\n        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)\n        address[] rebalanceComponents;      // Array of components involved in rebalance\n    }\n\n    struct TradeInfo {\n        ISetToken setToken;                         // Instance of SetToken\n        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter\n        address sendToken;                          // Address of token being sold\n        address receiveToken;                       // Address of token being bought\n        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token\n        uint256 setTotalSupply;                     // Total supply of Set (in precise units)\n        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded\n        uint256 sendQuantity;                       // Units of component sent to the exchange\n        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade\n        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold\n        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought\n        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange\n    }\n\n    / ============ Events ============ /\n\n    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);\n    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);\n    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);\n    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);\n    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);\n    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);\n\n    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);\n    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);\n\n    event TradeExecuted(\n        ISetToken indexed _setToken,\n        address indexed _sellComponent,\n        address indexed _buyComponent,\n        IIndexExchangeAdapter _exchangeAdapter,\n        address _executor,\n        uint256 _netAmountSold,\n        uint256 _netAmountReceived,\n        uint256 _protocolFee\n    );\n\n    event RebalanceStarted(\n        ISetToken indexed _setToken,\n        address[] aggregateComponents,\n        uint256[] aggregateTargetUnits,\n        uint256 indexed positionMultiplier\n    );\n\n    / ============ Constants ============ /\n\n    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller\n\n    / ============ State Variables ============ /\n\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken\n    mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions\n    mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance\n    IWETH public immutable weth;                                                            // Weth contract address\n\n    / ============ Modifiers ============ /\n\n    modifier onlyAllowedTrader(ISetToken setToken) {\n        _validateOnlyAllowedTrader(_setToken);\n        ;\n    }\n\n    modifier onlyEOAIfUnrestricted(ISetToken setToken) {\n        _validateOnlyEOAIfUnrestricted(_setToken);\n        ;\n    }\n\n    / ============ Constructor ============ /\n\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n\n    / ============ External Functions ============ */\n\n    /\n     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager\n     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 1018\n     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the\n     * SetToken. If a component is being removed it\'s index in the _oldComponentsTargetUnits should be set to 0. Additionally, the\n     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs\n     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.\n     \n     * @param _setToken                         Address of the SetToken to be rebalanced\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units\n     *                                               if fees accrued\n     /\n    function startRebalance(\n        ISetToken _setToken,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits,\n        uint256 _positionMultiplier\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(\n            _setToken.getComponents(),\n            _newComponents,\n            _newComponentsTargetUnits,\n            _oldComponentsTargetUnits\n        );\n\n        for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {\n            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");\n            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];\n        }\n\n        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;\n        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;\n\n        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);\n    }\n\n    /\n     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().\n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.\n     \n     * Trade can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Trader can pass\n     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.\n     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default\n     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,\n     * if enabled, are collected in the token received in a trade.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _component            Address of SetToken component to trade\n     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade\n     /\n    function trade(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        _validateTradeParameters(_setToken, _component);\n\n        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);\n\n        _executeTrade(tradeInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n\n    /\n     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be\n     * traded such that resulting inflows won\'t exceed component\'s maxTradeSize nor overshoot the target unit. To be used near the end of rebalances\n     * when a component\'s calculated trade size is greater in value than remaining WETH.\n     \n     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade\n     * can be called at anytime but will revert if the passed component\'s target unit is met or cool off period hasn\'t passed. Like with trade()\n     * a minimum component receive amount can be set.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _component                    Address of the SetToken component to trade\n     * @param _minComponentReceived        Min amount of component received during trade\n     /\n    function tradeRemainingWETH(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        external\n        nonReentrant\n        onlyAllowedTrader(_setToken)\n        onlyEOAIfUnrestricted(_setToken)\n        virtual\n    {\n        require(_noTokensToSell(_setToken), "Sell other set components first");\n        require(\n            executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),\n            "WETH is below target unit"\n        );\n\n        _validateTradeParameters(_setToken, _component);\n\n        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);\n\n        _executeTrade(tradeInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(tradeInfo);\n        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);\n\n        require(\n            netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,\n            "Trade amount &gt; max trade size"\n        );\n\n        _validateComponentPositionUnit(_setToken, _component);\n\n        emit TradeExecuted(\n            tradeInfo.setToken,\n            tradeInfo.sendToken,\n            tradeInfo.receiveToken,\n            tradeInfo.exchangeAdapter,\n            msg.sender,\n            netSendAmount,\n            netReceiveAmount,\n            protocolFee\n        );\n    }\n\n    /\n     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying\n     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,\n     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error\n     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components\n     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is\n     * spent buying the components to meet their new target.\n     \n     * @param _setToken             Address of the SetToken\n     /\n    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {\n        require(\n            _allTargetsMet(_setToken)\n            &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),\n            "Targets not met or ETH =~ 0"\n        );\n\n        // positionMultiplier / (10^18 + raiseTargetPercentage)\n        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087\n        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(\n            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)\n        );\n        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);\n    }\n\n    /\n     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.\n     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by\n     * default and trades will not execute if a component\'s trade size is greater than the maximum.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _tradeMaximums        Array of trade maximums mapping to correct component\n     /\n    function setTradeMaximums(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _tradeMaximums\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_tradeMaximums);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];\n            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeNames        Array of exchange names mapping to correct component\n     /\n    function setExchanges(\n        ISetToken _setToken,\n        address[] memory _components,\n        string[] memory _exchangeNames\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeNames);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            if (_components[i] != address(weth)) {\n\n                require(\n                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),\n                    "Unrecognized exchange name"\n                );\n\n                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];\n                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);\n            }\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _coolOffPeriods       Array of cool off periods to correct component\n     /\n    function setCoolOffPeriods(\n        ISetToken _setToken,\n        address[] memory _components,\n        uint256[] memory _coolOffPeriods\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_coolOffPeriods);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];\n            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying\n     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.\n     \n     * @param _setToken             Address of the SetToken\n     * @param _components           Array of components\n     * @param _exchangeData         Array of exchange specific arbitrary bytes data\n     /\n    function setExchangeData(\n        ISetToken _setToken,\n        address[] memory _components,\n        bytes[] memory _exchangeData\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _components.validatePairsWithArray(_exchangeData);\n\n        for (uint256 i = 0; i &lt; _components.length; i++) {\n            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];\n            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Set amount by which all component\'s targets units would be raised. Can be called at any time.\n     \n     * @param _setToken                     Address of the SetToken\n     * @param _raiseTargetPercentage        Amount to raise all component\'s unit targets by (in precise units)\n     /\n    function setRaiseTargetPercentage(\n        ISetToken _setToken,\n        uint256 _raiseTargetPercentage\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");\n        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;\n        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);\n    }\n\n    /\n     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.\n     \n     * @param _setToken          Address of the SetToken\n     * @param _traders           Array trader addresses to toggle status\n     * @param _statuses          Booleans indicating if matching trader can trade\n     /\n    function setTraderStatus(\n        ISetToken _setToken,\n        address[] memory _traders,\n        bool[] memory _statuses\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        _traders.validatePairsWithArray(_statuses);\n\n        for (uint256 i = 0; i &lt; _traders.length; i++) {\n            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);\n            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];\n            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);\n        }\n    }\n\n    /\n     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _status           Boolean indicating if anyone can trade\n     /\n    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {\n        permissionInfo[_setToken].anyoneTrade = _status;\n        emit AnyoneTradeUpdated(_setToken, _status);\n    }\n\n    /\n     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.\n     * Grabs the current units for each asset in the Set and set\'s the targetUnit to that unit in order to prevent any\n     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any\n     * position multiplier changes don\'t unintentionally open the Set for rebalancing.\n     \n     * @param _setToken         Address of the Set Token\n     /\n    function initialize(ISetToken _setToken)\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n\n        for (uint256 i = 0; i &lt; positions.length; i++) {\n            ISetToken.Position memory position = positions[i];\n            require(position.positionState == 0, "External positions not allowed");\n            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();\n            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;\n        }\n\n        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();\n        _setToken.initializeModule();\n    }\n\n    /\n     * Called by a SetToken to notify that this module was removed from the SetToken.\n     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.\n     * IMPORTANT: SetToken\'s execution settings, including trade maximums and exchange names,\n     * are NOT DELETED. Restoring a previously removed module requires that care is taken to\n     * initialize execution settings appropriately.\n     /\n    function removeModule() external override {\n        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];\n\n        for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {\n            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;\n        }\n\n        delete rebalanceInfo[ISetToken(msg.sender)];\n        delete permissionInfo[ISetToken(msg.sender)];\n    }\n\n    / ============ External View Functions ============ /\n\n    /\n     * Get the array of SetToken components involved in rebalance.\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]        Array of _setToken components involved in rebalance\n     /\n    function getRebalanceComponents(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return rebalanceInfo[_setToken].rebalanceComponents;\n    }\n\n    /\n     * Calculates the amount of a component that is going to be traded and whether the component is being bought\n     * or sold. If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return componentQuantity        Amount of component being traded\n     */\n    function getComponentTradeQuantityAndDirection(\n        ISetToken _setToken,\n        IERC20 _component\n    )\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool, uint256)\n    {\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not recognized"\n        );\n        uint256 totalSupply = _setToken.totalSupply();\n        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);\n    }\n\n\n    /\n     * Get if a given address is an allowed trader.\n     \n     * @param _setToken         Address of the SetToken\n     * @param _trader           Address of the trader\n     \n     * @return bool             True if _trader is allowed to trade, else false\n     /\n    function getIsAllowedTrader(ISetToken _setToken, address _trader)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (bool)\n    {\n        return _isAllowedTrader(_setToken, _trader);\n    }\n\n    /\n     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()\n     \n     * @param _setToken         Address of the SetToken\n     \n     * @return address[]\n     /\n    function getAllowedTraders(ISetToken _setToken)\n        external\n        view\n        onlyValidAndInitializedSet(_setToken)\n        returns (address[] memory)\n    {\n        return permissionInfo[_setToken].tradersHistory;\n    }\n\n    / ============ Internal Functions ============ /\n\n    /\n     * A rebalance is a multi-step process in which current Set components are sold for a\n     * bridge asset (WETH) before buying target components in the correct amount to achieve\n     * the desired balance between elements in the set.\n     \n     *        Step 1        |       Step 2\n     * -------------------------------------------\n     * Component --&gt; WETH   |   WETH --&gt; Component\n     * -------------------------------------------\n     \n     * The syntax we use frames this as trading from a "fixed" amount of one component to a\n     * "fixed" amount of another via a "floating limit" which is either the maximum size of\n     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum\n     * amount of tokens we expect to receive. The different meanings of the floating limit map to\n     * the trade sequence as below:\n     \n     * Step 1: Component --&gt; WETH\n     * ----------------------------------------------------------\n     *                     | Fixed  |     Floating limit        |\n     * ----------------------------------------------------------\n     * send  (Component)   |  YES   |                           |\n     * recieve (WETH)      |        |   Min WETH to receive     |\n     * ----------------------------------------------------------\n     \n     * Step 2: WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     |  Fixed  |    Floating limit        |\n     * ----------------------------------------------------------\n     * send  (WETH)        |   NO    |  Max WETH to send        |\n     * recieve (Component) |   YES   |                          |\n     * ----------------------------------------------------------\n     \n     * Additionally, there is an edge case where price volatility during a rebalance\n     * results in remaining WETH which needs to be allocated proportionately. In this case\n     * the values are as below:\n     \n     * Edge case: Remaining WETH --&gt; Component\n     * ----------------------------------------------------------\n     *                     | Fixed  |    Floating limit         |\n     * ----------------------------------------------------------\n     * send  (WETH)        |  YES   |                           |\n     * recieve (Component) |        | Min component to receive  |\n     * ----------------------------------------------------------\n    */\n\n    /\n     * Create and return TradeInfo struct. This function reverts if the target has already been met.\n     * If this is a trade from component into WETH, sell the total fixed component quantity\n     * and expect to receive an ETH amount the user has specified (or more). If it\'s a trade from\n     * WETH into a component, sell the lesser of: the user\'s WETH limit OR the SetToken\'s\n     * remaining WETH balance and expect to receive a fixed component quantity.\n     \n     * @param _setToken             Instance of the SetToken to rebalance\n     * @param _component            IERC20 component to trade\n     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade\n     \n     * @return tradeInfo            Struct containing data for trade\n     /\n    function _createTradeInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _ethQuantityLimit\n    )\n        internal\n        view\n        virtual\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);\n\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;\n            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;\n        } else {\n            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);\n            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;\n        }\n    }\n\n    /\n     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param _minComponentReceived         Min amount of component received during trade\n     \n     * @return tradeInfo                    Struct containing data for tradeRemaining info\n     /\n    function _createTradeRemainingInfo(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _minComponentReceived\n    )\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);\n\n        (,,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);\n\n        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);\n        tradeInfo.floatingQuantityLimit = _minComponentReceived;\n        tradeInfo.isSendTokenFixed = true;\n    }\n\n    /\n     * Create and returns a partial TradeInfo struct with all fields that overlap between trade\n     * and tradeRemaining info constructors filled in. Values for sendQuantity and floatingQuantityLimit\n     * are derived separately, outside this method. trade requires that trade size and direction are\n     * calculated, whereas tradeRemaining automatically sets WETH as the sendToken and _component\n     * as receiveToken.\n     \n     * @param _setToken                     Instance of the SetToken to rebalance\n     * @param _component                    IERC20 component to trade\n     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction\n     \n     * @return tradeInfo                    Struct containing partial data for trade\n     */\n    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)\n        internal\n        view\n        returns (TradeInfo memory tradeInfo)\n    {\n        tradeInfo.setToken = _setToken;\n        tradeInfo.setTotalSupply = _setToken.totalSupply();\n        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);\n        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;\n\n        if(calculateTradeDirection){\n            (\n                tradeInfo.isSendTokenFixed,\n                tradeInfo.totalFixedQuantity\n            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);\n        }\n\n        if (tradeInfo.isSendTokenFixed){\n            tradeInfo.sendToken = address(_component);\n            tradeInfo.receiveToken = address(weth);\n        } else {\n            tradeInfo.sendToken = address(weth);\n            tradeInfo.receiveToken = address(_component);\n        }\n\n        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));\n        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));\n    }\n\n    /\n     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed\n     * quantity of a token in return for a non-fixed (floating) quantity of a token. If isSendTokenFixed is true then the adapter\n     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for\n     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.\n     \n     * @param _tradeInfo            Struct containing trade information used in internal functions\n     /\n    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {\n        _tradeInfo.setToken.invokeApprove(\n            _tradeInfo.sendToken,\n            _tradeInfo.exchangeAdapter.getSpender(),\n            _tradeInfo.sendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(\n            _tradeInfo.sendToken,\n            _tradeInfo.receiveToken,\n            address(_tradeInfo.setToken),\n            _tradeInfo.isSendTokenFixed,\n            _tradeInfo.sendQuantity,\n            _tradeInfo.floatingQuantityLimit,\n            _tradeInfo.exchangeData\n        );\n\n        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);\n    }\n\n    /\n     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.\n     * The protocol fee is collected from the amount of received token in the trade.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     \n     * @return protocolFee              Amount of receive token taken as protocol fee\n     */\n    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {\n        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)\n            .balanceOf(address(_tradeInfo.setToken))\n            .sub(_tradeInfo.preTradeReceiveTokenBalance);\n\n        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);\n        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);\n    }\n\n    /\n     * Update SetToken positions and executionInfo\'s last trade timestamp. This function is intended\n     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.\n     \n     * @param _tradeInfo                Struct containing trade information used in internal functions\n     * @param _component                IERC20 component which was traded\n     \n     * @return netSendAmount            Amount of sendTokens used in the trade\n     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)\n     /\n    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)\n        internal\n        returns (uint256 netSendAmount, uint256 netReceiveAmount)\n    {\n        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.sendToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeSendTokenBalance\n        );\n        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(\n            _tradeInfo.receiveToken,\n            _tradeInfo.setTotalSupply,\n            _tradeInfo.preTradeReceiveTokenBalance\n        );\n\n        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);\n        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);\n\n        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;\n    }\n\n    /\n     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It\'s\n     * necessary to verify that traderHistory contains the address because AddressArrayUtils will\n     * throw when attempting to remove a non-element and it\'s possible someone can set a new\n     * trader\'s status to false.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _trader                           Trader whose permission is being set\n     * @param _status                           Boolean permission being set\n\n     /\n    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {\n        if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.push(_trader);\n        } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {\n            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);\n        }\n    }\n\n    /\n     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.\n     * If currentUnit and targetUnit are the same, function will revert.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to trade\n     * @param _totalSupply              Total supply of _setToken\n     \n     * @return isSendTokenFixed         Boolean indicating fixed asset is send token\n     * @return totalFixedQuantity       Amount of fixed token to send or receive\n     /\n    function _calculateTradeSizeAndDirection(\n        ISetToken _setToken,\n        IERC20 _component,\n        uint256 _totalSupply\n    )\n        internal\n        view\n        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)\n    {\n        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);\n        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;\n\n        (\n            uint256 currentUnit,\n            uint256 targetUnit,\n            uint256 currentNotional,\n            uint256 targetNotional\n        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);\n\n        require(currentUnit != targetUnit, "Target already met");\n\n        isSendTokenFixed = targetNotional &lt; currentNotional;\n\n        // In order to account for fees taken by protocol when buying the notional difference between currentUnit\n        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to\n        // do so would lead to never being able to meet target of components that need to be bought.\n        //\n        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))\n        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)\n        totalFixedQuantity = isSendTokenFixed\n            ? componentMaxSize.min(currentNotional.sub(targetNotional))\n            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));\n    }\n\n    /\n     * Check if all targets are met.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if all component\'s target units have been met, otherwise false\n     */\n    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }\n        }\n        return true;\n    }\n\n    /\n     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise\n     * needs to be approved.\n     \n     * @param _setToken             Instance of SetToken to be rebalanced\n     * @param  _trader              Address of the trader who called contract function\n     \n     * @return bool                 True if trader is an approved trader for the SetToken\n     /\n    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {\n        TradePermissionInfo storage permissions = permissionInfo[_setToken];\n        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];\n    }\n\n    /\n     * Checks if sell conditions are met. The component cannot be WETH and its normalized target\n     * unit must be less than its default position real unit\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component evaluated for sale\n     \n     * @return bool                             True if sell allowed, false otherwise\n     /\n    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {\n        return (\n            _component != address(weth) &amp;&amp;\n            (\n                _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;\n                _getDefaultPositionRealUnit(_setToken,IERC20(_component))\n            )\n        );\n    }\n\n    /\n     * Check if there are any more tokens to sell. Since we allow WETH to float around it\'s target during rebalances it is not checked.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     \n     * @return bool                 True if there is not any component that can be sold, otherwise false\n     */\n    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {\n        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;\n\n        for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {\n            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }\n        }\n        return true;\n    }\n\n    /\n     * Determines if a target is met. Due to small rounding errors converting between virtual and\n     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to\n     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not\n     * checked as it is allowed to float around its target.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        Component whose target is evaluated\n     \n     * @return bool                             True if component\'s target units are met, false otherwise\n     /\n    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {\n        if (_component == address(weth)) return false;\n\n        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));\n\n        return (normalizedTargetUnit &gt; 0)\n            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))\n            : normalizedTargetUnit != currentUnit;\n    }\n\n    /\n     * Validate component position unit has not exceeded it\'s target unit. This is used during tradeRemainingWETH() to make sure\n     * the amount of component bought does not exceed the targetUnit.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component whose position units are to be validated\n     /\n    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n        require(currentUnit &lt;= targetUnit, "Can not exceed target unit");\n    }\n\n    /\n     * Validate that component is a valid component and enough time has elapsed since component\'s last trade. Traders\n     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to be validated\n     /\n    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {\n        require(address(_component) != address(weth), "Can not explicitly trade WETH");\n        require(\n            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),\n            "Component not part of rebalance"\n        );\n\n        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];\n        require(\n            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,\n            "Component cool off in progress"\n        );\n\n        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");\n    }\n\n    /\n     * Extends and/or updates the current component set and its target units with new components and targets,\n     * Validates inputs, requiring that that new components and new target units arrays are the same size, and\n     * that the number of old components target units matches the number of current components. Throws if\n     * a duplicate component has been added.\n     \n     * @param  _currentComponents               Complete set of current SetToken components\n     * @param _newComponents                    Array of new components to add to allocation\n     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array\n     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of\n     *                                               _setToken.getComponents() array, if component being removed set to 0.\n     \n     * @return aggregateComponents              Array of current components extended by new components, without duplicates\n     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates\n     /\n    function _getAggregateComponentsAndUnits(\n        address[] memory _currentComponents,\n        address[] calldata _newComponents,\n        uint256[] calldata _newComponentsTargetUnits,\n        uint256[] calldata _oldComponentsTargetUnits\n    )\n        internal\n        pure\n        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)\n    {\n        // Don\'t use validate arrays because empty arrays are valid\n        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");\n        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");\n\n        aggregateComponents = _currentComponents.extend(_newComponents);\n        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);\n\n        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");\n    }\n\n    /\n     * Get the SetToken\'s default position as uint256\n     \n     * @param _setToken         Instance of the SetToken\n     * @param _component        IERC20 component to fetch the default position for\n     \n     * return uint256           Real unit position\n     */\n    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {\n        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();\n    }\n\n    /\n     * Gets exchange adapter address for a component after checking that it exists in the\n     * IntegrationRegistry. This method is called during a trade and must validate the adapter\n     * because its state may have changed since it was set in a separate transaction.\n     \n     * @param _setToken                         Instance of the SetToken to be rebalanced\n     * @param _component                        IERC20 component whose exchange adapter is fetched\n     \n     * @return IExchangeAdapter                 Adapter address\n     /\n    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {\n        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));\n    }\n\n    /\n     * Calculates and returns the normalized target unit value.\n     \n     * @param _setToken             Instance of the SetToken to be rebalanced\n     * @param _component            IERC20 component whose normalized target unit is required\n     \n     * @return uint256                          Normalized target unit of the component\n     /\n    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {\n        // (targetUnit * current position multiplier) / position multiplier when rebalance started\n        return executionInfo[_setToken][_component]\n            .targetUnit\n            .mul(_setToken.positionMultiplier().toUint256())\n            .div(rebalanceInfo[_setToken].positionMultiplier);\n    }\n\n    /\n     * Gets unit and notional amount values for current position and target. These are necessary\n     * to calculate the trade size and direction for regular trades and the sendQuantity for\n     * remainingWEth trades.\n     \n     * @param _setToken                 Instance of the SetToken to rebalance\n     * @param _component                IERC20 component to calculate notional amounts for\n     * @param _totalSupply              SetToken total supply\n     \n     * @return uint256              Current default position real unit of component\n     * @return uint256              Normalized unit of the trade target\n     * @return uint256              Current notional amount: total notional amount of SetToken default position\n     * @return uint256              Target notional amount: Total SetToken supply * targetUnit\n     /\n    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)\n        internal\n        view\n        returns (uint256, uint256, uint256, uint256)\n    {\n        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);\n        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);\n\n        return (\n            currentUnit,\n            targetUnit,\n            _totalSupply.getDefaultTotalNotional(currentUnit),\n            _totalSupply.preciseMulCeil(targetUnit)\n        );\n    }\n\n    / ============== Modifier Helpers ===============\n     * Internal functions used to reduce bytecode size\n     /\n\n    /\n     * Trader must be permissioned for SetToken\n     /\n    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {\n        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");\n    }\n\n    /\n     * Trade must be an EOA if anyoneTrade has been enabled for SetToken on the module.\n     */\n    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {\n        if(permissionInfo[_setToken].anyoneTrade) {\n            require(msg.sender == tx.origin, "Caller must be EOA Address");\n        }\n    }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 01:47:37 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Math } from "@openzeppelin/contracts/math/Math.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol"; import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol"; import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol"; import { Invoke } from "../../lib/Invoke.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IWETH } from "../../../interfaces/external/IWETH.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; import { Position } from "../../lib/Position.sol"; import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol"; import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol"; /*  * @title GeneralIndexModule  * @author Set Protocol  *  * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().  * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over  * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed  * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.  * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-  * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance  * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's  * target allocation is met any further attempted trades of that component will revert.  *  * SECURITY ASSUMPTION:  *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using  *    this module need to be examined separately)  / contract GeneralIndexModule is ModuleBase, ReentrancyGuard {     using SafeCast for int256;     using SafeCast for uint256;     using SafeMath for uint256;     using Position for uint256;     using Math for uint256;     using Position for ISetToken;     using Invoke for ISetToken;     using AddressArrayUtils for address[];     using AddressArrayUtils for IERC20[];     using Uint256ArrayUtils for uint256[]; /* ============ Struct ============ */  struct TradeExecutionParams {     uint256 targetUnit;              // Target unit of component for Set     uint256 maxSize;                 // Max trade size in precise units     uint256 coolOffPeriod;           // Required time between trades for the asset     uint256 lastTradeTimestamp;      // Timestamp of last trade     string exchangeName;             // Name of exchange adapter     bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop) }  struct TradePermissionInfo {     bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade     address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal     mapping(address =&gt; bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade }  struct RebalanceInfo {     uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance     uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)     address[] rebalanceComponents;      // Array of components involved in rebalance }  struct TradeInfo {     ISetToken setToken;                         // Instance of SetToken     IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter     address sendToken;                          // Address of token being sold     address receiveToken;                       // Address of token being bought     bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token     uint256 setTotalSupply;                     // Total supply of Set (in precise units)     uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded     uint256 sendQuantity;                       // Units of component sent to the exchange     uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade     uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold     uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought     bytes exchangeData;                         // Arbitrary data for executing trade on given exchange }  /* ============ Events ============ */  event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum); event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName); event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod); event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData); event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage); event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);  event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status); event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);  event TradeExecuted(     ISetToken indexed _setToken,     address indexed _sellComponent,     address indexed _buyComponent,     IIndexExchangeAdapter _exchangeAdapter,     address _executor,     uint256 _netAmountSold,     uint256 _netAmountReceived,     uint256 _protocolFee );  event RebalanceStarted(     ISetToken indexed _setToken,     address[] aggregateComponents,     uint256[] aggregateTargetUnits,     uint256 indexed positionMultiplier );  /* ============ Constants ============ */  uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller  /* ============ State Variables ============ */  mapping(ISetToken =&gt; mapping(IERC20 =&gt; TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken mapping(ISetToken =&gt; TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions mapping(ISetToken =&gt; RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance IWETH public immutable weth;                                                            // Weth contract address  /* ============ Modifiers ============ */  modifier onlyAllowedTrader(ISetToken _setToken) {     _validateOnlyAllowedTrader(_setToken);     _; }  modifier onlyEOAIfUnrestricted(ISetToken _setToken) {     _validateOnlyEOAIfUnrestricted(_setToken);     _; }  /* ============ Constructor ============ */  constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {     weth = _weth; }  /* ============ External Functions ============ */  /**  * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager  * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18  * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the  * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the  * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs  * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.  *  * @param _setToken                         Address of the SetToken to be rebalanced  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units  *                                               if fees accrued  */ function startRebalance(     ISetToken _setToken,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits,     uint256 _positionMultiplier )     external     onlyManagerAndValidSet(_setToken) {     ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(         _setToken.getComponents(),         _newComponents,         _newComponentsTargetUnits,         _oldComponentsTargetUnits     );      for (uint256 i = 0; i &lt; aggregateComponents.length; i++) {         require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");         executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];     }      rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;     rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;      emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier); }  /**  * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.  *  * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass  * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.  * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default  * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,  * if enabled, are collected in the token received in a trade.  *  * @param _setToken             Address of the SetToken  * @param _component            Address of SetToken component to trade  * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade  */ function trade(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);      (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be  * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances  * when a component's calculated trade size is greater in value than remaining WETH.  *  * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade  * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()  * a minimum component receive amount can be set.  *  * @param _setToken                     Address of the SetToken  * @param _component                    Address of the SetToken component to trade  * @param _minComponentReceived        Min amount of component received during trade  */ function tradeRemainingWETH(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     external     nonReentrant     onlyAllowedTrader(_setToken)     onlyEOAIfUnrestricted(_setToken)     virtual {     require(_noTokensToSell(_setToken), "Sell other set components first");     require(         executionInfo[_setToken][weth].targetUnit &lt; _getDefaultPositionRealUnit(_setToken, weth),         "WETH is below target unit"     );      _validateTradeParameters(_setToken, _component);      TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);      _executeTrade(tradeInfo);      uint256 protocolFee = _accrueProtocolFee(tradeInfo);     (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);      require(         netReceiveAmount.add(protocolFee) &lt; executionInfo[_setToken][_component].maxSize,         "Trade amount &gt; max trade size"     );      _validateComponentPositionUnit(_setToken, _component);      emit TradeExecuted(         tradeInfo.setToken,         tradeInfo.sendToken,         tradeInfo.receiveToken,         tradeInfo.exchangeAdapter,         msg.sender,         netSendAmount,         netReceiveAmount,         protocolFee     ); }  /**  * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying  * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,  * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error  * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components  * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is  * spent buying the components to meet their new target.  *  * @param _setToken             Address of the SetToken  */ function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {     require(         _allTargetsMet(_setToken)         &amp;&amp; _getDefaultPositionRealUnit(_setToken, weth) &gt; _getNormalizedTargetUnit(_setToken, weth),         "Targets not met or ETH =~ 0"     );      // positionMultiplier / (10^18 + raiseTargetPercentage)     // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) =&gt; 997506234413965087     rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(         PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)     );     emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier); }  /**  * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.  * Note: Trade maximums must be set before rebalance can begin properly - they are zero by  * default and trades will not execute if a component's trade size is greater than the maximum.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _tradeMaximums        Array of trade maximums mapping to correct component  */ function setTradeMaximums(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _tradeMaximums )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_tradeMaximums);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];         emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);     } }  /**  * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeNames        Array of exchange names mapping to correct component  */ function setExchanges(     ISetToken _setToken,     address[] memory _components,     string[] memory _exchangeNames )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeNames);      for (uint256 i = 0; i &lt; _components.length; i++) {         if (_components[i] != address(weth)) {              require(                 controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),                 "Unrecognized exchange name"             );              executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];             emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);         }     } }  /**  * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _coolOffPeriods       Array of cool off periods to correct component  */ function setCoolOffPeriods(     ISetToken _setToken,     address[] memory _components,     uint256[] memory _coolOffPeriods )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_coolOffPeriods);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];         emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);     } }  /**  * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying  * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.  *  * @param _setToken             Address of the SetToken  * @param _components           Array of components  * @param _exchangeData         Array of exchange specific arbitrary bytes data  */ function setExchangeData(     ISetToken _setToken,     address[] memory _components,     bytes[] memory _exchangeData )     external     onlyManagerAndValidSet(_setToken) {     _components.validatePairsWithArray(_exchangeData);      for (uint256 i = 0; i &lt; _components.length; i++) {         executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];         emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);     } }  /**  * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.  *  * @param _setToken                     Address of the SetToken  * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)  */ function setRaiseTargetPercentage(     ISetToken _setToken,     uint256 _raiseTargetPercentage )     external     onlyManagerAndValidSet(_setToken) {     require(_raiseTargetPercentage &gt; 0, "Target percentage must be &gt; 0");     rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;     emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage); }  /**  * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.  *  * @param _setToken          Address of the SetToken  * @param _traders           Array trader addresses to toggle status  * @param _statuses          Booleans indicating if matching trader can trade  */ function setTraderStatus(     ISetToken _setToken,     address[] memory _traders,     bool[] memory _statuses )     external     onlyManagerAndValidSet(_setToken) {     _traders.validatePairsWithArray(_statuses);      for (uint256 i = 0; i &lt; _traders.length; i++) {         _updateTradersHistory(_setToken, _traders[i], _statuses[i]);         permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];         emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);     } }  /**  * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.  *  * @param _setToken         Address of the SetToken  * @param _status           Boolean indicating if anyone can trade  */ function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {     permissionInfo[_setToken].anyoneTrade = _status;     emit AnyoneTradeUpdated(_setToken, _status); }  /**  * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.  * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any  * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any  * position multiplier changes don't unintentionally open the Set for rebalancing.  *  * @param _setToken         Address of the Set Token  */ function initialize(ISetToken _setToken)     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     ISetToken.Position[] memory positions = _setToken.getPositions();      for (uint256 i = 0; i &lt; positions.length; i++) {         ISetToken.Position memory position = positions[i];         require(position.positionState == 0, "External positions not allowed");         executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();         executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;     }      rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();     _setToken.initializeModule(); }  /**  * Called by a SetToken to notify that this module was removed from the SetToken.  * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.  * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,  * are NOT DELETED. Restoring a previously removed module requires that care is taken to  * initialize execution settings appropriately.  */ function removeModule() external override {     TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];      for (uint i = 0; i &lt; tokenPermissionInfo.tradersHistory.length; i++) {         tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;     }      delete rebalanceInfo[ISetToken(msg.sender)];     delete permissionInfo[ISetToken(msg.sender)]; }  /* ============ External View Functions ============ */  /**  * Get the array of SetToken components involved in rebalance.  *  * @param _setToken         Address of the SetToken  *  * @return address[]        Array of _setToken components involved in rebalance  */ function getRebalanceComponents(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return rebalanceInfo[_setToken].rebalanceComponents; }  /**  * Calculates the amount of a component that is going to be traded and whether the component is being bought  * or sold. If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return componentQuantity        Amount of component being traded  */ function getComponentTradeQuantityAndDirection(     ISetToken _setToken,     IERC20 _component )     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool, uint256) {     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not recognized"     );     uint256 totalSupply = _setToken.totalSupply();     return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply); }   /**  * Get if a given address is an allowed trader.  *  * @param _setToken         Address of the SetToken  * @param _trader           Address of the trader  *  * @return bool             True if _trader is allowed to trade, else false  */ function getIsAllowedTrader(ISetToken _setToken, address _trader)     external     view     onlyValidAndInitializedSet(_setToken)     returns (bool) {     return _isAllowedTrader(_setToken, _trader); }  /**  * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()  *  * @param _setToken         Address of the SetToken  *  * @return address[]  */ function getAllowedTraders(ISetToken _setToken)     external     view     onlyValidAndInitializedSet(_setToken)     returns (address[] memory) {     return permissionInfo[_setToken].tradersHistory; }  /* ============ Internal Functions ============ */  /**  * A rebalance is a multi-step process in which current Set components are sold for a  * bridge asset (WETH) before buying target components in the correct amount to achieve  * the desired balance between elements in the set.  *  *        Step 1        |       Step 2  * -------------------------------------------  * Component --&gt; WETH   |   WETH --&gt; Component  * -------------------------------------------  *  * The syntax we use frames this as trading from a "fixed" amount of one component to a  * "fixed" amount of another via a "floating limit" which is *either* the maximum size of  * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum  * amount of tokens we expect to receive. The different meanings of the floating limit map to  * the trade sequence as below:  *  * Step 1: Component --&gt; WETH  * ----------------------------------------------------------  *                     | Fixed  |     Floating limit        |  * ----------------------------------------------------------  * send  (Component)   |  YES   |                           |  * recieve (WETH)      |        |   Min WETH to receive     |  * ----------------------------------------------------------  *  * Step 2: WETH --&gt; Component  * ----------------------------------------------------------  *                     |  Fixed  |    Floating limit        |  * ----------------------------------------------------------  * send  (WETH)        |   NO    |  Max WETH to send        |  * recieve (Component) |   YES   |                          |  * ----------------------------------------------------------  *  * Additionally, there is an edge case where price volatility during a rebalance  * results in remaining WETH which needs to be allocated proportionately. In this case  * the values are as below:  *  * Edge case: Remaining WETH --&gt; Component  * ----------------------------------------------------------  *                     | Fixed  |    Floating limit         |  * ----------------------------------------------------------  * send  (WETH)        |  YES   |                           |  * recieve (Component) |        | Min component to receive  |  * ---------------------------------------------------------- */  /**  * Create and return TradeInfo struct. This function reverts if the target has already been met.  * If this is a trade from component into WETH, sell the total fixed component quantity  * and expect to receive an ETH amount the user has specified (or more). If it's a trade from  * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's  * remaining WETH balance and expect to receive a fixed component quantity.  *  * @param _setToken             Instance of the SetToken to rebalance  * @param _component            IERC20 component to trade  * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade  *  * @return tradeInfo            Struct containing data for trade  */ function _createTradeInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _ethQuantityLimit )     internal     view     virtual     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;         tradeInfo.floatingQuantityLimit = _ethQuantityLimit;     } else {         tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);         tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;     } }  /**  * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param _minComponentReceived         Min amount of component received during trade  *  * @return tradeInfo                    Struct containing data for tradeRemaining info  */ function _createTradeRemainingInfo(     ISetToken _setToken,     IERC20 _component,     uint256 _minComponentReceived )     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);      (,,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);      tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);     tradeInfo.floatingQuantityLimit = _minComponentReceived;     tradeInfo.isSendTokenFixed = true; }  /**  * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`  * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`  * are derived separately, outside this method. `trade` requires that trade size and direction are  * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component  * as receiveToken.  *  * @param _setToken                     Instance of the SetToken to rebalance  * @param _component                    IERC20 component to trade  * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction  *  * @return tradeInfo                    Struct containing partial data for trade  */ function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)     internal     view     returns (TradeInfo memory tradeInfo) {     tradeInfo.setToken = _setToken;     tradeInfo.setTotalSupply = _setToken.totalSupply();     tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);     tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;      if(calculateTradeDirection){         (             tradeInfo.isSendTokenFixed,             tradeInfo.totalFixedQuantity         ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);     }      if (tradeInfo.isSendTokenFixed){         tradeInfo.sendToken = address(_component);         tradeInfo.receiveToken = address(weth);     } else {         tradeInfo.sendToken = address(weth);         tradeInfo.receiveToken = address(_component);     }      tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));     tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken)); }  /**  * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed  * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter  * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for  * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.  *  * @param _tradeInfo            Struct containing trade information used in internal functions  */ function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {     _tradeInfo.setToken.invokeApprove(         _tradeInfo.sendToken,         _tradeInfo.exchangeAdapter.getSpender(),         _tradeInfo.sendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _tradeInfo.exchangeAdapter.getTradeCalldata(         _tradeInfo.sendToken,         _tradeInfo.receiveToken,         address(_tradeInfo.setToken),         _tradeInfo.isSendTokenFixed,         _tradeInfo.sendQuantity,         _tradeInfo.floatingQuantityLimit,         _tradeInfo.exchangeData     );      _tradeInfo.setToken.invoke(targetExchange, callValue, methodData); }  /**  * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.  * The protocol fee is collected from the amount of received token in the trade.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  *  * @return protocolFee              Amount of receive token taken as protocol fee  */ function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {     uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)         .balanceOf(address(_tradeInfo.setToken))         .sub(_tradeInfo.preTradeReceiveTokenBalance);      protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);     payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee); }  /**  * Update SetToken positions and executionInfo's last trade timestamp. This function is intended  * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.  *  * @param _tradeInfo                Struct containing trade information used in internal functions  * @param _component                IERC20 component which was traded  *  * @return netSendAmount            Amount of sendTokens used in the trade  * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)  */ function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)     internal     returns (uint256 netSendAmount, uint256 netReceiveAmount) {     (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.sendToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeSendTokenBalance     );     (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(         _tradeInfo.receiveToken,         _tradeInfo.setTotalSupply,         _tradeInfo.preTradeReceiveTokenBalance     );      netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);     netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);      executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp; }  /**  * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's  * necessary to verify that traderHistory contains the address because AddressArrayUtils will  * throw when attempting to remove a non-element and it's possible someone can set a new  * trader's status to false.  *  * @param _setToken                         Instance of the SetToken  * @param _trader                           Trader whose permission is being set  * @param _status                           Boolean permission being set   */ function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {     if (_status &amp;&amp; !permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.push(_trader);     } else if(!_status &amp;&amp; permissionInfo[_setToken].tradersHistory.contains(_trader)) {         permissionInfo[_setToken].tradersHistory.removeStorage(_trader);     } }  /**  * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.  * If currentUnit and targetUnit are the same, function will revert.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to trade  * @param _totalSupply              Total supply of _setToken  *  * @return isSendTokenFixed         Boolean indicating fixed asset is send token  * @return totalFixedQuantity       Amount of fixed token to send or receive  */ function _calculateTradeSizeAndDirection(     ISetToken _setToken,     IERC20 _component,     uint256 _totalSupply )     internal     view     returns (bool isSendTokenFixed, uint256 totalFixedQuantity) {     uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);     uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;      (         uint256 currentUnit,         uint256 targetUnit,         uint256 currentNotional,         uint256 targetNotional     ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);      require(currentUnit != targetUnit, "Target already met");      isSendTokenFixed = targetNotional &lt; currentNotional;      // In order to account for fees taken by protocol when buying the notional difference between currentUnit     // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to     // do so would lead to never being able to meet target of components that need to be bought.     //     // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))     // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)     totalFixedQuantity = isSendTokenFixed         ? componentMaxSize.min(currentNotional.sub(targetNotional))         : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee))); }  /**  * Check if all targets are met.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if all component's target units have been met, otherwise false  */ function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }     }     return true; }  /**  * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise  * needs to be approved.  *  * @param _setToken             Instance of SetToken to be rebalanced  * @param  _trader              Address of the trader who called contract function  *  * @return bool                 True if trader is an approved trader for the SetToken  */ function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {     TradePermissionInfo storage permissions = permissionInfo[_setToken];     return permissions.anyoneTrade || permissions.tradeAllowList[_trader]; }  /**  * Checks if sell conditions are met. The component cannot be WETH and its normalized target  * unit must be less than its default position real unit  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component evaluated for sale  *  * @return bool                             True if sell allowed, false otherwise  */ function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {     return (         _component != address(weth) &amp;&amp;         (             _getNormalizedTargetUnit(_setToken, IERC20(_component)) &lt;             _getDefaultPositionRealUnit(_setToken,IERC20(_component))         )     ); }  /**  * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.  *  * @param _setToken             Instance of the SetToken to be rebalanced  *  * @return bool                 True if there is not any component that can be sold, otherwise false  */ function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {     address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;      for (uint256 i = 0; i &lt; rebalanceComponents.length; i++) {         if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }     }     return true; }  /**  * Determines if a target is met. Due to small rounding errors converting between virtual and  * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to  * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not  * checked as it is allowed to float around its target.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        Component whose target is evaluated  *  * @return bool                             True if component's target units are met, false otherwise  */ function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {     if (_component == address(weth)) return false;      uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));      return (normalizedTargetUnit &gt; 0)         ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))         : normalizedTargetUnit != currentUnit; }  /**  * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure  * the amount of component bought does not exceed the targetUnit.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component whose position units are to be validated  */ function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);     require(currentUnit &lt;= targetUnit, "Can not exceed target unit"); }  /**  * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders  * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to be validated  */ function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {     require(address(_component) != address(weth), "Can not explicitly trade WETH");     require(         rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),         "Component not part of rebalance"     );      TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];     require(         componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) &lt;= block.timestamp,         "Component cool off in progress"     );      require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed"); }  /**  * Extends and/or updates the current component set and its target units with new components and targets,  * Validates inputs, requiring that that new components and new target units arrays are the same size, and  * that the number of old components target units matches the number of current components. Throws if  * a duplicate component has been added.  *  * @param  _currentComponents               Complete set of current SetToken components  * @param _newComponents                    Array of new components to add to allocation  * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array  * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of  *                                               _setToken.getComponents() array, if component being removed set to 0.  *  * @return aggregateComponents              Array of current components extended by new components, without duplicates  * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates  */ function _getAggregateComponentsAndUnits(     address[] memory _currentComponents,     address[] calldata _newComponents,     uint256[] calldata _newComponentsTargetUnits,     uint256[] calldata _oldComponentsTargetUnits )     internal     pure     returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits) {     // Don't use validate arrays because empty arrays are valid     require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");     require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");      aggregateComponents = _currentComponents.extend(_newComponents);     aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);      require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components"); }  /**  * Get the SetToken's default position as uint256  *  * @param _setToken         Instance of the SetToken  * @param _component        IERC20 component to fetch the default position for  *  * return uint256           Real unit position  */ function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {     return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256(); }  /**  * Gets exchange adapter address for a component after checking that it exists in the  * IntegrationRegistry. This method is called during a trade and must validate the adapter  * because its state may have changed since it was set in a separate transaction.  *  * @param _setToken                         Instance of the SetToken to be rebalanced  * @param _component                        IERC20 component whose exchange adapter is fetched  *  * @return IExchangeAdapter                 Adapter address  */ function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {     return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName)); }  /**  * Calculates and returns the normalized target unit value.  *  * @param _setToken             Instance of the SetToken to be rebalanced  * @param _component            IERC20 component whose normalized target unit is required  *  * @return uint256                          Normalized target unit of the component  */ function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {     // (targetUnit * current position multiplier) / position multiplier when rebalance started     return executionInfo[_setToken][_component]         .targetUnit         .mul(_setToken.positionMultiplier().toUint256())         .div(rebalanceInfo[_setToken].positionMultiplier); }  /**  * Gets unit and notional amount values for current position and target. These are necessary  * to calculate the trade size and direction for regular trades and the `sendQuantity` for  * remainingWEth trades.  *  * @param _setToken                 Instance of the SetToken to rebalance  * @param _component                IERC20 component to calculate notional amounts for  * @param _totalSupply              SetToken total supply  *  * @return uint256              Current default position real unit of component  * @return uint256              Normalized unit of the trade target  * @return uint256              Current notional amount: total notional amount of SetToken default position  * @return uint256              Target notional amount: Total SetToken supply * targetUnit  */ function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)     internal     view     returns (uint256, uint256, uint256, uint256) {     uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);     uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);      return (         currentUnit,         targetUnit,         _totalSupply.getDefaultTotalNotional(currentUnit),         _totalSupply.preciseMulCeil(targetUnit)     ); }  /* ============== Modifier Helpers ===============  * Internal functions used to reduce bytecode size  */  /*  * Trader must be permissioned for SetToken  */ function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {     require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade"); }  /*  * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.  */ function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {     if(permissionInfo[_setToken].anyoneTrade) {         require(msg.sender == tx.origin, "Caller must be EOA Address");     } }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 01:47:37 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Math } from "@openzeppelin/contracts/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { SafeCast } from "@openzeppelin/contracts/utils/SafeCast.sol";
import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";

import { AddressArrayUtils } from "../../../lib/AddressArrayUtils.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IIndexExchangeAdapter } from "../../../interfaces/IIndexExchangeAdapter.sol";
import { Invoke } from "../../lib/Invoke.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IWETH } from "../../../interfaces/external/IWETH.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
import { Position } from "../../lib/Position.sol";
import { PreciseUnitMath } from "../../../lib/PreciseUnitMath.sol";
import { Uint256ArrayUtils } from "../../../lib/Uint256ArrayUtils.sol";


/**
 * @title GeneralIndexModule
 * @author Set Protocol
 *
 * Smart contract that facilitates rebalances for indices. Manager can update allocation by calling startRebalance().
 * There is no "end" to a rebalance, however once there are no more tokens to sell the rebalance is effectively over
 * until the manager calls startRebalance() again with a new allocation. Once a new allocation is passed in, allowed
 * traders can submit rebalance transactions by calling trade() and specifying the component they wish to rebalance.
 * All parameterizations for a trade are set by the manager ahead of time, including max trade size, coolOffPeriod bet-
 * ween trades, and exchange to trade on. WETH is used as the quote asset for all trades, near the end of rebalance
 * tradeRemaingingWETH() or raiseAssetTargets() can be called to clean up any excess WETH positions. Once a component's
 * target allocation is met any further attempted trades of that component will revert.
 *
 * SECURITY ASSUMPTION:
 *  - Works with following modules: StreamingFeeModule, BasicIssuanceModule (any other module additions to Sets using
 *    this module need to be examined separately)
 */
contract GeneralIndexModule is ModuleBase, ReentrancyGuard {
    using SafeCast for int256;
    using SafeCast for uint256;
    using SafeMath for uint256;
    using Position for uint256;
    using Math for uint256;
    using Position for ISetToken;
    using Invoke for ISetToken;
    using AddressArrayUtils for address[];
    using AddressArrayUtils for IERC20[];
    using Uint256ArrayUtils for uint256[];

    /* ============ Struct ============ */

    struct TradeExecutionParams {
        uint256 targetUnit;              // Target unit of component for Set
        uint256 maxSize;                 // Max trade size in precise units
        uint256 coolOffPeriod;           // Required time between trades for the asset
        uint256 lastTradeTimestamp;      // Timestamp of last trade
        string exchangeName;             // Name of exchange adapter
        bytes exchangeData;              // Arbitrary data that can be used to encode exchange specific settings (fee tier) or features (multi-hop)
    }

    struct TradePermissionInfo {
        bool anyoneTrade;                               // Boolean indicating if anyone can execute a trade
        address[] tradersHistory;                       // Tracks permissioned traders to be deleted on module removal
        mapping(address => bool) tradeAllowList;        // Mapping indicating which addresses are allowed to execute trade
    }

    struct RebalanceInfo {
        uint256 positionMultiplier;         // Position multiplier at the beginning of rebalance
        uint256 raiseTargetPercentage;      // Amount to raise all unit targets by if allowed (in precise units)
        address[] rebalanceComponents;      // Array of components involved in rebalance
    }

    struct TradeInfo {
        ISetToken setToken;                         // Instance of SetToken
        IIndexExchangeAdapter exchangeAdapter;      // Instance of Exchange Adapter
        address sendToken;                          // Address of token being sold
        address receiveToken;                       // Address of token being bought
        bool isSendTokenFixed;                      // Boolean indicating fixed asset is send token
        uint256 setTotalSupply;                     // Total supply of Set (in precise units)
        uint256 totalFixedQuantity;                 // Total quantity of fixed asset being traded
        uint256 sendQuantity;                       // Units of component sent to the exchange
        uint256 floatingQuantityLimit;              // Max/min amount of floating token spent/received during trade
        uint256 preTradeSendTokenBalance;           // Total initial balance of token being sold
        uint256 preTradeReceiveTokenBalance;        // Total initial balance of token being bought
        bytes exchangeData;                         // Arbitrary data for executing trade on given exchange
    }

    /* ============ Events ============ */

    event TradeMaximumUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newMaximum);
    event AssetExchangeUpdated(ISetToken indexed _setToken, address indexed _component, string _newExchangeName);
    event CoolOffPeriodUpdated(ISetToken indexed _setToken, address indexed _component, uint256 _newCoolOffPeriod);
    event ExchangeDataUpdated(ISetToken indexed _setToken, address indexed _component, bytes _newExchangeData);
    event RaiseTargetPercentageUpdated(ISetToken indexed _setToken, uint256 indexed _raiseTargetPercentage);
    event AssetTargetsRaised(ISetToken indexed _setToken, uint256 indexed positionMultiplier);

    event AnyoneTradeUpdated(ISetToken indexed _setToken, bool indexed _status);
    event TraderStatusUpdated(ISetToken indexed _setToken, address indexed _trader, bool _status);

    event TradeExecuted(
        ISetToken indexed _setToken,
        address indexed _sellComponent,
        address indexed _buyComponent,
        IIndexExchangeAdapter _exchangeAdapter,
        address _executor,
        uint256 _netAmountSold,
        uint256 _netAmountReceived,
        uint256 _protocolFee
    );

    event RebalanceStarted(
        ISetToken indexed _setToken,
        address[] aggregateComponents,
        uint256[] aggregateTargetUnits,
        uint256 indexed positionMultiplier
    );

    /* ============ Constants ============ */

    uint256 private constant GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX = 0;                   // Id of protocol fee % assigned to this module in the Controller

    /* ============ State Variables ============ */

    mapping(ISetToken => mapping(IERC20 => TradeExecutionParams)) public executionInfo;     // Mapping of SetToken to execution parameters of each asset on SetToken
    mapping(ISetToken => TradePermissionInfo) public permissionInfo;                        // Mapping of SetToken to trading permissions
    mapping(ISetToken => RebalanceInfo) public rebalanceInfo;                               // Mapping of SetToken to relevant data for current rebalance
    IWETH public immutable weth;                                                            // Weth contract address

    /* ============ Modifiers ============ */

    modifier onlyAllowedTrader(ISetToken _setToken) {
        _validateOnlyAllowedTrader(_setToken);
        _;
    }

    modifier onlyEOAIfUnrestricted(ISetToken _setToken) {
        _validateOnlyEOAIfUnrestricted(_setToken);
        _;
    }

    /* ============ Constructor ============ */

    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {
        weth = _weth;
    }

    /* ============ External Functions ============ */

    /**
     * MANAGER ONLY: Changes the target allocation of the Set, opening it up for trading by the Sets designated traders. The manager
     * must pass in any new components and their target units (units defined by the amount of that component the manager wants in 10**18
     * units of a SetToken). Old component target units must be passed in, in the current order of the components array on the
     * SetToken. If a component is being removed it's index in the _oldComponentsTargetUnits should be set to 0. Additionally, the
     * positionMultiplier is passed in, in order to adjust the target units in the event fees are accrued or some other activity occurs
     * that changes the positionMultiplier of the Set. This guarantees the same relative allocation between all the components.
     *
     * @param _setToken                         Address of the SetToken to be rebalanced
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     * @param _positionMultiplier               Position multiplier when target units were calculated, needed in order to adjust target units
     *                                               if fees accrued
     */
    function startRebalance(
        ISetToken _setToken,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits,
        uint256 _positionMultiplier
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        ( address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits ) = _getAggregateComponentsAndUnits(
            _setToken.getComponents(),
            _newComponents,
            _newComponentsTargetUnits,
            _oldComponentsTargetUnits
        );

        for (uint256 i = 0; i < aggregateComponents.length; i++) {
            require(!_setToken.hasExternalPosition(aggregateComponents[i]), "External positions not allowed");
            executionInfo[_setToken][IERC20(aggregateComponents[i])].targetUnit = aggregateTargetUnits[i];
        }

        rebalanceInfo[_setToken].rebalanceComponents = aggregateComponents;
        rebalanceInfo[_setToken].positionMultiplier = _positionMultiplier;

        emit RebalanceStarted(_setToken, aggregateComponents, aggregateTargetUnits, _positionMultiplier);
    }

    /**
     * ACCESS LIMITED: Calling trade() pushes the current component units closer to the target units defined by the manager in startRebalance().
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA.
     *
     * Trade can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Trader can pass
     * in a max/min amount of ETH spent/received in the trade based on if the component is being bought/sold in order to prevent sandwich attacks.
     * The parameters defined by the manager are used to determine which exchange will be used and the size of the trade. Trade size will default
     * to max trade size unless the max trade size would exceed the target, then an amount that would match the target unit is traded. Protocol fees,
     * if enabled, are collected in the token received in a trade.
     *
     * @param _setToken             Address of the SetToken
     * @param _component            Address of SetToken component to trade
     * @param _ethQuantityLimit     Max/min amount of ETH spent/received during trade
     */
    function trade(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeInfo(_setToken, _component, _ethQuantityLimit);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);

        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: Only callable when 1) there are no more components to be sold and, 2) entire remaining WETH amount (above WETH target) can be
     * traded such that resulting inflows won't exceed component's maxTradeSize nor overshoot the target unit. To be used near the end of rebalances
     * when a component's calculated trade size is greater in value than remaining WETH.
     *
     * Only approved addresses can call, if anyoneTrade is false then contracts are allowed to call otherwise calling address must be EOA. Trade
     * can be called at anytime but will revert if the passed component's target unit is met or cool off period hasn't passed. Like with trade()
     * a minimum component receive amount can be set.
     *
     * @param _setToken                     Address of the SetToken
     * @param _component                    Address of the SetToken component to trade
     * @param _minComponentReceived        Min amount of component received during trade
     */
    function tradeRemainingWETH(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        external
        nonReentrant
        onlyAllowedTrader(_setToken)
        onlyEOAIfUnrestricted(_setToken)
        virtual
    {
        require(_noTokensToSell(_setToken), "Sell other set components first");
        require(
            executionInfo[_setToken][weth].targetUnit < _getDefaultPositionRealUnit(_setToken, weth),
            "WETH is below target unit"
        );

        _validateTradeParameters(_setToken, _component);

        TradeInfo memory tradeInfo = _createTradeRemainingInfo(_setToken, _component, _minComponentReceived);

        _executeTrade(tradeInfo);

        uint256 protocolFee = _accrueProtocolFee(tradeInfo);
        (uint256 netSendAmount, uint256 netReceiveAmount) = _updatePositionStateAndTimestamp(tradeInfo, _component);

        require(
            netReceiveAmount.add(protocolFee) < executionInfo[_setToken][_component].maxSize,
            "Trade amount > max trade size"
        );

        _validateComponentPositionUnit(_setToken, _component);

        emit TradeExecuted(
            tradeInfo.setToken,
            tradeInfo.sendToken,
            tradeInfo.receiveToken,
            tradeInfo.exchangeAdapter,
            msg.sender,
            netSendAmount,
            netReceiveAmount,
            protocolFee
        );
    }

    /**
     * ACCESS LIMITED: For situation where all target units met and remaining WETH, uniformly raise targets by same percentage by applying
     * to logged positionMultiplier in RebalanceInfo struct, in order to allow further trading. Can be called multiple times if necessary,
     * targets are increased by amount specified by raiseAssetTargetsPercentage as set by manager. In order to reduce tracking error
     * raising the target by a smaller amount allows greater granularity in finding an equilibrium between the excess ETH and components
     * that need to be bought. Raising the targets too much could result in vastly under allocating to WETH as more WETH than necessary is
     * spent buying the components to meet their new target.
     *
     * @param _setToken             Address of the SetToken
     */
    function raiseAssetTargets(ISetToken _setToken) external onlyAllowedTrader(_setToken) virtual {
        require(
            _allTargetsMet(_setToken)
            && _getDefaultPositionRealUnit(_setToken, weth) > _getNormalizedTargetUnit(_setToken, weth),
            "Targets not met or ETH =~ 0"
        );

        // positionMultiplier / (10^18 + raiseTargetPercentage)
        // ex: (10 ** 18) / ((10 ** 18) + ether(.0025)) => 997506234413965087
        rebalanceInfo[_setToken].positionMultiplier = rebalanceInfo[_setToken].positionMultiplier.preciseDiv(
            PreciseUnitMath.preciseUnit().add(rebalanceInfo[_setToken].raiseTargetPercentage)
        );
        emit AssetTargetsRaised(_setToken, rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * MANAGER ONLY: Set trade maximums for passed components of the SetToken. Can be called at anytime.
     * Note: Trade maximums must be set before rebalance can begin properly - they are zero by
     * default and trades will not execute if a component's trade size is greater than the maximum.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _tradeMaximums        Array of trade maximums mapping to correct component
     */
    function setTradeMaximums(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _tradeMaximums
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_tradeMaximums);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].maxSize = _tradeMaximums[i];
            emit TradeMaximumUpdated(_setToken, _components[i], _tradeMaximums[i]);
        }
    }

    /**
     * MANAGER ONLY: Set exchange for passed components of the SetToken. Can be called at anytime.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeNames        Array of exchange names mapping to correct component
     */
    function setExchanges(
        ISetToken _setToken,
        address[] memory _components,
        string[] memory _exchangeNames
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeNames);

        for (uint256 i = 0; i < _components.length; i++) {
            if (_components[i] != address(weth)) {

                require(
                    controller.getIntegrationRegistry().isValidIntegration(address(this), _exchangeNames[i]),
                    "Unrecognized exchange name"
                );

                executionInfo[_setToken][IERC20(_components[i])].exchangeName = _exchangeNames[i];
                emit AssetExchangeUpdated(_setToken, _components[i], _exchangeNames[i]);
            }
        }
    }

    /**
     * MANAGER ONLY: Set cool off periods for passed components of the SetToken. Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _coolOffPeriods       Array of cool off periods to correct component
     */
    function setCoolOffPeriods(
        ISetToken _setToken,
        address[] memory _components,
        uint256[] memory _coolOffPeriods
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_coolOffPeriods);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].coolOffPeriod = _coolOffPeriods[i];
            emit CoolOffPeriodUpdated(_setToken, _components[i], _coolOffPeriods[i]);
        }
    }

    /**
     * MANAGER ONLY: Set arbitrary byte data on a per asset basis that can be used to pass exchange specific settings (i.e. specifying
     * fee tiers) or exchange specific features (enabling multi-hop trades). Can be called at any time.
     *
     * @param _setToken             Address of the SetToken
     * @param _components           Array of components
     * @param _exchangeData         Array of exchange specific arbitrary bytes data
     */
    function setExchangeData(
        ISetToken _setToken,
        address[] memory _components,
        bytes[] memory _exchangeData
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _components.validatePairsWithArray(_exchangeData);

        for (uint256 i = 0; i < _components.length; i++) {
            executionInfo[_setToken][IERC20(_components[i])].exchangeData = _exchangeData[i];
            emit ExchangeDataUpdated(_setToken, _components[i], _exchangeData[i]);
        }
    }

    /**
     * MANAGER ONLY: Set amount by which all component's targets units would be raised. Can be called at any time.
     *
     * @param _setToken                     Address of the SetToken
     * @param _raiseTargetPercentage        Amount to raise all component's unit targets by (in precise units)
     */
    function setRaiseTargetPercentage(
        ISetToken _setToken,
        uint256 _raiseTargetPercentage
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        require(_raiseTargetPercentage > 0, "Target percentage must be > 0");
        rebalanceInfo[_setToken].raiseTargetPercentage = _raiseTargetPercentage;
        emit RaiseTargetPercentageUpdated(_setToken, _raiseTargetPercentage);
    }

    /**
     * MANAGER ONLY: Toggles ability for passed addresses to call trade() or tradeRemainingWETH(). Can be called at any time.
     *
     * @param _setToken          Address of the SetToken
     * @param _traders           Array trader addresses to toggle status
     * @param _statuses          Booleans indicating if matching trader can trade
     */
    function setTraderStatus(
        ISetToken _setToken,
        address[] memory _traders,
        bool[] memory _statuses
    )
        external
        onlyManagerAndValidSet(_setToken)
    {
        _traders.validatePairsWithArray(_statuses);

        for (uint256 i = 0; i < _traders.length; i++) {
            _updateTradersHistory(_setToken, _traders[i], _statuses[i]);
            permissionInfo[_setToken].tradeAllowList[_traders[i]] = _statuses[i];
            emit TraderStatusUpdated(_setToken, _traders[i], _statuses[i]);
        }
    }

    /**
     * MANAGER ONLY: Toggle whether anyone can trade, if true bypasses the traderAllowList. Can be called at anytime.
     *
     * @param _setToken         Address of the SetToken
     * @param _status           Boolean indicating if anyone can trade
     */
    function setAnyoneTrade(ISetToken _setToken, bool _status) external onlyManagerAndValidSet(_setToken) {
        permissionInfo[_setToken].anyoneTrade = _status;
        emit AnyoneTradeUpdated(_setToken, _status);
    }

    /**
     * MANAGER ONLY: Called to initialize module to SetToken in order to allow GeneralIndexModule access for rebalances.
     * Grabs the current units for each asset in the Set and set's the targetUnit to that unit in order to prevent any
     * trading until startRebalance() is explicitly called. Position multiplier is also logged in order to make sure any
     * position multiplier changes don't unintentionally open the Set for rebalancing.
     *
     * @param _setToken         Address of the Set Token
     */
    function initialize(ISetToken _setToken)
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        ISetToken.Position[] memory positions = _setToken.getPositions();

        for (uint256 i = 0; i < positions.length; i++) {
            ISetToken.Position memory position = positions[i];
            require(position.positionState == 0, "External positions not allowed");
            executionInfo[_setToken][IERC20(position.component)].targetUnit = position.unit.toUint256();
            executionInfo[_setToken][IERC20(position.component)].lastTradeTimestamp = 0;
        }

        rebalanceInfo[_setToken].positionMultiplier = _setToken.positionMultiplier().toUint256();
        _setToken.initializeModule();
    }

    /**
     * Called by a SetToken to notify that this module was removed from the SetToken.
     * Clears the rebalanceInfo and permissionsInfo of the calling SetToken.
     * IMPORTANT: SetToken's execution settings, including trade maximums and exchange names,
     * are NOT DELETED. Restoring a previously removed module requires that care is taken to
     * initialize execution settings appropriately.
     */
    function removeModule() external override {
        TradePermissionInfo storage tokenPermissionInfo = permissionInfo[ISetToken(msg.sender)];

        for (uint i = 0; i < tokenPermissionInfo.tradersHistory.length; i++) {
            tokenPermissionInfo.tradeAllowList[tokenPermissionInfo.tradersHistory[i]] = false;
        }

        delete rebalanceInfo[ISetToken(msg.sender)];
        delete permissionInfo[ISetToken(msg.sender)];
    }

    /* ============ External View Functions ============ */

    /**
     * Get the array of SetToken components involved in rebalance.
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]        Array of _setToken components involved in rebalance
     */
    function getRebalanceComponents(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return rebalanceInfo[_setToken].rebalanceComponents;
    }

    /**
     * Calculates the amount of a component that is going to be traded and whether the component is being bought
     * or sold. If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return componentQuantity        Amount of component being traded
     */
    function getComponentTradeQuantityAndDirection(
        ISetToken _setToken,
        IERC20 _component
    )
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool, uint256)
    {
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not recognized"
        );
        uint256 totalSupply = _setToken.totalSupply();
        return _calculateTradeSizeAndDirection(_setToken, _component, totalSupply);
    }


    /**
     * Get if a given address is an allowed trader.
     *
     * @param _setToken         Address of the SetToken
     * @param _trader           Address of the trader
     *
     * @return bool             True if _trader is allowed to trade, else false
     */
    function getIsAllowedTrader(ISetToken _setToken, address _trader)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (bool)
    {
        return _isAllowedTrader(_setToken, _trader);
    }

    /**
     * Get the list of traders who are allowed to call trade(), tradeRemainingWeth(), and raiseAssetTarget()
     *
     * @param _setToken         Address of the SetToken
     *
     * @return address[]
     */
    function getAllowedTraders(ISetToken _setToken)
        external
        view
        onlyValidAndInitializedSet(_setToken)
        returns (address[] memory)
    {
        return permissionInfo[_setToken].tradersHistory;
    }

    /* ============ Internal Functions ============ */

    /**
     * A rebalance is a multi-step process in which current Set components are sold for a
     * bridge asset (WETH) before buying target components in the correct amount to achieve
     * the desired balance between elements in the set.
     *
     *        Step 1        |       Step 2
     * -------------------------------------------
     * Component --> WETH   |   WETH --> Component
     * -------------------------------------------
     *
     * The syntax we use frames this as trading from a "fixed" amount of one component to a
     * "fixed" amount of another via a "floating limit" which is *either* the maximum size of
     * the trade we want to make (trades may be tranched to avoid moving markets) OR the minimum
     * amount of tokens we expect to receive. The different meanings of the floating limit map to
     * the trade sequence as below:
     *
     * Step 1: Component --> WETH
     * ----------------------------------------------------------
     *                     | Fixed  |     Floating limit        |
     * ----------------------------------------------------------
     * send  (Component)   |  YES   |                           |
     * recieve (WETH)      |        |   Min WETH to receive     |
     * ----------------------------------------------------------
     *
     * Step 2: WETH --> Component
     * ----------------------------------------------------------
     *                     |  Fixed  |    Floating limit        |
     * ----------------------------------------------------------
     * send  (WETH)        |   NO    |  Max WETH to send        |
     * recieve (Component) |   YES   |                          |
     * ----------------------------------------------------------
     *
     * Additionally, there is an edge case where price volatility during a rebalance
     * results in remaining WETH which needs to be allocated proportionately. In this case
     * the values are as below:
     *
     * Edge case: Remaining WETH --> Component
     * ----------------------------------------------------------
     *                     | Fixed  |    Floating limit         |
     * ----------------------------------------------------------
     * send  (WETH)        |  YES   |                           |
     * recieve (Component) |        | Min component to receive  |
     * ----------------------------------------------------------
    */

    /**
     * Create and return TradeInfo struct. This function reverts if the target has already been met.
     * If this is a trade from component into WETH, sell the total fixed component quantity
     * and expect to receive an ETH amount the user has specified (or more). If it's a trade from
     * WETH into a component, sell the lesser of: the user's WETH limit OR the SetToken's
     * remaining WETH balance and expect to receive a fixed component quantity.
     *
     * @param _setToken             Instance of the SetToken to rebalance
     * @param _component            IERC20 component to trade
     * @param _ethQuantityLimit     Max/min amount of weth spent/received during trade
     *
     * @return tradeInfo            Struct containing data for trade
     */
    function _createTradeInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _ethQuantityLimit
    )
        internal
        view
        virtual
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, true);

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendQuantity = tradeInfo.totalFixedQuantity;
            tradeInfo.floatingQuantityLimit = _ethQuantityLimit;
        } else {
            tradeInfo.sendQuantity = _ethQuantityLimit.min(tradeInfo.preTradeSendTokenBalance);
            tradeInfo.floatingQuantityLimit = tradeInfo.totalFixedQuantity;
        }
    }

    /**
     * Create and return TradeInfo struct. This function does NOT check if the WETH target has been met.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param _minComponentReceived         Min amount of component received during trade
     *
     * @return tradeInfo                    Struct containing data for tradeRemaining info
     */
    function _createTradeRemainingInfo(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _minComponentReceived
    )
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo = _getDefaultTradeInfo(_setToken, _component, false);

        (,,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, weth, tradeInfo.setTotalSupply);

        tradeInfo.sendQuantity =  currentNotional.sub(targetNotional);
        tradeInfo.floatingQuantityLimit = _minComponentReceived;
        tradeInfo.isSendTokenFixed = true;
    }

    /**
     * Create and returns a partial TradeInfo struct with all fields that overlap between `trade`
     * and `tradeRemaining` info constructors filled in. Values for `sendQuantity` and `floatingQuantityLimit`
     * are derived separately, outside this method. `trade` requires that trade size and direction are
     * calculated, whereas `tradeRemaining` automatically sets WETH as the sendToken and _component
     * as receiveToken.
     *
     * @param _setToken                     Instance of the SetToken to rebalance
     * @param _component                    IERC20 component to trade
     * @param  calculateTradeDirection      Indicates whether method should calculate trade size and direction
     *
     * @return tradeInfo                    Struct containing partial data for trade
     */
    function _getDefaultTradeInfo(ISetToken _setToken, IERC20 _component, bool calculateTradeDirection)
        internal
        view
        returns (TradeInfo memory tradeInfo)
    {
        tradeInfo.setToken = _setToken;
        tradeInfo.setTotalSupply = _setToken.totalSupply();
        tradeInfo.exchangeAdapter = _getExchangeAdapter(_setToken, _component);
        tradeInfo.exchangeData = executionInfo[_setToken][_component].exchangeData;

        if(calculateTradeDirection){
            (
                tradeInfo.isSendTokenFixed,
                tradeInfo.totalFixedQuantity
            ) = _calculateTradeSizeAndDirection(_setToken, _component, tradeInfo.setTotalSupply);
        }

        if (tradeInfo.isSendTokenFixed){
            tradeInfo.sendToken = address(_component);
            tradeInfo.receiveToken = address(weth);
        } else {
            tradeInfo.sendToken = address(weth);
            tradeInfo.receiveToken = address(_component);
        }

        tradeInfo.preTradeSendTokenBalance = IERC20(tradeInfo.sendToken).balanceOf(address(_setToken));
        tradeInfo.preTradeReceiveTokenBalance = IERC20(tradeInfo.receiveToken).balanceOf(address(_setToken));
    }

    /**
     * Function handles all interactions with exchange. All GeneralIndexModule adapters must allow for selling or buying a fixed
     * quantity of a token in return for a non-fixed (floating) quantity of a token. If `isSendTokenFixed` is true then the adapter
     * will choose the exchange interface associated with inputting a fixed amount, otherwise it will select the interface used for
     * receiving a fixed amount. Any other exchange specific data can also be created by calling generateDataParam function.
     *
     * @param _tradeInfo            Struct containing trade information used in internal functions
     */
    function _executeTrade(TradeInfo memory _tradeInfo) internal virtual {
        _tradeInfo.setToken.invokeApprove(
            _tradeInfo.sendToken,
            _tradeInfo.exchangeAdapter.getSpender(),
            _tradeInfo.sendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _tradeInfo.exchangeAdapter.getTradeCalldata(
            _tradeInfo.sendToken,
            _tradeInfo.receiveToken,
            address(_tradeInfo.setToken),
            _tradeInfo.isSendTokenFixed,
            _tradeInfo.sendQuantity,
            _tradeInfo.floatingQuantityLimit,
            _tradeInfo.exchangeData
        );

        _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);
    }

    /**
     * Retrieve fee from controller and calculate total protocol fee and send from SetToken to protocol recipient.
     * The protocol fee is collected from the amount of received token in the trade.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     *
     * @return protocolFee              Amount of receive token taken as protocol fee
     */
    function _accrueProtocolFee(TradeInfo memory _tradeInfo) internal returns (uint256 protocolFee) {
        uint256 exchangedQuantity =  IERC20(_tradeInfo.receiveToken)
            .balanceOf(address(_tradeInfo.setToken))
            .sub(_tradeInfo.preTradeReceiveTokenBalance);

        protocolFee = getModuleFee(GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX, exchangedQuantity);
        payProtocolFeeFromSetToken(_tradeInfo.setToken, _tradeInfo.receiveToken, protocolFee);
    }

    /**
     * Update SetToken positions and executionInfo's last trade timestamp. This function is intended
     * to be called after the fees have been accrued, hence it returns the amount of tokens bought net of fees.
     *
     * @param _tradeInfo                Struct containing trade information used in internal functions
     * @param _component                IERC20 component which was traded
     *
     * @return netSendAmount            Amount of sendTokens used in the trade
     * @return netReceiveAmount         Amount of receiveTokens received in the trade (net of fees)
     */
    function _updatePositionStateAndTimestamp(TradeInfo memory _tradeInfo, IERC20 _component)
        internal
        returns (uint256 netSendAmount, uint256 netReceiveAmount)
    {
        (uint256 postTradeSendTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.sendToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeSendTokenBalance
        );
        (uint256 postTradeReceiveTokenBalance,,) = _tradeInfo.setToken.calculateAndEditDefaultPosition(
            _tradeInfo.receiveToken,
            _tradeInfo.setTotalSupply,
            _tradeInfo.preTradeReceiveTokenBalance
        );

        netSendAmount = _tradeInfo.preTradeSendTokenBalance.sub(postTradeSendTokenBalance);
        netReceiveAmount = postTradeReceiveTokenBalance.sub(_tradeInfo.preTradeReceiveTokenBalance);

        executionInfo[_tradeInfo.setToken][_component].lastTradeTimestamp = block.timestamp;
    }

    /**
     * Adds or removes newly permissioned trader to/from permissionsInfo traderHistory. It's
     * necessary to verify that traderHistory contains the address because AddressArrayUtils will
     * throw when attempting to remove a non-element and it's possible someone can set a new
     * trader's status to false.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _trader                           Trader whose permission is being set
     * @param _status                           Boolean permission being set

     */
    function _updateTradersHistory(ISetToken _setToken, address _trader, bool _status) internal {
        if (_status && !permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.push(_trader);
        } else if(!_status && permissionInfo[_setToken].tradersHistory.contains(_trader)) {
            permissionInfo[_setToken].tradersHistory.removeStorage(_trader);
        }
    }

    /**
     * Calculates the amount of a component is going to be traded and whether the component is being bought or sold.
     * If currentUnit and targetUnit are the same, function will revert.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to trade
     * @param _totalSupply              Total supply of _setToken
     *
     * @return isSendTokenFixed         Boolean indicating fixed asset is send token
     * @return totalFixedQuantity       Amount of fixed token to send or receive
     */
    function _calculateTradeSizeAndDirection(
        ISetToken _setToken,
        IERC20 _component,
        uint256 _totalSupply
    )
        internal
        view
        returns (bool isSendTokenFixed, uint256 totalFixedQuantity)
    {
        uint256 protocolFee = controller.getModuleFee(address(this), GENERAL_INDEX_MODULE_PROTOCOL_FEE_INDEX);
        uint256 componentMaxSize = executionInfo[_setToken][_component].maxSize;

        (
            uint256 currentUnit,
            uint256 targetUnit,
            uint256 currentNotional,
            uint256 targetNotional
        ) = _getUnitsAndNotionalAmounts(_setToken, _component, _totalSupply);

        require(currentUnit != targetUnit, "Target already met");

        isSendTokenFixed = targetNotional < currentNotional;

        // In order to account for fees taken by protocol when buying the notional difference between currentUnit
        // and targetUnit is divided by (1 - protocolFee) to make sure that targetUnit can be met. Failure to
        // do so would lead to never being able to meet target of components that need to be bought.
        //
        // ? - lesserOf: (componentMaxSize, (currentNotional - targetNotional))
        // : - lesserOf: (componentMaxSize, (targetNotional - currentNotional) / 10 ** 18 - protocolFee)
        totalFixedQuantity = isSendTokenFixed
            ? componentMaxSize.min(currentNotional.sub(targetNotional))
            : componentMaxSize.min(targetNotional.sub(currentNotional).preciseDiv(PreciseUnitMath.preciseUnit().sub(protocolFee)));
    }

    /**
     * Check if all targets are met.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if all component's target units have been met, otherwise false
     */
    function _allTargetsMet(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_targetUnmet(_setToken, rebalanceComponents[i])) { return false; }
        }
        return true;
    }

    /**
     * Determine if passed address is allowed to call trade for the SetToken. If anyoneTrade set to true anyone can call otherwise
     * needs to be approved.
     *
     * @param _setToken             Instance of SetToken to be rebalanced
     * @param  _trader              Address of the trader who called contract function
     *
     * @return bool                 True if trader is an approved trader for the SetToken
     */
    function _isAllowedTrader(ISetToken _setToken, address _trader) internal view returns (bool) {
        TradePermissionInfo storage permissions = permissionInfo[_setToken];
        return permissions.anyoneTrade || permissions.tradeAllowList[_trader];
    }

    /**
     * Checks if sell conditions are met. The component cannot be WETH and its normalized target
     * unit must be less than its default position real unit
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component evaluated for sale
     *
     * @return bool                             True if sell allowed, false otherwise
     */
    function _canSell(ISetToken _setToken, address _component) internal view returns(bool) {
        return (
            _component != address(weth) &&
            (
                _getNormalizedTargetUnit(_setToken, IERC20(_component)) <
                _getDefaultPositionRealUnit(_setToken,IERC20(_component))
            )
        );
    }

    /**
     * Check if there are any more tokens to sell. Since we allow WETH to float around it's target during rebalances it is not checked.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     *
     * @return bool                 True if there is not any component that can be sold, otherwise false
     */
    function _noTokensToSell(ISetToken _setToken) internal view returns (bool) {
        address[] memory rebalanceComponents = rebalanceInfo[_setToken].rebalanceComponents;

        for (uint256 i = 0; i < rebalanceComponents.length; i++) {
            if (_canSell(_setToken, rebalanceComponents[i]) ) { return false; }
        }
        return true;
    }

    /**
     * Determines if a target is met. Due to small rounding errors converting between virtual and
     * real unit on SetToken we allow for a 1 wei buffer when checking if target is met. In order to
     * avoid subtraction overflow errors targetUnits of zero check for an exact amount. WETH is not
     * checked as it is allowed to float around its target.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        Component whose target is evaluated
     *
     * @return bool                             True if component's target units are met, false otherwise
     */
    function _targetUnmet(ISetToken _setToken, address _component) internal view returns(bool) {
        if (_component == address(weth)) return false;

        uint256 normalizedTargetUnit = _getNormalizedTargetUnit(_setToken, IERC20(_component));
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, IERC20(_component));

        return (normalizedTargetUnit > 0)
            ? !(normalizedTargetUnit.approximatelyEquals(currentUnit, 1))
            : normalizedTargetUnit != currentUnit;
    }

    /**
     * Validate component position unit has not exceeded it's target unit. This is used during tradeRemainingWETH() to make sure
     * the amount of component bought does not exceed the targetUnit.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component whose position units are to be validated
     */
    function _validateComponentPositionUnit(ISetToken _setToken, IERC20 _component) internal view {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);
        require(currentUnit <= targetUnit, "Can not exceed target unit");
    }

    /**
     * Validate that component is a valid component and enough time has elapsed since component's last trade. Traders
     * cannot explicitly trade WETH, it may only implicitly be traded by being the quote asset for other component trades.
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to be validated
     */
    function _validateTradeParameters(ISetToken _setToken, IERC20 _component) internal view virtual {
        require(address(_component) != address(weth), "Can not explicitly trade WETH");
        require(
            rebalanceInfo[_setToken].rebalanceComponents.contains(address(_component)),
            "Component not part of rebalance"
        );

        TradeExecutionParams memory componentInfo = executionInfo[_setToken][_component];
        require(
            componentInfo.lastTradeTimestamp.add(componentInfo.coolOffPeriod) <= block.timestamp,
            "Component cool off in progress"
        );

        require(!_setToken.hasExternalPosition(address(_component)), "External positions not allowed");
    }

    /**
     * Extends and/or updates the current component set and its target units with new components and targets,
     * Validates inputs, requiring that that new components and new target units arrays are the same size, and
     * that the number of old components target units matches the number of current components. Throws if
     * a duplicate component has been added.
     *
     * @param  _currentComponents               Complete set of current SetToken components
     * @param _newComponents                    Array of new components to add to allocation
     * @param _newComponentsTargetUnits         Array of target units at end of rebalance for new components, maps to same index of _newComponents array
     * @param _oldComponentsTargetUnits         Array of target units at end of rebalance for old component, maps to same index of
     *                                               _setToken.getComponents() array, if component being removed set to 0.
     *
     * @return aggregateComponents              Array of current components extended by new components, without duplicates
     * @return aggregateTargetUnits             Array of old component target units extended by new target units, without duplicates
     */
    function _getAggregateComponentsAndUnits(
        address[] memory _currentComponents,
        address[] calldata _newComponents,
        uint256[] calldata _newComponentsTargetUnits,
        uint256[] calldata _oldComponentsTargetUnits
    )
        internal
        pure
        returns (address[] memory aggregateComponents, uint256[] memory aggregateTargetUnits)
    {
        // Don't use validate arrays because empty arrays are valid
        require(_newComponents.length == _newComponentsTargetUnits.length, "Array length mismatch");
        require(_currentComponents.length == _oldComponentsTargetUnits.length, "Old Components targets missing");

        aggregateComponents = _currentComponents.extend(_newComponents);
        aggregateTargetUnits = _oldComponentsTargetUnits.extend(_newComponentsTargetUnits);

        require(!aggregateComponents.hasDuplicate(), "Cannot duplicate components");
    }

    /**
     * Get the SetToken's default position as uint256
     *
     * @param _setToken         Instance of the SetToken
     * @param _component        IERC20 component to fetch the default position for
     *
     * return uint256           Real unit position
     */
    function _getDefaultPositionRealUnit(ISetToken _setToken, IERC20 _component) internal view returns (uint256) {
        return _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();
    }

    /**
     * Gets exchange adapter address for a component after checking that it exists in the
     * IntegrationRegistry. This method is called during a trade and must validate the adapter
     * because its state may have changed since it was set in a separate transaction.
     *
     * @param _setToken                         Instance of the SetToken to be rebalanced
     * @param _component                        IERC20 component whose exchange adapter is fetched
     *
     * @return IExchangeAdapter                 Adapter address
     */
    function _getExchangeAdapter(ISetToken _setToken, IERC20 _component) internal view returns(IIndexExchangeAdapter) {
        return IIndexExchangeAdapter(getAndValidateAdapter(executionInfo[_setToken][_component].exchangeName));
    }

    /**
     * Calculates and returns the normalized target unit value.
     *
     * @param _setToken             Instance of the SetToken to be rebalanced
     * @param _component            IERC20 component whose normalized target unit is required
     *
     * @return uint256                          Normalized target unit of the component
     */
    function _getNormalizedTargetUnit(ISetToken _setToken, IERC20 _component) internal view returns(uint256) {
        // (targetUnit * current position multiplier) / position multiplier when rebalance started
        return executionInfo[_setToken][_component]
            .targetUnit
            .mul(_setToken.positionMultiplier().toUint256())
            .div(rebalanceInfo[_setToken].positionMultiplier);
    }

    /**
     * Gets unit and notional amount values for current position and target. These are necessary
     * to calculate the trade size and direction for regular trades and the `sendQuantity` for
     * remainingWEth trades.
     *
     * @param _setToken                 Instance of the SetToken to rebalance
     * @param _component                IERC20 component to calculate notional amounts for
     * @param _totalSupply              SetToken total supply
     *
     * @return uint256              Current default position real unit of component
     * @return uint256              Normalized unit of the trade target
     * @return uint256              Current notional amount: total notional amount of SetToken default position
     * @return uint256              Target notional amount: Total SetToken supply * targetUnit
     */
    function _getUnitsAndNotionalAmounts(ISetToken _setToken, IERC20 _component, uint256 _totalSupply)
        internal
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 currentUnit = _getDefaultPositionRealUnit(_setToken, _component);
        uint256 targetUnit = _getNormalizedTargetUnit(_setToken, _component);

        return (
            currentUnit,
            targetUnit,
            _totalSupply.getDefaultTotalNotional(currentUnit),
            _totalSupply.preciseMulCeil(targetUnit)
        );
    }

    /* ============== Modifier Helpers ===============
     * Internal functions used to reduce bytecode size
     */

    /*
     * Trader must be permissioned for SetToken
     */
    function _validateOnlyAllowedTrader(ISetToken _setToken) internal view {
        require(_isAllowedTrader(_setToken, msg.sender), "Address not permitted to trade");
    }

    /*
     * Trade must be an EOA if `anyoneTrade` has been enabled for SetToken on the module.
     */
    function _validateOnlyEOAIfUnrestricted(ISetToken _setToken) internal view {
        if(permissionInfo[_setToken].anyoneTrade) {
            require(msg.sender == tx.origin, "Caller must be EOA Address");
        }
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

