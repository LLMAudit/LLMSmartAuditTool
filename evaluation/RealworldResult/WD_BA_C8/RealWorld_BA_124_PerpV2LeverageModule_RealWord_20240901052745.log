[2024-01-09 05:27:45 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901052745)

**Timestamp**: 20240901052745

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}

**project_name**: RealWorld_BA_124_PerpV2LeverageModule

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_124_PerpV2LeverageModule_RealWord_20240901052745.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 05:27:46 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport "@openzeppelin/contracts/math/SignedSafeMath.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";\n\nimport { PerpV2 } from "../integration/lib/PerpV2.sol";\nimport { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";\nimport { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";\nimport { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";\nimport { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";\nimport { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";\nimport { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";\nimport { IVault } from "../../interfaces/external/perp-v2/IVault.sol";\nimport { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";\nimport { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";\nimport { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";\n\n/\n * @title PerpV2LeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account\n * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token\n * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of\n * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.\n \n * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit\n * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.\n * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the\n * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.\n \n * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current\n * value of the Set\'s perpetual position. The current value can be calculated from getPositionNotionalInfo.\n /\ncontract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {\n    using PerpV2 for ISetToken;\n    using PreciseUnitMath for int256;\n    using SignedSafeMath for int256;\n    using UnitConversionUtils for int256;\n    using UniswapV3Math for uint160;\n    using UniswapV3Math for uint256;\n    using UnitConversionUtils for uint256;\n    using AddressArrayUtils for address[];\n\n    / ============ Structs ============ */\n\n    struct ActionInfo {\n        ISetToken setToken;\n        address baseToken;              // Virtual token minted by the Perp protocol\n        bool isBuy;                     // When true, baseToken is being bought, when false, sold\n        uint256 baseTokenAmount;        // Base token quantity in 1018 decimals\n        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see _createActionInfoNotional for details)\n    }\n\n    struct PositionNotionalInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseBalance;             // Base position notional quantity in 1018 decimals. When negative, position is short\n        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short\n    }\n\n    struct PositionUnitInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseUnit;                // Base position unit. When negative, position is short\n        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short\n    }\n\n    // Note: when pendingFundingPayments is positive it will be credited to account on settlement,\n    // when negative it\'s a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value\n    // with the opposite meaning, e.g positively signed payments are owed by account to system).\n    struct AccountInfo {\n        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 1018 decimals\n        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 1018 decimals not yet settled to vault\n        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 1018 decimals\n        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account\n    }\n\n    / ============ Events ============ /\n\n    /\n     * @dev Emitted on trade\n     * @param _setToken         Instance of SetToken\n     * @param _baseToken        Virtual token minted by the Perp protocol\n     * @param _deltaBase        Change in baseToken position size resulting from trade\n     * @param _deltaQuote       Change in vUSDC position size resulting from trade\n     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade\n     * @param _isBuy            True when baseToken is being bought, false when being sold\n     */\n    event PerpTraded(\n        ISetToken indexed _setToken,\n        address indexed _baseToken,\n        uint256 indexed _deltaBase,\n        uint256 _deltaQuote,\n        uint256 _protocolFee,\n        bool _isBuy\n    );\n\n    /\n     * @dev Emitted on deposit (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being deposited as collateral (USDC)\n     * @param _amountDeposited      Amount of collateral being deposited into Perp\n     /\n    event CollateralDeposited(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountDeposited\n    );\n\n    /\n     * @dev Emitted on withdraw (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being withdrawn as collateral (USDC)\n     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp\n     /\n    event CollateralWithdrawn(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountWithdrawn\n    );\n\n    / ============ Constants ============ /\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it\'s settlement and collateral token\n    IERC20 public immutable collateralToken;\n\n    // Decimals of collateral token. We set this in the constructor for later reading\n    uint8 internal immutable collateralDecimals;\n\n    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances\n    IAccountBalance public immutable perpAccountBalance;\n\n    // PerpV2 contract which provides a trading API\n    IClearingHouse public immutable perpClearingHouse;\n\n    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances\n    IExchange public immutable perpExchange;\n\n    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances\n    IVault public immutable perpVault;\n\n    // PerpV2 contract which makes it possible to simulate a trade before it occurs\n    IQuoter public immutable perpQuoter;\n\n    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools\n    IMarketRegistry public immutable perpMarketRegistry;\n\n    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction\n    // during issuance/redemption. maxPerpPositionsPerSet is a safe limit set by governance taking Optimism\'s block gas limit into account.\n    uint256 public maxPerpPositionsPerSet;\n\n    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.\n    // Array is updated when new positions are opened or old positions are zeroed out.\n    mapping(ISetToken =&gt; address[]) internal positions;\n\n    / ============ Constructor ============ /\n\n    /\n     * @dev Sets external PerpV2 Protocol contract addresses. Sets collateralToken and collateralDecimals\n     * to the Perp vault\'s settlement token (USDC) and its decimals, respectively.\n     \n     * @param _controller               Address of controller contract\n     * @param _perpVault                Address of Perp Vault contract\n     * @param _perpQuoter               Address of Perp Quoter contract\n     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract\n     /\n    constructor(\n        IController _controller,\n        IVault _perpVault,\n        IQuoter _perpQuoter,\n        IMarketRegistry _perpMarketRegistry,\n        uint256 _maxPerpPositionsPerSet\n    )\n        public\n        ModuleBase(_controller)\n        SetTokenAccessible(_controller)\n    {\n        // Use temp variables to initialize immutables\n        address tempCollateralToken = _perpVault.getSettlementToken();\n        collateralToken = IERC20(tempCollateralToken);\n        collateralDecimals = ERC20(tempCollateralToken).decimals();\n\n        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());\n        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());\n        perpExchange = IExchange(_perpVault.getExchange());\n        perpVault = _perpVault;\n        perpQuoter = _perpQuoter;\n        perpMarketRegistry = _perpMarketRegistry;\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the\n     * allowed list or anySetAllowed needs to be true.\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     /\n    function initialize(\n        ISetToken _setToken\n    )\n        public\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n        onlyAllowedSet(_setToken)\n    {\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(\n            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),\n            "Issuance not initialized"\n        );\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {\n                // This module registered itself on modules[i] issuance module.\n            } catch {\n                // Try will fail if modules[i] is not an instance of IDebtIssuanceModule and does not\n                // implement the registerToIssuanceModule function, or if the registerToIssuanceModule\n                // function call reverted. Irrespective of the reason for failure, continue to the next module.\n            }\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.\n     * Providing a positive value for _baseQuantityUnits buys vToken on UniswapV3 via Perp\'s ClearingHouse,\n     * Providing a negative value sells the token. _quoteBoundQuantityUnits defines a min-receive-like slippage\n     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.\n     \n     * NOTE: This method doesn\'t update the externalPositionUnit because it is a function of UniswapV3 virtual\n     * token market prices and needs to be generated on the fly to be meaningful.\n     \n     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.\n     \n     * As a user when levering, e.g increasing the magnitude of your position, you\'d trade as below\n     * | ----------------------------------------------------------------------------------------------- |\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits |\n     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |\n     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |\n     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |\n     * | ----------------------------------------------------------------------------------------------- |\n     \n     * As a user when delevering by partially closing your position, you\'d trade as below\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when completely closing a position, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |\n     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _baseToken                    Address virtual token being traded\n     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units\n     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling\n     /\n    function trade(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteBoundQuantityUnits\n    )\n        public\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        ActionInfo memory actionInfo = _createAndValidateActionInfo(\n            _setToken,\n            _baseToken,\n            _baseQuantityUnits,\n            _quoteBoundQuantityUnits\n        );\n\n        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);\n\n        _updatePositionList(_setToken, _baseToken);\n\n        emit PerpTraded(\n            _setToken,\n            _baseToken,\n            deltaBase,\n            deltaQuote,\n            protocolFee,\n            actionInfo.isBuy\n        );\n    }\n\n    /\n     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing\n     * the size of the Perp account external position. This method is useful for establishing initial\n     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit\n     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference\n     * between these made up as automatically "issued" margin debt in the PerpV2 system.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units\n     /\n    function deposit(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");\n\n        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);\n\n        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);\n    }\n\n    /\n     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on\n     * the SetToken. This method is useful when adjusting the overall composition of a Set which has\n     * a Perp account external position as one of several components.\n     \n     * NOTE: Within PerpV2, withdraw settles owedRealizedPnl and any pending funding payments\n     * to the Perp vault prior to transfer.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units\n     */\n    function withdraw(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");\n\n        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);\n\n        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);\n    }\n\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes\n     * position mappings associated with SetToken.\n     \n     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.\n     /\n    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).\n        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.\n        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());\n        require(\n            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,\n            "Account balance exists"\n        );\n\n        // positions[setToken] mapping stores an array of addresses. The base token addresses are removed from the array when the\n        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should\n        // already be empty, and the mapping can be deleted directly.\n        delete positions[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     \n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then\n     * this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE\n     * during issue. Trades into current positions and sets the collateralToken\'s externalPositionUnit so that\n     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage\n     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current\n     * Set holders.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     /\n    function moduleIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        public\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);\n\n        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing\n     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the externalPositionUnit\n     * equal to the realizable value of account in position units (as measured by the trade outcomes for\n     * this redemption). Any owedRealizedPnl and pending funding payments are socialized in this step so\n     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     /\n    function moduleRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);\n\n        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits\n     * collateral into Perp protocol from SetToken default position.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to issue\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.\n            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());\n\n            _deposit(_setToken, usdcTransferInNotionalQuantity);\n        }\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws\n     * collateral from Perp protocol to SetToken default position without updating the default position unit.\n     * Called by issuance module\'s resolveEquityPositions method which immediately transfers the collateral\n     * component from SetToken to redeemer after this hook executes.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());\n\n            _withdraw(_setToken, usdcTransferOutNotionalQuantity);\n        }\n    }\n\n    / ============ External Setter Functions ============ /\n\n    /\n     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.\n     \n     * @param _maxPerpPositionsPerSet       New max perpetual positions per set\n     /\n    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * issuing a quantity of SetToken, representing the amount of collateral that would need to\n     * be transferred in per SetToken. Values in the returned arrays map to the same index in the\n     * SetToken\'s components array\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     /\n    function getIssuanceAdjustments(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        override\n        returns (int256[] memory, int256[] memory)\n    {\n        address[] memory components = _setToken.getComponents();\n\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.\n     * Values in the returned arrays map to the same index in the SetToken\'s components array.\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     */\n    function getRedemptionAdjustments(\n        ISetToken setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        returns (int256[] memory, int256[] memory )\n    {\n        address[] memory components = _setToken.getComponents();\n\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n\n    /\n     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     \n     *         + baseToken: address,\n     *         + baseBalance:  baseToken balance as notional quantity (1018)\n     *         + quoteBalance: USDC quote asset balance as notional quantity (1018)\n     /\n    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo;\n\n        for(uint i = 0; i &lt; positionLength; i++){\n            address baseToken = positionList[i];\n            positionInfo[i] = PositionNotionalInfo({\n                baseToken: baseToken,\n                baseBalance: perpAccountBalance.getBase(\n                    address(_setToken),\n                    baseToken\n                ),\n                quoteBalance: perpAccountBalance.getQuote(\n                    address(_setToken),\n                    baseToken\n                )\n            });\n        }\n\n        return positionInfo;\n    }\n\n    /\n     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     *\n     *         + baseToken: address,\n     *         + baseUnit:  baseToken balance as position unit (1018)\n     *         + quoteUnit: USDC quote asset balance as position unit (1018)\n     */\n    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionNotionalInfo.length;\n        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo;\n\n        for(uint i = 0; i &lt; positionLength; i++){\n            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];\n            positionUnitInfo[i] = PositionUnitInfo({\n                baseToken: currentPosition.baseToken,\n                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),\n                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)\n            });\n        }\n\n        return positionUnitInfo;\n    }\n\n\n    /\n     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide\n     * (rather than position specific) balance info\n     \n     * @param  _setToken            Instance of the SetToken\n     \n     * @return accountInfo          struct with properties for:\n     \n     *         + collateral balance (1018, regardless of underlying collateral decimals)\n     *         + owed realized Pnl(10**18)\n     *         + pending funding payments (10**18)\n     *         + net quote balance (10**18)\n     */\n    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {\n        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));\n\n        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"\n        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.\n        // We are flipping its sign here to reflect its settlement value.\n        accountInfo = AccountInfo({\n            collateralBalance: _getCollateralBalance(_setToken),\n            owedRealizedPnl: owedRealizedPnl,\n            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),\n            netQuoteBalance: _getNetQuoteBalance(_setToken)\n        });\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.\n     * This method implements the core logic to replicate positions during issuance and redemption. Syncs\n     * thepositionslist before starting (because positions may have liquidated). Cycles through\n     * each position, tradingbasePositionUnit * issueOrRedeemQuantityand calculates the amount of\n     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any\n     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders\n     * appropriately. The hook which invokes this method sets the SetToken\'s externalPositionUnit using\n     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module\n     * which reads this value.\n     *\n     * The general formula for determiningaccountValueper Set is:\n     *\n     *accountValue = collateral                                &lt;---\n     *               + owedRealizedPnl                               }   totalCollateralValue\n     *               + pendingFundingPayment                     &lt;---\n     *               + netQuoteBalance                           neg. when long, pos. when short\n     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short\n     \n     * (See docs for _calculatePartialAccountValuePositionUnit below for more detail about the\n     * account value components).\n     \n     * NOTE: On issuance, this hook is run BEFORE USDC is transferred in and deposited to the Perp\n     * vault to pay for the issuer\'s Sets. This trading temporarily spikes the Perp account\'s\n     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to\n     * a multiple of the current Perp account value (will vary depending on Set\'s leverage ratio).\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     * @param _isIssue              If true, invocation is for issuance, redemption otherwise\n     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)\n     * @return int256               Amount of collateral to transfer in/out in position units\n     /\n    function _executePositionTrades(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        bool _isIssue,\n        bool _isSimulation\n    )\n        internal\n        returns (int256)\n    {\n        _syncPositionList(_setToken);\n        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();\n\n        // Note: issued naming convention used here for brevity. This logic is also run on redemption\n        // and variable may refer to the value which will be redeemed.\n        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);\n\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n\n        for(uint i = 0; i &lt; positionLength; i++) {\n            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);\n\n            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,\n            // e.g selling base when long, buying base when short\n            ActionInfo memory actionInfo = _createActionInfoNotional(\n                _setToken,\n                positionInfo[i].baseToken,\n                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),\n                0\n            );\n\n            // Execute or simulate trade.\n            // deltaQuote is always a positive number\n            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);\n\n            // slippage is borne by the issuer\n            accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :\n                accountValueIssued.sub(deltaQuote.toInt256());\n        }\n\n        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the\n        // account could be bankrupt and we represent that as zero.\n        if (accountValueIssued &lt;= 0) {\n            return 0;\n        }\n\n        // Return value in collateral decimals (e.g USDC = 6)\n        // Use preciseDivCeil when issuing to ensure we don\'t under-collateralize due to rounding error\n        return (_isIssue)\n            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)\n            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);\n    }\n\n    /\n     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,\n     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,\n     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,\n     * and to which existing position values are added when calculating the externalPositionUnit.\n     \n     * @param _setToken             Instance of the SetToken\n     * @return accountValue         Partial account value in position units\n     /\n    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {\n        AccountInfo memory accountInfo = getAccountInfo(_setToken);\n\n        accountValue = accountInfo.collateralBalance\n            .add(accountInfo.owedRealizedPnl)\n            .add(accountInfo.pendingFundingPayments)\n            .add(accountInfo.netQuoteBalance)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n    }\n\n    /\n     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault\n     * Updates the collateral token default position unit. This function is called directly by\n     * the componentIssue hook, skipping external position unit setting because that method is assumed\n     * to be the end of a call sequence (e.g manager will not need to read the updated value)\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit\n     /\n    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        _setToken.invokeApprove(\n            address(collateralToken),\n            address(perpVault),\n            _collateralNotionalQuantity\n        );\n\n        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n\n    /\n     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit\n     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.\n     \n     * NOTE: This flow is only used when invoking the external deposit function - it converts collateral\n     * quantity units into a notional quantity.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit\n     * @return uint256                      Notional quantity deposited\n     /\n    function _depositAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n\n        _deposit(_setToken, collateralNotionalQuantity);\n\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n\n        return collateralNotionalQuantity;\n    }\n\n    /\n     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault\n     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,\n     * skipping position unit state updates because the funds withdrawn to SetToken are immediately\n     * forwarded to feeRecipient and SetToken owner respectively.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw\n     /\n    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        if (_collateralNotionalQuantity == 0) return;\n\n        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n\n    /\n     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken\n     * externalPositionUnit (so Manager contracts have a value they can base calculations for further\n     * trading on within the same transaction), and the collateral token default position unit.\n     \n     * NOTE: This flow is only used when invoking the external withdraw function - it converts\n     * a collateral units quantity into a notional quantity before invoking withdraw.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw\n     * @return uint256                      Notional quantity withdrawn\n     /\n    function _withdrawAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n\n        _withdraw(_setToken, collateralNotionalQuantity);\n\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n\n        return collateralNotionalQuantity;\n    }\n\n    /\n     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)\n     \n     * isBaseToQuote, isExactInput and oppositeAmountBound are configured as below:\n     * | ---------------------------------------------------|---------------------------- |\n     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |\n     * | ------- |-------- |--------|-----------------------|---------------------------- |\n     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |\n     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |\n     * |----------------------------------------------------|---------------------------- |\n     \n     * @param _actionInfo  ActionInfo object\n     * @return uint256     The base position delta resulting from the trade\n     * @return uint256     The quote asset position delta resulting from the trade\n     /\n    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n\n        // When isBaseToQuote is true, baseToken is being sold, when false, bought\n        // When isExactInput is true, amount is the swap input, when false, the swap output\n        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            oppositeAmountBound: _actionInfo.oppositeAmountBound,\n            deadline: PreciseUnitMath.maxUint256(),\n            sqrtPriceLimitX96: 0,\n            referralCode: bytes32(0)\n        });\n\n        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);\n    }\n\n\n    /\n     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)\n     \n     * See _executeTrade method comments for details about isBaseToQuote and isExactInput configuration.\n     \n     * @param _actionInfo   ActionInfo object\n     * @return uint256      The base position delta resulting from the trade\n     * @return uint256      The quote asset position delta resulting from the trade\n     */\n    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n        IQuoter.SwapParams memory params = IQuoter.SwapParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            sqrtPriceLimitX96: 0\n        });\n\n        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);\n        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);\n    }\n\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     \n     * @param  _setToken            Instance of SetToken\n     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)\n     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)\n     /\n    function _accrueProtocolFee(\n        ISetToken _setToken,\n        uint256 _exchangedQuantity\n    )\n        internal\n        returns(uint256)\n    {\n        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);\n\n        _withdraw(_setToken, protocolFeeInPreciseUnits);\n\n        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);\n\n        return protocolFeeInPreciseUnits;\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to\n     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If\n     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is\n     * only called from trade - the issue/redeem flow uses createActionInfoNotional directly.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _baseToken            Address of base token being traded into/out of\n     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits\n     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits\n     \n     * @return ActionInfo           Instance of constructed ActionInfo struct\n     */\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteReceiveUnits\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        require(_baseQuantityUnits != 0, "Amount is 0");\n        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");\n\n        uint256 totalSupply = _setToken.totalSupply();\n\n        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);\n        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());\n\n        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()\n            ? baseBalance.neg()         // To close position completely\n            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());\n\n        return _createActionInfoNotional(\n            _setToken,\n            _baseToken,\n            baseNotional,\n            _quoteReceiveUnits.preciseMul(totalSupply)\n        );\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates\n     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method\n     * is called during issue and redeem via _executePositionTrades and during trade via _createAndValidateActionInfo.\n     \n     * (See _executeTrade method comments for details about oppositeAmountBound configuration)\n     \n     * @param _setToken                 Instance of the SetToken\n     * @param _baseToken                Address of base token being traded into/out of\n     * @param _baseTokenQuantity        Notional quantity of baseToken to trade\n     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying\n     \n     * @return ActionInfo               Instance of constructed ActionInfo struct\n     /\n    function _createActionInfoNotional(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseTokenQuantity,\n        uint256 _quoteReceiveQuantity\n    )\n        internal\n        pure\n        returns(ActionInfo memory)\n    {\n        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called\n        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo\n        // that quantity is 0 for inputs to trade.\n        bool isBuy = _baseTokenQuantity &gt; 0;\n\n        return ActionInfo({\n            setToken: _setToken,\n            baseToken: _baseToken,\n            isBuy: isBuy,\n            baseTokenAmount: _baseTokenQuantity.abs(),\n            oppositeAmountBound: _quoteReceiveQuantity\n        });\n    }\n\n    /\n     * @dev Update position address array if a token has been newly added or completely sold off\n     * during lever/delever\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     /\n    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {\n        address[] memory positionList = positions[_setToken];\n        bool hasBaseToken = positionList.contains(_baseToken);\n\n        if (hasBaseToken) {\n            if(!_hasBaseBalance(_setToken, _baseToken)) {\n                positions[_setToken].removeStorage(_baseToken);\n            }\n        } else {\n            require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");\n            positions[_setToken].push(_baseToken);\n        }\n    }\n\n    /\n     * @dev Removes any zero balance positions from the positions array. This\n     * sync is done before issuance and redemption to account for positions that may have\n     * been liquidated.\n     \n     * @param _setToken         Instance of the SetToken\n     /\n    function _syncPositionList(ISetToken _setToken) internal {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            address currPosition = positionList[i];\n            if (!_hasBaseBalance(_setToken, currPosition)) {\n                positions[_setToken].removeStorage(currPosition);\n            }\n        }\n    }\n\n    /\n     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have\n     * no balance and return false\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     * @return bool         True if a non-dust base token balance exists, false otherwise\n     /\n    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {\n        int256 baseBalanceUnit = perpAccountBalance\n            .getBase(address(_setToken), _baseToken)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n\n        return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1);\n    }\n\n    /\n     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol\n     \n     * @param  _baseToken           Address of virtual token to price\n     * @return price                Mid-point price of virtual token in UniswapV3 AMM market\n     /\n    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {\n        address pool = perpMarketRegistry.getPool(_baseToken);\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();\n        return priceX96.formatX96ToX10_18();\n    }\n\n    /\n     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per\n     * SetToken\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       External position unit\n     /\n    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalPositionValue = 0;\n\n        for (uint i = 0; i &lt; positionLength; i++ ) {\n            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();\n            totalPositionValue = totalPositionValue.add(\n                positionInfo[i].baseBalance.preciseMul(spotPrice)\n            );\n        }\n\n        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)\n            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));\n\n        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);\n    }\n\n    /\n     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       Collateral balance as an 18 decimal vUSDC quote value\n     /\n    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {\n        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);\n    }\n\n    /\n     * @dev Retrieves net quote balance of all open positions\n     \n     * @param _setToken             Instance of SetToken\n     * @return netQuoteBalance      Net quote balance of all open positions\n     /\n    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            netQuoteBalance = netQuoteBalance.add(\n                perpAccountBalance.getQuote(address(_setToken), positionList[i])\n            );\n        }\n    }\n\n    /\n     * @dev Returns issuance or redemption adjustments in the format expected by SlippageIssuanceModule.\n     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated\n     * externalPositionUnit (new) and set in an equityAdjustments array which is the same length as\n     * the SetToken\'s components array, at the same index the collateral token occupies in the components\n     * array. All other values are left unset (0). An empty-value components length debtAdjustments\n     * array is also returned.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _components                       Array of components held by the SetToken\n     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit\n     * @return int256[]                         Components-length array with equity adjustment value at appropriate index\n     * @return int256[]                         Components-length array of zeroes (debt adjustments)\n     /\n    function _formatAdjustments(\n        ISetToken _setToken,\n        address[] memory _components,\n        int256 _newExternalPositionUnit\n    )\n        internal\n        view\n        returns (int256[] memory, int256[] memory)\n    {\n        int256[] memory equityAdjustments = new int256;\n        int256[] memory debtAdjustments = new int256;\n\n        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));\n\n        if (isIn) {\n            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(\n                address(collateralToken),\n                address(this)\n            );\n\n            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);\n        }\n\n        return (equityAdjustments, debtAdjustments);\n    }\n}'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:27:46 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:27:46 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "/*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 05:27:50 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:27:50 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 26504
completion_tokens: 1
total_tokens: 26505
cost: $-1.000000


[2024-01-09 05:27:50 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Let's

[2024-01-09 05:27:52 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: /\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\nimport "@openzeppelin/contracts/math/SignedSafeMath.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";\nimport { PerpV2 } from "../integration/lib/PerpV2.sol";\nimport { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";\nimport { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";\nimport { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";\nimport { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";\nimport { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";\nimport { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";\nimport { IVault } from "../../interfaces/external/perp-v2/IVault.sol";\nimport { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";\nimport { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";\nimport { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";\n/\n * @title PerpV2LeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account\n * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token\n * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of\n * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.\n \n * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit\n * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.\n * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the\n * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.\n \n * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current\n * value of the Set\'s perpetual position. The current value can be calculated from getPositionNotionalInfo.\n /\ncontract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {\n    using PerpV2 for ISetToken;\n    using PreciseUnitMath for int256;\n    using SignedSafeMath for int256;\n    using UnitConversionUtils for int256;\n    using UniswapV3Math for uint160;\n    using UniswapV3Math for uint256;\n    using UnitConversionUtils for uint256;\n    using AddressArrayUtils for address[];\n    / ============ Structs ============ */\n    struct ActionInfo {\n        ISetToken setToken;\n        address baseToken;              // Virtual token minted by the Perp protocol\n        bool isBuy;                     // When true, baseToken is being bought, when false, sold\n        uint256 baseTokenAmount;        // Base token quantity in 1018 decimals\n        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see _createActionInfoNotional for details)\n    }\n    struct PositionNotionalInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseBalance;             // Base position notional quantity in 1018 decimals. When negative, position is short\n        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short\n    }\n    struct PositionUnitInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseUnit;                // Base position unit. When negative, position is short\n        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short\n    }\n    // Note: when pendingFundingPayments is positive it will be credited to account on settlement,\n    // when negative it\'s a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value\n    // with the opposite meaning, e.g positively signed payments are owed by account to system).\n    struct AccountInfo {\n        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 1018 decimals\n        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 1018 decimals not yet settled to vault\n        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 1018 decimals\n        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account\n    }\n    / ============ Events ============ /\n    /\n     * @dev Emitted on trade\n     * @param _setToken         Instance of SetToken\n     * @param _baseToken        Virtual token minted by the Perp protocol\n     * @param _deltaBase        Change in baseToken position size resulting from trade\n     * @param _deltaQuote       Change in vUSDC position size resulting from trade\n     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade\n     * @param _isBuy            True when baseToken is being bought, false when being sold\n     */\n    event PerpTraded(\n        ISetToken indexed _setToken,\n        address indexed _baseToken,\n        uint256 indexed _deltaBase,\n        uint256 _deltaQuote,\n        uint256 _protocolFee,\n        bool _isBuy\n    );\n    /\n     * @dev Emitted on deposit (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being deposited as collateral (USDC)\n     * @param _amountDeposited      Amount of collateral being deposited into Perp\n     /\n    event CollateralDeposited(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountDeposited\n    );\n    /\n     * @dev Emitted on withdraw (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being withdrawn as collateral (USDC)\n     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp\n     /\n    event CollateralWithdrawn(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountWithdrawn\n    );\n    / ============ Constants ============ /\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n    / ============ State Variables ============ /\n    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it\'s settlement and collateral token\n    IERC20 public immutable collateralToken;\n    // Decimals of collateral token. We set this in the constructor for later reading\n    uint8 internal immutable collateralDecimals;\n    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances\n    IAccountBalance public immutable perpAccountBalance;\n    // PerpV2 contract which provides a trading API\n    IClearingHouse public immutable perpClearingHouse;\n    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances\n    IExchange public immutable perpExchange;\n    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances\n    IVault public immutable perpVault;\n    // PerpV2 contract which makes it possible to simulate a trade before it occurs\n    IQuoter public immutable perpQuoter;\n    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools\n    IMarketRegistry public immutable perpMarketRegistry;\n    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction\n    // during issuance/redemption. maxPerpPositionsPerSet is a safe limit set by governance taking Optimism\'s block gas limit into account.\n    uint256 public maxPerpPositionsPerSet;\n    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.\n    // Array is updated when new positions are opened or old positions are zeroed out.\n    mapping(ISetToken =&gt; address[]) internal positions;\n    / ============ Constructor ============ /\n    /\n     * @dev Sets external PerpV2 Protocol contract addresses. Sets collateralToken and collateralDecimals\n     * to the Perp vault\'s settlement token (USDC) and its decimals, respectively.\n     \n     * @param _controller               Address of controller contract\n     * @param _perpVault                Address of Perp Vault contract\n     * @param _perpQuoter               Address of Perp Quoter contract\n     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract\n     /\n    constructor(\n        IController _controller,\n        IVault _perpVault,\n        IQuoter _perpQuoter,\n        IMarketRegistry _perpMarketRegistry,\n        uint256 _maxPerpPositionsPerSet\n    )\n        public\n        ModuleBase(_controller)\n        SetTokenAccessible(_controller)\n    {\n        // Use temp variables to initialize immutables\n        address tempCollateralToken = _perpVault.getSettlementToken();\n        collateralToken = IERC20(tempCollateralToken);\n        collateralDecimals = ERC20(tempCollateralToken).decimals();\n        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());\n        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());\n        perpExchange = IExchange(_perpVault.getExchange());\n        perpVault = _perpVault;\n        perpQuoter = _perpQuoter;\n        perpMarketRegistry = _perpMarketRegistry;\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n    / ============ External Functions ============ /\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the\n     * allowed list or anySetAllowed needs to be true.\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     /\n    function initialize(\n        ISetToken _setToken\n    )\n        public\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n        onlyAllowedSet(_setToken)\n    {\n        // Initialize module before trying register\n        _setToken.initializeModule();\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(\n            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),\n            "Issuance not initialized"\n        );\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {\n                // This module registered itself on modules[i] issuance module.\n            } catch {\n                // Try will fail if modules[i] is not an instance of IDebtIssuanceModule and does not\n                // implement the registerToIssuanceModule function, or if the registerToIssuanceModule\n                // function call reverted. Irrespective of the reason for failure, continue to the next module.\n            }\n        }\n    }\n    /\n     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.\n     * Providing a positive value for _baseQuantityUnits buys vToken on UniswapV3 via Perp\'s ClearingHouse,\n     * Providing a negative value sells the token. _quoteBoundQuantityUnits defines a min-receive-like slippage\n     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.\n     \n     * NOTE: This method doesn\'t update the externalPositionUnit because it is a function of UniswapV3 virtual\n     * token market prices and needs to be generated on the fly to be meaningful.\n     \n     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.\n     \n     * As a user when levering, e.g increasing the magnitude of your position, you\'d trade as below\n     * | ----------------------------------------------------------------------------------------------- |\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits |\n     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |\n     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |\n     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |\n     * | ----------------------------------------------------------------------------------------------- |\n     \n     * As a user when delevering by partially closing your position, you\'d trade as below\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when completely closing a position, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |\n     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _baseToken                    Address virtual token being traded\n     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units\n     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling\n     /\n    function trade(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteBoundQuantityUnits\n    )\n        public\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        ActionInfo memory actionInfo = _createAndValidateActionInfo(\n            _setToken,\n            _baseToken,\n            _baseQuantityUnits,\n            _quoteBoundQuantityUnits\n        );\n        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);\n        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);\n        _updatePositionList(_setToken, _baseToken);\n        emit PerpTraded(\n            _setToken,\n            _baseToken,\n            deltaBase,\n            deltaQuote,\n            protocolFee,\n            actionInfo.isBuy\n        );\n    }\n    /\n     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing\n     * the size of the Perp account external position. This method is useful for establishing initial\n     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit\n     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference\n     * between these made up as automatically "issued" margin debt in the PerpV2 system.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units\n     /\n    function deposit(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");\n        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);\n        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);\n    }\n    /\n     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on\n     * the SetToken. This method is useful when adjusting the overall composition of a Set which has\n     * a Perp account external position as one of several components.\n     \n     * NOTE: Within PerpV2, withdraw settles owedRealizedPnl and any pending funding payments\n     * to the Perp vault prior to transfer.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units\n     */\n    function withdraw(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");\n        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);\n        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);\n    }\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes\n     * position mappings associated with SetToken.\n     \n     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.\n     /\n    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).\n        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.\n        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());\n        require(\n            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,\n            "Account balance exists"\n        );\n        // positions[setToken] mapping stores an array of addresses. The base token addresses are removed from the array when the\n        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should\n        // already be empty, and the mapping can be deleted directly.\n        delete positions[setToken];\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     \n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then\n     * this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE\n     * during issue. Trades into current positions and sets the collateralToken\'s externalPositionUnit so that\n     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage\n     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current\n     * Set holders.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     /\n    function moduleIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        public\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);\n        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing\n     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the externalPositionUnit\n     * equal to the realizable value of account in position units (as measured by the trade outcomes for\n     * this redemption). Any owedRealizedPnl and pending funding payments are socialized in this step so\n     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     /\n    function moduleRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);\n        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits\n     * collateral into Perp protocol from SetToken default position.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to issue\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.\n            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());\n            _deposit(_setToken, usdcTransferInNotionalQuantity);\n        }\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws\n     * collateral from Perp protocol to SetToken default position without updating the default position unit.\n     * Called by issuance module\'s resolveEquityPositions method which immediately transfers the collateral\n     * component from SetToken to redeemer after this hook executes.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());\n            _withdraw(_setToken, usdcTransferOutNotionalQuantity);\n        }\n    }\n    / ============ External Setter Functions ============ /\n    /\n     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.\n     \n     * @param _maxPerpPositionsPerSet       New max perpetual positions per set\n     /\n    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n    / ============ External Getter Functions ============ /\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * issuing a quantity of SetToken, representing the amount of collateral that would need to\n     * be transferred in per SetToken. Values in the returned arrays map to the same index in the\n     * SetToken\'s components array\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     /\n    function getIssuanceAdjustments(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        override\n        returns (int256[] memory, int256[] memory)\n    {\n        address[] memory components = _setToken.getComponents();\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.\n     * Values in the returned arrays map to the same index in the SetToken\'s components array.\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     */\n    function getRedemptionAdjustments(\n        ISetToken setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        returns (int256[] memory, int256[] memory )\n    {\n        address[] memory components = _setToken.getComponents();\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n    /\n     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     \n     *         + baseToken: address,\n     *         + baseBalance:  baseToken balance as notional quantity (1018)\n     *         + quoteBalance: USDC quote asset balance as notional quantity (1018)\n     /\n    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo;\n        for(uint i = 0; i &lt; positionLength; i++){\n            address baseToken = positionList[i];\n            positionInfo[i] = PositionNotionalInfo({\n                baseToken: baseToken,\n                baseBalance: perpAccountBalance.getBase(\n                    address(_setToken),\n                    baseToken\n                ),\n                quoteBalance: perpAccountBalance.getQuote(\n                    address(_setToken),\n                    baseToken\n                )\n            });\n        }\n        return positionInfo;\n    }\n    /\n     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     *\n     *         + baseToken: address,\n     *         + baseUnit:  baseToken balance as position unit (1018)\n     *         + quoteUnit: USDC quote asset balance as position unit (1018)\n     */\n    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionNotionalInfo.length;\n        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo;\n        for(uint i = 0; i &lt; positionLength; i++){\n            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];\n            positionUnitInfo[i] = PositionUnitInfo({\n                baseToken: currentPosition.baseToken,\n                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),\n                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)\n            });\n        }\n        return positionUnitInfo;\n    }\n\n    /\n     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide\n     * (rather than position specific) balance info\n     \n     * @param  _setToken            Instance of the SetToken\n     \n     * @return accountInfo          struct with properties for:\n     \n     *         + collateral balance (1018, regardless of underlying collateral decimals)\n     *         + owed realized Pnl(10**18)\n     *         + pending funding payments (10**18)\n     *         + net quote balance (10**18)\n     */\n    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {\n        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));\n        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"\n        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.\n        // We are flipping its sign here to reflect its settlement value.\n        accountInfo = AccountInfo({\n            collateralBalance: _getCollateralBalance(_setToken),\n            owedRealizedPnl: owedRealizedPnl,\n            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),\n            netQuoteBalance: _getNetQuoteBalance(_setToken)\n        });\n    }\n    /* ============ Internal Functions ============ */\n    /**\n     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.\n     * This method implements the core logic to replicate positions during issuance and redemption. Syncs\n     * thepositionslist before starting (because positions may have liquidated). Cycles through\n     * each position, tradingbasePositionUnit * issueOrRedeemQuantityand calculates the amount of\n     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any\n     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders\n     * appropriately. The hook which invokes this method sets the SetToken\'s externalPositionUnit using\n     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module\n     * which reads this value.\n     *\n     * The general formula for determiningaccountValueper Set is:\n     *\n     *accountValue = collateral                                &lt;---\n     *               + owedRealizedPnl                               }   totalCollateralValue\n     *               + pendingFundingPayment                     &lt;---\n     *               + netQuoteBalance                           neg. when long, pos. when short\n     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short\n     \n     * (See docs for _calculatePartialAccountValuePositionUnit below for more detail about the\n     * account value components).\n     \n     * NOTE: On issuance, this hook is run BEFORE USDC is transferred in and deposited to the Perp\n     * vault to pay for the issuer\'s Sets. This trading temporarily spikes the Perp account\'s\n     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to\n     * a multiple of the current Perp account value (will vary depending on Set\'s leverage ratio).\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     * @param _isIssue              If true, invocation is for issuance, redemption otherwise\n     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)\n     * @return int256               Amount of collateral to transfer in/out in position units\n     /\n    function _executePositionTrades(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        bool _isIssue,\n        bool _isSimulation\n    )\n        internal\n        returns (int256)\n    {\n        _syncPositionList(_setToken);\n        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();\n        // Note: issued naming convention used here for brevity. This logic is also run on redemption\n        // and variable may refer to the value which will be redeemed.\n        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n        for(uint i = 0; i &lt; positionLength; i++) {\n            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);\n            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,\n            // e.g selling base when long, buying base when short\n            ActionInfo memory actionInfo = _createActionInfoNotional(\n                _setToken,\n                positionInfo[i].baseToken,\n                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),\n                0\n            );\n            // Execute or simulate trade.\n            // deltaQuote is always a positive number\n            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);\n            // slippage is borne by the issuer\n            accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :\n                accountValueIssued.sub(deltaQuote.toInt256());\n        }\n        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the\n        // account could be bankrupt and we represent that as zero.\n        if (accountValueIssued &lt;= 0) {\n            return 0;\n        }\n        // Return value in collateral decimals (e.g USDC = 6)\n        // Use preciseDivCeil when issuing to ensure we don\'t under-collateralize due to rounding error\n        return (_isIssue)\n            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)\n            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);\n    }\n    /\n     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,\n     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,\n     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,\n     * and to which existing position values are added when calculating the externalPositionUnit.\n     \n     * @param _setToken             Instance of the SetToken\n     * @return accountValue         Partial account value in position units\n     /\n    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {\n        AccountInfo memory accountInfo = getAccountInfo(_setToken);\n        accountValue = accountInfo.collateralBalance\n            .add(accountInfo.owedRealizedPnl)\n            .add(accountInfo.pendingFundingPayments)\n            .add(accountInfo.netQuoteBalance)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n    }\n    /\n     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault\n     * Updates the collateral token default position unit. This function is called directly by\n     * the componentIssue hook, skipping external position unit setting because that method is assumed\n     * to be the end of a call sequence (e.g manager will not need to read the updated value)\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit\n     /\n    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        _setToken.invokeApprove(\n            address(collateralToken),\n            address(perpVault),\n            _collateralNotionalQuantity\n        );\n        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n    /\n     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit\n     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.\n     \n     * NOTE: This flow is only used when invoking the external deposit function - it converts collateral\n     * quantity units into a notional quantity.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit\n     * @return uint256                      Notional quantity deposited\n     /\n    function _depositAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n        _deposit(_setToken, collateralNotionalQuantity);\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n        return collateralNotionalQuantity;\n    }\n    /\n     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault\n     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,\n     * skipping position unit state updates because the funds withdrawn to SetToken are immediately\n     * forwarded to feeRecipient and SetToken owner respectively.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw\n     /\n    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        if (_collateralNotionalQuantity == 0) return;\n        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n    /\n     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken\n     * externalPositionUnit (so Manager contracts have a value they can base calculations for further\n     * trading on within the same transaction), and the collateral token default position unit.\n     \n     * NOTE: This flow is only used when invoking the external withdraw function - it converts\n     * a collateral units quantity into a notional quantity before invoking withdraw.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw\n     * @return uint256                      Notional quantity withdrawn\n     /\n    function _withdrawAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n        _withdraw(_setToken, collateralNotionalQuantity);\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n        return collateralNotionalQuantity;\n    }\n    /\n     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)\n     \n     * isBaseToQuote, isExactInput and oppositeAmountBound are configured as below:\n     * | ---------------------------------------------------|---------------------------- |\n     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |\n     * | ------- |-------- |--------|-----------------------|---------------------------- |\n     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |\n     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |\n     * |----------------------------------------------------|---------------------------- |\n     \n     * @param _actionInfo  ActionInfo object\n     * @return uint256     The base position delta resulting from the trade\n     * @return uint256     The quote asset position delta resulting from the trade\n     /\n    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n        // When isBaseToQuote is true, baseToken is being sold, when false, bought\n        // When isExactInput is true, amount is the swap input, when false, the swap output\n        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            oppositeAmountBound: _actionInfo.oppositeAmountBound,\n            deadline: PreciseUnitMath.maxUint256(),\n            sqrtPriceLimitX96: 0,\n            referralCode: bytes32(0)\n        });\n        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);\n    }\n\n    /\n     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)\n     \n     * See _executeTrade method comments for details about isBaseToQuote and isExactInput configuration.\n     \n     * @param _actionInfo   ActionInfo object\n     * @return uint256      The base position delta resulting from the trade\n     * @return uint256      The quote asset position delta resulting from the trade\n     */\n    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n        IQuoter.SwapParams memory params = IQuoter.SwapParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            sqrtPriceLimitX96: 0\n        });\n        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);\n        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);\n    }\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     \n     * @param  _setToken            Instance of SetToken\n     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)\n     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)\n     /\n    function _accrueProtocolFee(\n        ISetToken _setToken,\n        uint256 _exchangedQuantity\n    )\n        internal\n        returns(uint256)\n    {\n        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);\n        _withdraw(_setToken, protocolFeeInPreciseUnits);\n        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);\n        return protocolFeeInPreciseUnits;\n    }\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to\n     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If\n     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is\n     * only called from trade - the issue/redeem flow uses createActionInfoNotional directly.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _baseToken            Address of base token being traded into/out of\n     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits\n     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits\n     \n     * @return ActionInfo           Instance of constructed ActionInfo struct\n     */\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteReceiveUnits\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        require(_baseQuantityUnits != 0, "Amount is 0");\n        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");\n        uint256 totalSupply = _setToken.totalSupply();\n        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);\n        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());\n        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()\n            ? baseBalance.neg()         // To close position completely\n            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());\n        return _createActionInfoNotional(\n            _setToken,\n            _baseToken,\n            baseNotional,\n            _quoteReceiveUnits.preciseMul(totalSupply)\n        );\n    }\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates\n     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method\n     * is called during issue and redeem via _executePositionTrades and during trade via _createAndValidateActionInfo.\n     \n     * (See _executeTrade method comments for details about oppositeAmountBound configuration)\n     \n     * @param _setToken                 Instance of the SetToken\n     * @param _baseToken                Address of base token being traded into/out of\n     * @param _baseTokenQuantity        Notional quantity of baseToken to trade\n     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying\n     \n     * @return ActionInfo               Instance of constructed ActionInfo struct\n     /\n    function _createActionInfoNotional(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseTokenQuantity,\n        uint256 _quoteReceiveQuantity\n    )\n        internal\n        pure\n        returns(ActionInfo memory)\n    {\n        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called\n        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo\n        // that quantity is 0 for inputs to trade.\n        bool isBuy = _baseTokenQuantity &gt; 0;\n        return ActionInfo({\n            setToken: _setToken,\n            baseToken: _baseToken,\n            isBuy: isBuy,\n            baseTokenAmount: _baseTokenQuantity.abs(),\n            oppositeAmountBound: _quoteReceiveQuantity\n        });\n    }\n    /\n     * @dev Update position address array if a token has been newly added or completely sold off\n     * during lever/delever\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     /\n    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {\n        address[] memory positionList = positions[_setToken];\n        bool hasBaseToken = positionList.contains(_baseToken);\n        if (hasBaseToken) {\n            if(!_hasBaseBalance(_setToken, _baseToken)) {\n                positions[_setToken].removeStorage(_baseToken);\n            }\n        } else {\n            require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");\n            positions[_setToken].push(_baseToken);\n        }\n    }\n    /\n     * @dev Removes any zero balance positions from the positions array. This\n     * sync is done before issuance and redemption to account for positions that may have\n     * been liquidated.\n     \n     * @param _setToken         Instance of the SetToken\n     /\n    function _syncPositionList(ISetToken _setToken) internal {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            address currPosition = positionList[i];\n            if (!_hasBaseBalance(_setToken, currPosition)) {\n                positions[_setToken].removeStorage(currPosition);\n            }\n        }\n    }\n    /\n     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have\n     * no balance and return false\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     * @return bool         True if a non-dust base token balance exists, false otherwise\n     /\n    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {\n        int256 baseBalanceUnit = perpAccountBalance\n            .getBase(address(_setToken), _baseToken)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n        return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1);\n    }\n    /\n     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol\n     \n     * @param  _baseToken           Address of virtual token to price\n     * @return price                Mid-point price of virtual token in UniswapV3 AMM market\n     /\n    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {\n        address pool = perpMarketRegistry.getPool(_baseToken);\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();\n        return priceX96.formatX96ToX10_18();\n    }\n    /\n     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per\n     * SetToken\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       External position unit\n     /\n    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalPositionValue = 0;\n        for (uint i = 0; i &lt; positionLength; i++ ) {\n            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();\n            totalPositionValue = totalPositionValue.add(\n                positionInfo[i].baseBalance.preciseMul(spotPrice)\n            );\n        }\n        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)\n            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));\n        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);\n    }\n    /\n     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       Collateral balance as an 18 decimal vUSDC quote value\n     /\n    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {\n        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);\n    }\n    /\n     * @dev Retrieves net quote balance of all open positions\n     \n     * @param _setToken             Instance of SetToken\n     * @return netQuoteBalance      Net quote balance of all open positions\n     /\n    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            netQuoteBalance = netQuoteBalance.add(\n                perpAccountBalance.getQuote(address(_setToken), positionList[i])\n            );\n        }\n    }\n    /\n     * @dev Returns issuance or redemption adjustments in the format expected by SlippageIssuanceModule.\n     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated\n     * externalPositionUnit (new) and set in an equityAdjustments array which is the same length as\n     * the SetToken\'s components array, at the same index the collateral token occupies in the components\n     * array. All other values are left unset (0). An empty-value components length debtAdjustments\n     * array is also returned.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _components                       Array of components held by the SetToken\n     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit\n     * @return int256[]                         Components-length array with equity adjustment value at appropriate index\n     * @return int256[]                         Components-length array of zeroes (debt adjustments)\n     /\n    function _formatAdjustments(\n        ISetToken _setToken,\n        address[] memory _components,\n        int256 _newExternalPositionUnit\n    )\n        internal\n        view\n        returns (int256[] memory, int256[] memory)\n    {\n        int256[] memory equityAdjustments = new int256;\n        int256[] memory debtAdjustments = new int256;\n        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));\n        if (isIn) {\n            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(\n                address(collateralToken),\n                address(this)\n            );\n            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);\n        }\n        return (equityAdjustments, debtAdjustments);\n    }\n}.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "/\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\nimport "@openzeppelin/contracts/math/SignedSafeMath.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";\nimport { PerpV2 } from "../integration/lib/PerpV2.sol";\nimport { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";\nimport { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";\nimport { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";\nimport { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";\nimport { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";\nimport { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";\nimport { IVault } from "../../interfaces/external/perp-v2/IVault.sol";\nimport { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";\nimport { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";\nimport { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";\n/\n * @title PerpV2LeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account\n * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token\n * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of\n * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.\n \n * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit\n * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.\n * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the\n * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.\n \n * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current\n * value of the Set\'s perpetual position. The current value can be calculated from getPositionNotionalInfo.\n /\ncontract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {\n    using PerpV2 for ISetToken;\n    using PreciseUnitMath for int256;\n    using SignedSafeMath for int256;\n    using UnitConversionUtils for int256;\n    using UniswapV3Math for uint160;\n    using UniswapV3Math for uint256;\n    using UnitConversionUtils for uint256;\n    using AddressArrayUtils for address[];\n    / ============ Structs ============ */\n    struct ActionInfo {\n        ISetToken setToken;\n        address baseToken;              // Virtual token minted by the Perp protocol\n        bool isBuy;                     // When true, baseToken is being bought, when false, sold\n        uint256 baseTokenAmount;        // Base token quantity in 1018 decimals\n        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see _createActionInfoNotional for details)\n    }\n    struct PositionNotionalInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseBalance;             // Base position notional quantity in 1018 decimals. When negative, position is short\n        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short\n    }\n    struct PositionUnitInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseUnit;                // Base position unit. When negative, position is short\n        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short\n    }\n    // Note: when pendingFundingPayments is positive it will be credited to account on settlement,\n    // when negative it\'s a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value\n    // with the opposite meaning, e.g positively signed payments are owed by account to system).\n    struct AccountInfo {\n        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 1018 decimals\n        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 1018 decimals not yet settled to vault\n        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 1018 decimals\n        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account\n    }\n    / ============ Events ============ /\n    /\n     * @dev Emitted on trade\n     * @param _setToken         Instance of SetToken\n     * @param _baseToken        Virtual token minted by the Perp protocol\n     * @param _deltaBase        Change in baseToken position size resulting from trade\n     * @param _deltaQuote       Change in vUSDC position size resulting from trade\n     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade\n     * @param _isBuy            True when baseToken is being bought, false when being sold\n     */\n    event PerpTraded(\n        ISetToken indexed _setToken,\n        address indexed _baseToken,\n        uint256 indexed _deltaBase,\n        uint256 _deltaQuote,\n        uint256 _protocolFee,\n        bool _isBuy\n    );\n    /\n     * @dev Emitted on deposit (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being deposited as collateral (USDC)\n     * @param _amountDeposited      Amount of collateral being deposited into Perp\n     /\n    event CollateralDeposited(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountDeposited\n    );\n    /\n     * @dev Emitted on withdraw (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being withdrawn as collateral (USDC)\n     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp\n     /\n    event CollateralWithdrawn(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountWithdrawn\n    );\n    / ============ Constants ============ /\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n    / ============ State Variables ============ /\n    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it\'s settlement and collateral token\n    IERC20 public immutable collateralToken;\n    // Decimals of collateral token. We set this in the constructor for later reading\n    uint8 internal immutable collateralDecimals;\n    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances\n    IAccountBalance public immutable perpAccountBalance;\n    // PerpV2 contract which provides a trading API\n    IClearingHouse public immutable perpClearingHouse;\n    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances\n    IExchange public immutable perpExchange;\n    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances\n    IVault public immutable perpVault;\n    // PerpV2 contract which makes it possible to simulate a trade before it occurs\n    IQuoter public immutable perpQuoter;\n    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools\n    IMarketRegistry public immutable perpMarketRegistry;\n    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction\n    // during issuance/redemption. maxPerpPositionsPerSet is a safe limit set by governance taking Optimism\'s block gas limit into account.\n    uint256 public maxPerpPositionsPerSet;\n    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.\n    // Array is updated when new positions are opened or old positions are zeroed out.\n    mapping(ISetToken =&gt; address[]) internal positions;\n    / ============ Constructor ============ /\n    /\n     * @dev Sets external PerpV2 Protocol contract addresses. Sets collateralToken and collateralDecimals\n     * to the Perp vault\'s settlement token (USDC) and its decimals, respectively.\n     \n     * @param _controller               Address of controller contract\n     * @param _perpVault                Address of Perp Vault contract\n     * @param _perpQuoter               Address of Perp Quoter contract\n     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract\n     /\n    constructor(\n        IController _controller,\n        IVault _perpVault,\n        IQuoter _perpQuoter,\n        IMarketRegistry _perpMarketRegistry,\n        uint256 _maxPerpPositionsPerSet\n    )\n        public\n        ModuleBase(_controller)\n        SetTokenAccessible(_controller)\n    {\n        // Use temp variables to initialize immutables\n        address tempCollateralToken = _perpVault.getSettlementToken();\n        collateralToken = IERC20(tempCollateralToken);\n        collateralDecimals = ERC20(tempCollateralToken).decimals();\n        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());\n        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());\n        perpExchange = IExchange(_perpVault.getExchange());\n        perpVault = _perpVault;\n        perpQuoter = _perpQuoter;\n        perpMarketRegistry = _perpMarketRegistry;\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n    / ============ External Functions ============ /\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the\n     * allowed list or anySetAllowed needs to be true.\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     /\n    function initialize(\n        ISetToken _setToken\n    )\n        public\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n        onlyAllowedSet(_setToken)\n    {\n        // Initialize module before trying register\n        _setToken.initializeModule();\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(\n            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),\n            "Issuance not initialized"\n        );\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {\n                // This module registered itself on modules[i] issuance module.\n            } catch {\n                // Try will fail if modules[i] is not an instance of IDebtIssuanceModule and does not\n                // implement the registerToIssuanceModule function, or if the registerToIssuanceModule\n                // function call reverted. Irrespective of the reason for failure, continue to the next module.\n            }\n        }\n    }\n    /\n     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.\n     * Providing a positive value for _baseQuantityUnits buys vToken on UniswapV3 via Perp\'s ClearingHouse,\n     * Providing a negative value sells the token. _quoteBoundQuantityUnits defines a min-receive-like slippage\n     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.\n     \n     * NOTE: This method doesn\'t update the externalPositionUnit because it is a function of UniswapV3 virtual\n     * token market prices and needs to be generated on the fly to be meaningful.\n     \n     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.\n     \n     * As a user when levering, e.g increasing the magnitude of your position, you\'d trade as below\n     * | ----------------------------------------------------------------------------------------------- |\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits |\n     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |\n     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |\n     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |\n     * | ----------------------------------------------------------------------------------------------- |\n     \n     * As a user when delevering by partially closing your position, you\'d trade as below\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when completely closing a position, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |\n     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _baseToken                    Address virtual token being traded\n     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units\n     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling\n     /\n    function trade(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteBoundQuantityUnits\n    )\n        public\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        ActionInfo memory actionInfo = _createAndValidateActionInfo(\n            _setToken,\n            _baseToken,\n            _baseQuantityUnits,\n            _quoteBoundQuantityUnits\n        );\n        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);\n        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);\n        _updatePositionList(_setToken, _baseToken);\n        emit PerpTraded(\n            _setToken,\n            _baseToken,\n            deltaBase,\n            deltaQuote,\n            protocolFee,\n            actionInfo.isBuy\n        );\n    }\n    /\n     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing\n     * the size of the Perp account external position. This method is useful for establishing initial\n     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit\n     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference\n     * between these made up as automatically "issued" margin debt in the PerpV2 system.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units\n     /\n    function deposit(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");\n        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);\n        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);\n    }\n    /\n     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on\n     * the SetToken. This method is useful when adjusting the overall composition of a Set which has\n     * a Perp account external position as one of several components.\n     \n     * NOTE: Within PerpV2, withdraw settles owedRealizedPnl and any pending funding payments\n     * to the Perp vault prior to transfer.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units\n     */\n    function withdraw(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");\n        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);\n        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);\n    }\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes\n     * position mappings associated with SetToken.\n     \n     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.\n     /\n    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).\n        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.\n        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());\n        require(\n            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,\n            "Account balance exists"\n        );\n        // positions[setToken] mapping stores an array of addresses. The base token addresses are removed from the array when the\n        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should\n        // already be empty, and the mapping can be deleted directly.\n        delete positions[setToken];\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     \n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then\n     * this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE\n     * during issue. Trades into current positions and sets the collateralToken\'s externalPositionUnit so that\n     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage\n     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current\n     * Set holders.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     /\n    function moduleIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        public\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);\n        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing\n     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the externalPositionUnit\n     * equal to the realizable value of account in position units (as measured by the trade outcomes for\n     * this redemption). Any owedRealizedPnl and pending funding payments are socialized in this step so\n     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     /\n    function moduleRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);\n        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits\n     * collateral into Perp protocol from SetToken default position.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to issue\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.\n            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());\n            _deposit(_setToken, usdcTransferInNotionalQuantity);\n        }\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws\n     * collateral from Perp protocol to SetToken default position without updating the default position unit.\n     * Called by issuance module\'s resolveEquityPositions method which immediately transfers the collateral\n     * component from SetToken to redeemer after this hook executes.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());\n            _withdraw(_setToken, usdcTransferOutNotionalQuantity);\n        }\n    }\n    / ============ External Setter Functions ============ /\n    /\n     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.\n     \n     * @param _maxPerpPositionsPerSet       New max perpetual positions per set\n     /\n    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n    / ============ External Getter Functions ============ /\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * issuing a quantity of SetToken, representing the amount of collateral that would need to\n     * be transferred in per SetToken. Values in the returned arrays map to the same index in the\n     * SetToken\'s components array\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     /\n    function getIssuanceAdjustments(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        override\n        returns (int256[] memory, int256[] memory)\n    {\n        address[] memory components = _setToken.getComponents();\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.\n     * Values in the returned arrays map to the same index in the SetToken\'s components array.\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     */\n    function getRedemptionAdjustments(\n        ISetToken setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        returns (int256[] memory, int256[] memory )\n    {\n        address[] memory components = _setToken.getComponents();\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n    /\n     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     \n     *         + baseToken: address,\n     *         + baseBalance:  baseToken balance as notional quantity (1018)\n     *         + quoteBalance: USDC quote asset balance as notional quantity (1018)\n     /\n    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo;\n        for(uint i = 0; i &lt; positionLength; i++){\n            address baseToken = positionList[i];\n            positionInfo[i] = PositionNotionalInfo({\n                baseToken: baseToken,\n                baseBalance: perpAccountBalance.getBase(\n                    address(_setToken),\n                    baseToken\n                ),\n                quoteBalance: perpAccountBalance.getQuote(\n                    address(_setToken),\n                    baseToken\n                )\n            });\n        }\n        return positionInfo;\n    }\n    /\n     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     *\n     *         + baseToken: address,\n     *         + baseUnit:  baseToken balance as position unit (1018)\n     *         + quoteUnit: USDC quote asset balance as position unit (1018)\n     */\n    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionNotionalInfo.length;\n        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo;\n        for(uint i = 0; i &lt; positionLength; i++){\n            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];\n            positionUnitInfo[i] = PositionUnitInfo({\n                baseToken: currentPosition.baseToken,\n                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),\n                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)\n            });\n        }\n        return positionUnitInfo;\n    }\n\n    /\n     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide\n     * (rather than position specific) balance info\n     \n     * @param  _setToken            Instance of the SetToken\n     \n     * @return accountInfo          struct with properties for:\n     \n     *         + collateral balance (1018, regardless of underlying collateral decimals)\n     *         + owed realized Pnl(10**18)\n     *         + pending funding payments (10**18)\n     *         + net quote balance (10**18)\n     */\n    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {\n        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));\n        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"\n        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.\n        // We are flipping its sign here to reflect its settlement value.\n        accountInfo = AccountInfo({\n            collateralBalance: _getCollateralBalance(_setToken),\n            owedRealizedPnl: owedRealizedPnl,\n            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),\n            netQuoteBalance: _getNetQuoteBalance(_setToken)\n        });\n    }\n    /* ============ Internal Functions ============ */\n    /**\n     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.\n     * This method implements the core logic to replicate positions during issuance and redemption. Syncs\n     * thepositionslist before starting (because positions may have liquidated). Cycles through\n     * each position, tradingbasePositionUnit * issueOrRedeemQuantityand calculates the amount of\n     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any\n     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders\n     * appropriately. The hook which invokes this method sets the SetToken\'s externalPositionUnit using\n     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module\n     * which reads this value.\n     *\n     * The general formula for determiningaccountValueper Set is:\n     *\n     *accountValue = collateral                                &lt;---\n     *               + owedRealizedPnl                               }   totalCollateralValue\n     *               + pendingFundingPayment                     &lt;---\n     *               + netQuoteBalance                           neg. when long, pos. when short\n     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short\n     \n     * (See docs for _calculatePartialAccountValuePositionUnit below for more detail about the\n     * account value components).\n     \n     * NOTE: On issuance, this hook is run BEFORE USDC is transferred in and deposited to the Perp\n     * vault to pay for the issuer\'s Sets. This trading temporarily spikes the Perp account\'s\n     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to\n     * a multiple of the current Perp account value (will vary depending on Set\'s leverage ratio).\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     * @param _isIssue              If true, invocation is for issuance, redemption otherwise\n     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)\n     * @return int256               Amount of collateral to transfer in/out in position units\n     /\n    function _executePositionTrades(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        bool _isIssue,\n        bool _isSimulation\n    )\n        internal\n        returns (int256)\n    {\n        _syncPositionList(_setToken);\n        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();\n        // Note: issued naming convention used here for brevity. This logic is also run on redemption\n        // and variable may refer to the value which will be redeemed.\n        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n        for(uint i = 0; i &lt; positionLength; i++) {\n            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);\n            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,\n            // e.g selling base when long, buying base when short\n            ActionInfo memory actionInfo = _createActionInfoNotional(\n                _setToken,\n                positionInfo[i].baseToken,\n                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),\n                0\n            );\n            // Execute or simulate trade.\n            // deltaQuote is always a positive number\n            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);\n            // slippage is borne by the issuer\n            accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :\n                accountValueIssued.sub(deltaQuote.toInt256());\n        }\n        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the\n        // account could be bankrupt and we represent that as zero.\n        if (accountValueIssued &lt;= 0) {\n            return 0;\n        }\n        // Return value in collateral decimals (e.g USDC = 6)\n        // Use preciseDivCeil when issuing to ensure we don\'t under-collateralize due to rounding error\n        return (_isIssue)\n            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)\n            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);\n    }\n    /\n     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,\n     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,\n     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,\n     * and to which existing position values are added when calculating the externalPositionUnit.\n     \n     * @param _setToken             Instance of the SetToken\n     * @return accountValue         Partial account value in position units\n     /\n    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {\n        AccountInfo memory accountInfo = getAccountInfo(_setToken);\n        accountValue = accountInfo.collateralBalance\n            .add(accountInfo.owedRealizedPnl)\n            .add(accountInfo.pendingFundingPayments)\n            .add(accountInfo.netQuoteBalance)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n    }\n    /\n     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault\n     * Updates the collateral token default position unit. This function is called directly by\n     * the componentIssue hook, skipping external position unit setting because that method is assumed\n     * to be the end of a call sequence (e.g manager will not need to read the updated value)\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit\n     /\n    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        _setToken.invokeApprove(\n            address(collateralToken),\n            address(perpVault),\n            _collateralNotionalQuantity\n        );\n        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n    /\n     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit\n     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.\n     \n     * NOTE: This flow is only used when invoking the external deposit function - it converts collateral\n     * quantity units into a notional quantity.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit\n     * @return uint256                      Notional quantity deposited\n     /\n    function _depositAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n        _deposit(_setToken, collateralNotionalQuantity);\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n        return collateralNotionalQuantity;\n    }\n    /\n     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault\n     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,\n     * skipping position unit state updates because the funds withdrawn to SetToken are immediately\n     * forwarded to feeRecipient and SetToken owner respectively.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw\n     /\n    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        if (_collateralNotionalQuantity == 0) return;\n        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n    /\n     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken\n     * externalPositionUnit (so Manager contracts have a value they can base calculations for further\n     * trading on within the same transaction), and the collateral token default position unit.\n     \n     * NOTE: This flow is only used when invoking the external withdraw function - it converts\n     * a collateral units quantity into a notional quantity before invoking withdraw.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw\n     * @return uint256                      Notional quantity withdrawn\n     /\n    function _withdrawAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n        _withdraw(_setToken, collateralNotionalQuantity);\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n        return collateralNotionalQuantity;\n    }\n    /\n     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)\n     \n     * isBaseToQuote, isExactInput and oppositeAmountBound are configured as below:\n     * | ---------------------------------------------------|---------------------------- |\n     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |\n     * | ------- |-------- |--------|-----------------------|---------------------------- |\n     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |\n     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |\n     * |----------------------------------------------------|---------------------------- |\n     \n     * @param _actionInfo  ActionInfo object\n     * @return uint256     The base position delta resulting from the trade\n     * @return uint256     The quote asset position delta resulting from the trade\n     /\n    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n        // When isBaseToQuote is true, baseToken is being sold, when false, bought\n        // When isExactInput is true, amount is the swap input, when false, the swap output\n        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            oppositeAmountBound: _actionInfo.oppositeAmountBound,\n            deadline: PreciseUnitMath.maxUint256(),\n            sqrtPriceLimitX96: 0,\n            referralCode: bytes32(0)\n        });\n        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);\n    }\n\n    /\n     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)\n     \n     * See _executeTrade method comments for details about isBaseToQuote and isExactInput configuration.\n     \n     * @param _actionInfo   ActionInfo object\n     * @return uint256      The base position delta resulting from the trade\n     * @return uint256      The quote asset position delta resulting from the trade\n     */\n    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n        IQuoter.SwapParams memory params = IQuoter.SwapParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            sqrtPriceLimitX96: 0\n        });\n        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);\n        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);\n    }\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     \n     * @param  _setToken            Instance of SetToken\n     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)\n     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)\n     /\n    function _accrueProtocolFee(\n        ISetToken _setToken,\n        uint256 _exchangedQuantity\n    )\n        internal\n        returns(uint256)\n    {\n        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);\n        _withdraw(_setToken, protocolFeeInPreciseUnits);\n        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);\n        return protocolFeeInPreciseUnits;\n    }\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to\n     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If\n     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is\n     * only called from trade - the issue/redeem flow uses createActionInfoNotional directly.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _baseToken            Address of base token being traded into/out of\n     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits\n     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits\n     \n     * @return ActionInfo           Instance of constructed ActionInfo struct\n     */\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteReceiveUnits\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        require(_baseQuantityUnits != 0, "Amount is 0");\n        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");\n        uint256 totalSupply = _setToken.totalSupply();\n        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);\n        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());\n        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()\n            ? baseBalance.neg()         // To close position completely\n            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());\n        return _createActionInfoNotional(\n            _setToken,\n            _baseToken,\n            baseNotional,\n            _quoteReceiveUnits.preciseMul(totalSupply)\n        );\n    }\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates\n     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method\n     * is called during issue and redeem via _executePositionTrades and during trade via _createAndValidateActionInfo.\n     \n     * (See _executeTrade method comments for details about oppositeAmountBound configuration)\n     \n     * @param _setToken                 Instance of the SetToken\n     * @param _baseToken                Address of base token being traded into/out of\n     * @param _baseTokenQuantity        Notional quantity of baseToken to trade\n     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying\n     \n     * @return ActionInfo               Instance of constructed ActionInfo struct\n     /\n    function _createActionInfoNotional(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseTokenQuantity,\n        uint256 _quoteReceiveQuantity\n    )\n        internal\n        pure\n        returns(ActionInfo memory)\n    {\n        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called\n        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo\n        // that quantity is 0 for inputs to trade.\n        bool isBuy = _baseTokenQuantity &gt; 0;\n        return ActionInfo({\n            setToken: _setToken,\n            baseToken: _baseToken,\n            isBuy: isBuy,\n            baseTokenAmount: _baseTokenQuantity.abs(),\n            oppositeAmountBound: _quoteReceiveQuantity\n        });\n    }\n    /\n     * @dev Update position address array if a token has been newly added or completely sold off\n     * during lever/delever\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     /\n    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {\n        address[] memory positionList = positions[_setToken];\n        bool hasBaseToken = positionList.contains(_baseToken);\n        if (hasBaseToken) {\n            if(!_hasBaseBalance(_setToken, _baseToken)) {\n                positions[_setToken].removeStorage(_baseToken);\n            }\n        } else {\n            require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");\n            positions[_setToken].push(_baseToken);\n        }\n    }\n    /\n     * @dev Removes any zero balance positions from the positions array. This\n     * sync is done before issuance and redemption to account for positions that may have\n     * been liquidated.\n     \n     * @param _setToken         Instance of the SetToken\n     /\n    function _syncPositionList(ISetToken _setToken) internal {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            address currPosition = positionList[i];\n            if (!_hasBaseBalance(_setToken, currPosition)) {\n                positions[_setToken].removeStorage(currPosition);\n            }\n        }\n    }\n    /\n     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have\n     * no balance and return false\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     * @return bool         True if a non-dust base token balance exists, false otherwise\n     /\n    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {\n        int256 baseBalanceUnit = perpAccountBalance\n            .getBase(address(_setToken), _baseToken)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n        return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1);\n    }\n    /\n     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol\n     \n     * @param  _baseToken           Address of virtual token to price\n     * @return price                Mid-point price of virtual token in UniswapV3 AMM market\n     /\n    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {\n        address pool = perpMarketRegistry.getPool(_baseToken);\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();\n        return priceX96.formatX96ToX10_18();\n    }\n    /\n     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per\n     * SetToken\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       External position unit\n     /\n    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalPositionValue = 0;\n        for (uint i = 0; i &lt; positionLength; i++ ) {\n            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();\n            totalPositionValue = totalPositionValue.add(\n                positionInfo[i].baseBalance.preciseMul(spotPrice)\n            );\n        }\n        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)\n            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));\n        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);\n    }\n    /\n     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       Collateral balance as an 18 decimal vUSDC quote value\n     /\n    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {\n        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);\n    }\n    /\n     * @dev Retrieves net quote balance of all open positions\n     \n     * @param _setToken             Instance of SetToken\n     * @return netQuoteBalance      Net quote balance of all open positions\n     /\n    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            netQuoteBalance = netQuoteBalance.add(\n                perpAccountBalance.getQuote(address(_setToken), positionList[i])\n            );\n        }\n    }\n    /\n     * @dev Returns issuance or redemption adjustments in the format expected by SlippageIssuanceModule.\n     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated\n     * externalPositionUnit (new) and set in an equityAdjustments array which is the same length as\n     * the SetToken\'s components array, at the same index the collateral token occupies in the components\n     * array. All other values are left unset (0). An empty-value components length debtAdjustments\n     * array is also returned.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _components                       Array of components held by the SetToken\n     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit\n     * @return int256[]                         Components-length array with equity adjustment value at appropriate index\n     * @return int256[]                         Components-length array of zeroes (debt adjustments)\n     /\n    function _formatAdjustments(\n        ISetToken _setToken,\n        address[] memory _components,\n        int256 _newExternalPositionUnit\n    )\n        internal\n        view\n        returns (int256[] memory, int256[] memory)\n    {\n        int256[] memory equityAdjustments = new int256;\n        int256[] memory debtAdjustments = new int256;\n        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));\n        if (isIn) {\n            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(\n                address(collateralToken),\n                address(this)\n            );\n            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);\n        }\n        return (equityAdjustments, debtAdjustments);\n    }\n}".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:27:52 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:27:52 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/
pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";
import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";
/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];
    /* ============ Structs ============ */
    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }
    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }
    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }
    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }
    /* ============ Events ============ */
    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );
    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );
    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );
    /* ============ Constants ============ */
    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";
    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;
    /* ============ State Variables ============ */
    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;
    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;
    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;
    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;
    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;
    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;
    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;
    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;
    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;
    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;
    /* ============ Constructor ============ */
    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();
        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }
    /* ============ External Functions ============ */
    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();
        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );
        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }
    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );
        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);
        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);
        _updatePositionList(_setToken, _baseToken);
        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }
    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");
        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);
        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }
    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");
        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);
        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }
    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);
        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );
        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];
        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }
    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");
        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }
    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;
        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);
        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }
    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;
        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);
        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }
    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());
            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }
    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());
            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }
    /* ============ External Setter Functions ============ */
    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }
    /* ============ External Getter Functions ============ */
    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();
        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }
    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();
        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }
    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);
        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }
        return positionInfo;
    }
    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);
        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }
        return positionUnitInfo;
    }

    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));
        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }
    /* ============ Internal Functions ============ */
    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();
        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();
        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);
            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );
            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);
            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }
        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }
        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }
    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);
        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }
    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );
        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }
    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());
        _deposit(_setToken, collateralNotionalQuantity);
        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );
        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );
        return collateralNotionalQuantity;
    }
    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;
        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }
    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());
        _withdraw(_setToken, collateralNotionalQuantity);
        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );
        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );
        return collateralNotionalQuantity;
    }
    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });
        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }

    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });
        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }
    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);
        _withdraw(_setToken, protocolFeeInPreciseUnits);
        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);
        return protocolFeeInPreciseUnits;
    }
    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");
        uint256 totalSupply = _setToken.totalSupply();
        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());
        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());
        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }
    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;
        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }
    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);
        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }
    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }
    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());
        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }
    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }
    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;
        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }
        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));
        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }
    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }
    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }
    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);
        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));
        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );
            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }
        return (equityAdjustments, debtAdjustments);
    }
}.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "/*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/
pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";
import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";
/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];
    /* ============ Structs ============ */
    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }
    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }
    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }
    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }
    /* ============ Events ============ */
    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );
    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );
    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );
    /* ============ Constants ============ */
    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";
    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;
    /* ============ State Variables ============ */
    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;
    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;
    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;
    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;
    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;
    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;
    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;
    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;
    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;
    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;
    /* ============ Constructor ============ */
    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();
        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }
    /* ============ External Functions ============ */
    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();
        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );
        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }
    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );
        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);
        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);
        _updatePositionList(_setToken, _baseToken);
        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }
    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");
        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);
        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }
    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");
        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);
        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }
    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);
        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );
        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];
        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }
    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");
        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }
    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;
        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);
        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }
    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;
        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);
        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }
    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());
            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }
    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());
            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }
    /* ============ External Setter Functions ============ */
    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }
    /* ============ External Getter Functions ============ */
    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();
        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }
    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();
        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }
    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);
        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }
        return positionInfo;
    }
    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);
        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }
        return positionUnitInfo;
    }

    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));
        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }
    /* ============ Internal Functions ============ */
    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();
        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();
        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);
            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );
            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);
            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }
        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }
        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }
    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);
        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }
    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );
        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }
    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());
        _deposit(_setToken, collateralNotionalQuantity);
        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );
        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );
        return collateralNotionalQuantity;
    }
    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;
        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }
    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());
        _withdraw(_setToken, collateralNotionalQuantity);
        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );
        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );
        return collateralNotionalQuantity;
    }
    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });
        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }

    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });
        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }
    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);
        _withdraw(_setToken, protocolFeeInPreciseUnits);
        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);
        return protocolFeeInPreciseUnits;
    }
    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");
        uint256 totalSupply = _setToken.totalSupply();
        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());
        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());
        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }
    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;
        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }
    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);
        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }
    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }
    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());
        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }
    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }
    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;
        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }
        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));
        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }
    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }
    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }
    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);
        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));
        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );
            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }
        return (equityAdjustments, debtAdjustments);
    }
}".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 05:27:57 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:27:57 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 39811
completion_tokens: 1
total_tokens: 39812
cost: $-1.000000


[2024-01-09 05:27:57 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Security

[2024-01-09 05:27:57 INFO] **[Seminar Conclusion]**:

 Security

[2024-01-09 05:27:57 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-01-09 05:27:57 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 05:27:58 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport "@openzeppelin/contracts/math/SignedSafeMath.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";\n\nimport { PerpV2 } from "../integration/lib/PerpV2.sol";\nimport { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";\nimport { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";\nimport { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";\nimport { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";\nimport { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";\nimport { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";\nimport { IVault } from "../../interfaces/external/perp-v2/IVault.sol";\nimport { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";\nimport { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";\nimport { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";\n\n/\n * @title PerpV2LeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account\n * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token\n * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of\n * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.\n \n * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit\n * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.\n * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the\n * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.\n \n * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current\n * value of the Set\'s perpetual position. The current value can be calculated from getPositionNotionalInfo.\n /\ncontract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {\n    using PerpV2 for ISetToken;\n    using PreciseUnitMath for int256;\n    using SignedSafeMath for int256;\n    using UnitConversionUtils for int256;\n    using UniswapV3Math for uint160;\n    using UniswapV3Math for uint256;\n    using UnitConversionUtils for uint256;\n    using AddressArrayUtils for address[];\n\n    / ============ Structs ============ */\n\n    struct ActionInfo {\n        ISetToken setToken;\n        address baseToken;              // Virtual token minted by the Perp protocol\n        bool isBuy;                     // When true, baseToken is being bought, when false, sold\n        uint256 baseTokenAmount;        // Base token quantity in 1018 decimals\n        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see _createActionInfoNotional for details)\n    }\n\n    struct PositionNotionalInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseBalance;             // Base position notional quantity in 1018 decimals. When negative, position is short\n        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short\n    }\n\n    struct PositionUnitInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseUnit;                // Base position unit. When negative, position is short\n        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short\n    }\n\n    // Note: when pendingFundingPayments is positive it will be credited to account on settlement,\n    // when negative it\'s a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value\n    // with the opposite meaning, e.g positively signed payments are owed by account to system).\n    struct AccountInfo {\n        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 1018 decimals\n        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 1018 decimals not yet settled to vault\n        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 1018 decimals\n        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account\n    }\n\n    / ============ Events ============ /\n\n    /\n     * @dev Emitted on trade\n     * @param _setToken         Instance of SetToken\n     * @param _baseToken        Virtual token minted by the Perp protocol\n     * @param _deltaBase        Change in baseToken position size resulting from trade\n     * @param _deltaQuote       Change in vUSDC position size resulting from trade\n     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade\n     * @param _isBuy            True when baseToken is being bought, false when being sold\n     */\n    event PerpTraded(\n        ISetToken indexed _setToken,\n        address indexed _baseToken,\n        uint256 indexed _deltaBase,\n        uint256 _deltaQuote,\n        uint256 _protocolFee,\n        bool _isBuy\n    );\n\n    /\n     * @dev Emitted on deposit (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being deposited as collateral (USDC)\n     * @param _amountDeposited      Amount of collateral being deposited into Perp\n     /\n    event CollateralDeposited(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountDeposited\n    );\n\n    /\n     * @dev Emitted on withdraw (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being withdrawn as collateral (USDC)\n     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp\n     /\n    event CollateralWithdrawn(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountWithdrawn\n    );\n\n    / ============ Constants ============ /\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it\'s settlement and collateral token\n    IERC20 public immutable collateralToken;\n\n    // Decimals of collateral token. We set this in the constructor for later reading\n    uint8 internal immutable collateralDecimals;\n\n    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances\n    IAccountBalance public immutable perpAccountBalance;\n\n    // PerpV2 contract which provides a trading API\n    IClearingHouse public immutable perpClearingHouse;\n\n    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances\n    IExchange public immutable perpExchange;\n\n    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances\n    IVault public immutable perpVault;\n\n    // PerpV2 contract which makes it possible to simulate a trade before it occurs\n    IQuoter public immutable perpQuoter;\n\n    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools\n    IMarketRegistry public immutable perpMarketRegistry;\n\n    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction\n    // during issuance/redemption. maxPerpPositionsPerSet is a safe limit set by governance taking Optimism\'s block gas limit into account.\n    uint256 public maxPerpPositionsPerSet;\n\n    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.\n    // Array is updated when new positions are opened or old positions are zeroed out.\n    mapping(ISetToken =&gt; address[]) internal positions;\n\n    / ============ Constructor ============ /\n\n    /\n     * @dev Sets external PerpV2 Protocol contract addresses. Sets collateralToken and collateralDecimals\n     * to the Perp vault\'s settlement token (USDC) and its decimals, respectively.\n     \n     * @param _controller               Address of controller contract\n     * @param _perpVault                Address of Perp Vault contract\n     * @param _perpQuoter               Address of Perp Quoter contract\n     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract\n     /\n    constructor(\n        IController _controller,\n        IVault _perpVault,\n        IQuoter _perpQuoter,\n        IMarketRegistry _perpMarketRegistry,\n        uint256 _maxPerpPositionsPerSet\n    )\n        public\n        ModuleBase(_controller)\n        SetTokenAccessible(_controller)\n    {\n        // Use temp variables to initialize immutables\n        address tempCollateralToken = _perpVault.getSettlementToken();\n        collateralToken = IERC20(tempCollateralToken);\n        collateralDecimals = ERC20(tempCollateralToken).decimals();\n\n        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());\n        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());\n        perpExchange = IExchange(_perpVault.getExchange());\n        perpVault = _perpVault;\n        perpQuoter = _perpQuoter;\n        perpMarketRegistry = _perpMarketRegistry;\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the\n     * allowed list or anySetAllowed needs to be true.\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     /\n    function initialize(\n        ISetToken _setToken\n    )\n        public\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n        onlyAllowedSet(_setToken)\n    {\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(\n            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),\n            "Issuance not initialized"\n        );\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {\n                // This module registered itself on modules[i] issuance module.\n            } catch {\n                // Try will fail if modules[i] is not an instance of IDebtIssuanceModule and does not\n                // implement the registerToIssuanceModule function, or if the registerToIssuanceModule\n                // function call reverted. Irrespective of the reason for failure, continue to the next module.\n            }\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.\n     * Providing a positive value for _baseQuantityUnits buys vToken on UniswapV3 via Perp\'s ClearingHouse,\n     * Providing a negative value sells the token. _quoteBoundQuantityUnits defines a min-receive-like slippage\n     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.\n     \n     * NOTE: This method doesn\'t update the externalPositionUnit because it is a function of UniswapV3 virtual\n     * token market prices and needs to be generated on the fly to be meaningful.\n     \n     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.\n     \n     * As a user when levering, e.g increasing the magnitude of your position, you\'d trade as below\n     * | ----------------------------------------------------------------------------------------------- |\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits |\n     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |\n     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |\n     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |\n     * | ----------------------------------------------------------------------------------------------- |\n     \n     * As a user when delevering by partially closing your position, you\'d trade as below\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when completely closing a position, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |\n     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _baseToken                    Address virtual token being traded\n     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units\n     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling\n     /\n    function trade(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteBoundQuantityUnits\n    )\n        public\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        ActionInfo memory actionInfo = _createAndValidateActionInfo(\n            _setToken,\n            _baseToken,\n            _baseQuantityUnits,\n            _quoteBoundQuantityUnits\n        );\n\n        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);\n\n        _updatePositionList(_setToken, _baseToken);\n\n        emit PerpTraded(\n            _setToken,\n            _baseToken,\n            deltaBase,\n            deltaQuote,\n            protocolFee,\n            actionInfo.isBuy\n        );\n    }\n\n    /\n     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing\n     * the size of the Perp account external position. This method is useful for establishing initial\n     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit\n     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference\n     * between these made up as automatically "issued" margin debt in the PerpV2 system.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units\n     /\n    function deposit(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");\n\n        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);\n\n        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);\n    }\n\n    /\n     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on\n     * the SetToken. This method is useful when adjusting the overall composition of a Set which has\n     * a Perp account external position as one of several components.\n     \n     * NOTE: Within PerpV2, withdraw settles owedRealizedPnl and any pending funding payments\n     * to the Perp vault prior to transfer.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units\n     */\n    function withdraw(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");\n\n        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);\n\n        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);\n    }\n\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes\n     * position mappings associated with SetToken.\n     \n     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.\n     /\n    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).\n        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.\n        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());\n        require(\n            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,\n            "Account balance exists"\n        );\n\n        // positions[setToken] mapping stores an array of addresses. The base token addresses are removed from the array when the\n        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should\n        // already be empty, and the mapping can be deleted directly.\n        delete positions[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     \n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then\n     * this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE\n     * during issue. Trades into current positions and sets the collateralToken\'s externalPositionUnit so that\n     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage\n     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current\n     * Set holders.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     /\n    function moduleIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        public\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);\n\n        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing\n     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the externalPositionUnit\n     * equal to the realizable value of account in position units (as measured by the trade outcomes for\n     * this redemption). Any owedRealizedPnl and pending funding payments are socialized in this step so\n     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     /\n    function moduleRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);\n\n        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits\n     * collateral into Perp protocol from SetToken default position.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to issue\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.\n            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());\n\n            _deposit(_setToken, usdcTransferInNotionalQuantity);\n        }\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws\n     * collateral from Perp protocol to SetToken default position without updating the default position unit.\n     * Called by issuance module\'s resolveEquityPositions method which immediately transfers the collateral\n     * component from SetToken to redeemer after this hook executes.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());\n\n            _withdraw(_setToken, usdcTransferOutNotionalQuantity);\n        }\n    }\n\n    / ============ External Setter Functions ============ /\n\n    /\n     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.\n     \n     * @param _maxPerpPositionsPerSet       New max perpetual positions per set\n     /\n    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * issuing a quantity of SetToken, representing the amount of collateral that would need to\n     * be transferred in per SetToken. Values in the returned arrays map to the same index in the\n     * SetToken\'s components array\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     /\n    function getIssuanceAdjustments(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        override\n        returns (int256[] memory, int256[] memory)\n    {\n        address[] memory components = _setToken.getComponents();\n\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.\n     * Values in the returned arrays map to the same index in the SetToken\'s components array.\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     */\n    function getRedemptionAdjustments(\n        ISetToken setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        returns (int256[] memory, int256[] memory )\n    {\n        address[] memory components = _setToken.getComponents();\n\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n\n    /\n     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     \n     *         + baseToken: address,\n     *         + baseBalance:  baseToken balance as notional quantity (1018)\n     *         + quoteBalance: USDC quote asset balance as notional quantity (1018)\n     /\n    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo;\n\n        for(uint i = 0; i &lt; positionLength; i++){\n            address baseToken = positionList[i];\n            positionInfo[i] = PositionNotionalInfo({\n                baseToken: baseToken,\n                baseBalance: perpAccountBalance.getBase(\n                    address(_setToken),\n                    baseToken\n                ),\n                quoteBalance: perpAccountBalance.getQuote(\n                    address(_setToken),\n                    baseToken\n                )\n            });\n        }\n\n        return positionInfo;\n    }\n\n    /\n     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     *\n     *         + baseToken: address,\n     *         + baseUnit:  baseToken balance as position unit (1018)\n     *         + quoteUnit: USDC quote asset balance as position unit (1018)\n     */\n    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionNotionalInfo.length;\n        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo;\n\n        for(uint i = 0; i &lt; positionLength; i++){\n            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];\n            positionUnitInfo[i] = PositionUnitInfo({\n                baseToken: currentPosition.baseToken,\n                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),\n                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)\n            });\n        }\n\n        return positionUnitInfo;\n    }\n\n\n    /\n     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide\n     * (rather than position specific) balance info\n     \n     * @param  _setToken            Instance of the SetToken\n     \n     * @return accountInfo          struct with properties for:\n     \n     *         + collateral balance (1018, regardless of underlying collateral decimals)\n     *         + owed realized Pnl(10**18)\n     *         + pending funding payments (10**18)\n     *         + net quote balance (10**18)\n     */\n    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {\n        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));\n\n        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"\n        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.\n        // We are flipping its sign here to reflect its settlement value.\n        accountInfo = AccountInfo({\n            collateralBalance: _getCollateralBalance(_setToken),\n            owedRealizedPnl: owedRealizedPnl,\n            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),\n            netQuoteBalance: _getNetQuoteBalance(_setToken)\n        });\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.\n     * This method implements the core logic to replicate positions during issuance and redemption. Syncs\n     * thepositionslist before starting (because positions may have liquidated). Cycles through\n     * each position, tradingbasePositionUnit * issueOrRedeemQuantityand calculates the amount of\n     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any\n     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders\n     * appropriately. The hook which invokes this method sets the SetToken\'s externalPositionUnit using\n     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module\n     * which reads this value.\n     *\n     * The general formula for determiningaccountValueper Set is:\n     *\n     *accountValue = collateral                                &lt;---\n     *               + owedRealizedPnl                               }   totalCollateralValue\n     *               + pendingFundingPayment                     &lt;---\n     *               + netQuoteBalance                           neg. when long, pos. when short\n     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short\n     \n     * (See docs for _calculatePartialAccountValuePositionUnit below for more detail about the\n     * account value components).\n     \n     * NOTE: On issuance, this hook is run BEFORE USDC is transferred in and deposited to the Perp\n     * vault to pay for the issuer\'s Sets. This trading temporarily spikes the Perp account\'s\n     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to\n     * a multiple of the current Perp account value (will vary depending on Set\'s leverage ratio).\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     * @param _isIssue              If true, invocation is for issuance, redemption otherwise\n     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)\n     * @return int256               Amount of collateral to transfer in/out in position units\n     /\n    function _executePositionTrades(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        bool _isIssue,\n        bool _isSimulation\n    )\n        internal\n        returns (int256)\n    {\n        _syncPositionList(_setToken);\n        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();\n\n        // Note: issued naming convention used here for brevity. This logic is also run on redemption\n        // and variable may refer to the value which will be redeemed.\n        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);\n\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n\n        for(uint i = 0; i &lt; positionLength; i++) {\n            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);\n\n            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,\n            // e.g selling base when long, buying base when short\n            ActionInfo memory actionInfo = _createActionInfoNotional(\n                _setToken,\n                positionInfo[i].baseToken,\n                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),\n                0\n            );\n\n            // Execute or simulate trade.\n            // deltaQuote is always a positive number\n            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);\n\n            // slippage is borne by the issuer\n            accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :\n                accountValueIssued.sub(deltaQuote.toInt256());\n        }\n\n        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the\n        // account could be bankrupt and we represent that as zero.\n        if (accountValueIssued &lt;= 0) {\n            return 0;\n        }\n\n        // Return value in collateral decimals (e.g USDC = 6)\n        // Use preciseDivCeil when issuing to ensure we don\'t under-collateralize due to rounding error\n        return (_isIssue)\n            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)\n            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);\n    }\n\n    /\n     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,\n     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,\n     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,\n     * and to which existing position values are added when calculating the externalPositionUnit.\n     \n     * @param _setToken             Instance of the SetToken\n     * @return accountValue         Partial account value in position units\n     /\n    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {\n        AccountInfo memory accountInfo = getAccountInfo(_setToken);\n\n        accountValue = accountInfo.collateralBalance\n            .add(accountInfo.owedRealizedPnl)\n            .add(accountInfo.pendingFundingPayments)\n            .add(accountInfo.netQuoteBalance)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n    }\n\n    /\n     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault\n     * Updates the collateral token default position unit. This function is called directly by\n     * the componentIssue hook, skipping external position unit setting because that method is assumed\n     * to be the end of a call sequence (e.g manager will not need to read the updated value)\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit\n     /\n    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        _setToken.invokeApprove(\n            address(collateralToken),\n            address(perpVault),\n            _collateralNotionalQuantity\n        );\n\n        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n\n    /\n     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit\n     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.\n     \n     * NOTE: This flow is only used when invoking the external deposit function - it converts collateral\n     * quantity units into a notional quantity.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit\n     * @return uint256                      Notional quantity deposited\n     /\n    function _depositAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n\n        _deposit(_setToken, collateralNotionalQuantity);\n\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n\n        return collateralNotionalQuantity;\n    }\n\n    /\n     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault\n     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,\n     * skipping position unit state updates because the funds withdrawn to SetToken are immediately\n     * forwarded to feeRecipient and SetToken owner respectively.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw\n     /\n    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        if (_collateralNotionalQuantity == 0) return;\n\n        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n\n    /\n     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken\n     * externalPositionUnit (so Manager contracts have a value they can base calculations for further\n     * trading on within the same transaction), and the collateral token default position unit.\n     \n     * NOTE: This flow is only used when invoking the external withdraw function - it converts\n     * a collateral units quantity into a notional quantity before invoking withdraw.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw\n     * @return uint256                      Notional quantity withdrawn\n     /\n    function _withdrawAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n\n        _withdraw(_setToken, collateralNotionalQuantity);\n\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n\n        return collateralNotionalQuantity;\n    }\n\n    /\n     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)\n     \n     * isBaseToQuote, isExactInput and oppositeAmountBound are configured as below:\n     * | ---------------------------------------------------|---------------------------- |\n     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |\n     * | ------- |-------- |--------|-----------------------|---------------------------- |\n     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |\n     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |\n     * |----------------------------------------------------|---------------------------- |\n     \n     * @param _actionInfo  ActionInfo object\n     * @return uint256     The base position delta resulting from the trade\n     * @return uint256     The quote asset position delta resulting from the trade\n     /\n    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n\n        // When isBaseToQuote is true, baseToken is being sold, when false, bought\n        // When isExactInput is true, amount is the swap input, when false, the swap output\n        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            oppositeAmountBound: _actionInfo.oppositeAmountBound,\n            deadline: PreciseUnitMath.maxUint256(),\n            sqrtPriceLimitX96: 0,\n            referralCode: bytes32(0)\n        });\n\n        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);\n    }\n\n\n    /\n     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)\n     \n     * See _executeTrade method comments for details about isBaseToQuote and isExactInput configuration.\n     \n     * @param _actionInfo   ActionInfo object\n     * @return uint256      The base position delta resulting from the trade\n     * @return uint256      The quote asset position delta resulting from the trade\n     */\n    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n        IQuoter.SwapParams memory params = IQuoter.SwapParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            sqrtPriceLimitX96: 0\n        });\n\n        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);\n        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);\n    }\n\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     \n     * @param  _setToken            Instance of SetToken\n     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)\n     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)\n     /\n    function _accrueProtocolFee(\n        ISetToken _setToken,\n        uint256 _exchangedQuantity\n    )\n        internal\n        returns(uint256)\n    {\n        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);\n\n        _withdraw(_setToken, protocolFeeInPreciseUnits);\n\n        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);\n\n        return protocolFeeInPreciseUnits;\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to\n     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If\n     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is\n     * only called from trade - the issue/redeem flow uses createActionInfoNotional directly.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _baseToken            Address of base token being traded into/out of\n     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits\n     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits\n     \n     * @return ActionInfo           Instance of constructed ActionInfo struct\n     */\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteReceiveUnits\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        require(_baseQuantityUnits != 0, "Amount is 0");\n        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");\n\n        uint256 totalSupply = _setToken.totalSupply();\n\n        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);\n        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());\n\n        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()\n            ? baseBalance.neg()         // To close position completely\n            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());\n\n        return _createActionInfoNotional(\n            _setToken,\n            _baseToken,\n            baseNotional,\n            _quoteReceiveUnits.preciseMul(totalSupply)\n        );\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates\n     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method\n     * is called during issue and redeem via _executePositionTrades and during trade via _createAndValidateActionInfo.\n     \n     * (See _executeTrade method comments for details about oppositeAmountBound configuration)\n     \n     * @param _setToken                 Instance of the SetToken\n     * @param _baseToken                Address of base token being traded into/out of\n     * @param _baseTokenQuantity        Notional quantity of baseToken to trade\n     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying\n     \n     * @return ActionInfo               Instance of constructed ActionInfo struct\n     /\n    function _createActionInfoNotional(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseTokenQuantity,\n        uint256 _quoteReceiveQuantity\n    )\n        internal\n        pure\n        returns(ActionInfo memory)\n    {\n        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called\n        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo\n        // that quantity is 0 for inputs to trade.\n        bool isBuy = _baseTokenQuantity &gt; 0;\n\n        return ActionInfo({\n            setToken: _setToken,\n            baseToken: _baseToken,\n            isBuy: isBuy,\n            baseTokenAmount: _baseTokenQuantity.abs(),\n            oppositeAmountBound: _quoteReceiveQuantity\n        });\n    }\n\n    /\n     * @dev Update position address array if a token has been newly added or completely sold off\n     * during lever/delever\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     /\n    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {\n        address[] memory positionList = positions[_setToken];\n        bool hasBaseToken = positionList.contains(_baseToken);\n\n        if (hasBaseToken) {\n            if(!_hasBaseBalance(_setToken, _baseToken)) {\n                positions[_setToken].removeStorage(_baseToken);\n            }\n        } else {\n            require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");\n            positions[_setToken].push(_baseToken);\n        }\n    }\n\n    /\n     * @dev Removes any zero balance positions from the positions array. This\n     * sync is done before issuance and redemption to account for positions that may have\n     * been liquidated.\n     \n     * @param _setToken         Instance of the SetToken\n     /\n    function _syncPositionList(ISetToken _setToken) internal {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            address currPosition = positionList[i];\n            if (!_hasBaseBalance(_setToken, currPosition)) {\n                positions[_setToken].removeStorage(currPosition);\n            }\n        }\n    }\n\n    /\n     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have\n     * no balance and return false\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     * @return bool         True if a non-dust base token balance exists, false otherwise\n     /\n    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {\n        int256 baseBalanceUnit = perpAccountBalance\n            .getBase(address(_setToken), _baseToken)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n\n        return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1);\n    }\n\n    /\n     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol\n     \n     * @param  _baseToken           Address of virtual token to price\n     * @return price                Mid-point price of virtual token in UniswapV3 AMM market\n     /\n    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {\n        address pool = perpMarketRegistry.getPool(_baseToken);\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();\n        return priceX96.formatX96ToX10_18();\n    }\n\n    /\n     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per\n     * SetToken\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       External position unit\n     /\n    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalPositionValue = 0;\n\n        for (uint i = 0; i &lt; positionLength; i++ ) {\n            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();\n            totalPositionValue = totalPositionValue.add(\n                positionInfo[i].baseBalance.preciseMul(spotPrice)\n            );\n        }\n\n        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)\n            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));\n\n        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);\n    }\n\n    /\n     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       Collateral balance as an 18 decimal vUSDC quote value\n     /\n    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {\n        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);\n    }\n\n    /\n     * @dev Retrieves net quote balance of all open positions\n     \n     * @param _setToken             Instance of SetToken\n     * @return netQuoteBalance      Net quote balance of all open positions\n     /\n    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            netQuoteBalance = netQuoteBalance.add(\n                perpAccountBalance.getQuote(address(_setToken), positionList[i])\n            );\n        }\n    }\n\n    /\n     * @dev Returns issuance or redemption adjustments in the format expected by SlippageIssuanceModule.\n     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated\n     * externalPositionUnit (new) and set in an equityAdjustments array which is the same length as\n     * the SetToken\'s components array, at the same index the collateral token occupies in the components\n     * array. All other values are left unset (0). An empty-value components length debtAdjustments\n     * array is also returned.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _components                       Array of components held by the SetToken\n     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit\n     * @return int256[]                         Components-length array with equity adjustment value at appropriate index\n     * @return int256[]                         Components-length array of zeroes (debt adjustments)\n     /\n    function _formatAdjustments(\n        ISetToken _setToken,\n        address[] memory _components,\n        int256 _newExternalPositionUnit\n    )\n        internal\n        view\n        returns (int256[] memory, int256[] memory)\n    {\n        int256[] memory equityAdjustments = new int256;\n        int256[] memory debtAdjustments = new int256;\n\n        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));\n\n        if (isIn) {\n            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(\n                address(collateralToken),\n                address(this)\n            );\n\n            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);\n        }\n\n        return (equityAdjustments, debtAdjustments);\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:27:58 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:27:58 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 05:28:01 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:28:01 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 26495
completion_tokens: 1
total_tokens: 26496
cost: $-1.000000


[2024-01-09 05:28:01 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

###

[2024-01-09 05:28:01 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 05:28:01 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 05:28:01 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:28:01 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:28:01 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 05:28:15 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:28:15 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13306
completion_tokens: 904
total_tokens: 14210
cost: $-1.000000


[2024-01-09 05:28:15 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Based on the provided Solidity smart contract code for the `PerpV2LeverageModule`, here is a succinct summary of the security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract uses `nonReentrant` modifier to prevent reentrancy attacks in functions like `trade`, `deposit`, and `withdraw`. However, care must be taken to ensure that all external calls are properly guarded to prevent reentrancy in any function that interacts with external contracts.

2. **Lack of Input Validation**:
   - Functions such as `trade`, `deposit`, and `withdraw` require additional checks on input parameters to ensure that they are within acceptable limits. For example, ensuring that the amounts being traded or deposited are greater than zero.

3. **Potential for Integer Overflow/Underflow**:
   - Although the contract uses `SignedSafeMath`, there are still areas where integer operations could lead to unexpected behavior if not handled properly. For instance, the calculations involving balances and quantities should be carefully reviewed to ensure they do not lead to overflows or underflows.

4. **Protocol Fee Calculation**:
   - The calculation of protocol fees in `_accrueProtocolFee` does not account for potential rounding errors, which could lead to under- or overcharging fees. This could affect the economic model of the contract.

5. **Access Control Issues**:
   - The contract relies on the `onlyManagerAndValidSet` and `onlyValidAndInitializedSet` modifiers for access control. However, it is crucial to ensure that these roles are strictly enforced and that there are no ways for unauthorized users to execute sensitive functions.

6. **Potential for Front-Running Attacks**:
   - The contract does not implement any mechanisms to mitigate front-running attacks, particularly in the `trade` function where the price could be manipulated by an attacker before the transaction is confirmed.

7. **Event Emission**:
   - While events are emitted for significant actions (like trades and deposits), there may be additional state changes that should also trigger events for better tracking and transparency.

8. **Gas Limit Issues**:
   - The contract has a limit on the number of positions that can be opened in a single transaction (`maxPerpPositionsPerSet`). If this limit is reached, it could lead to failed transactions or require multiple transactions to achieve the desired state, which could be exploited.

### Comprehensive Analysis Report

The `PerpV2LeverageModule` contract is designed to facilitate leveraged trading using the PerpV2 protocol. While it incorporates several best practices, including the use of OpenZeppelin's libraries for safe math operations and access control, there are notable security vulnerabilities that need to be addressed to ensure the robustness and reliability of the contract.

1. **Reentrancy Protection**: The use of `nonReentrant` is a positive step, but developers must ensure that all external calls are carefully managed to prevent any potential reentrancy attacks.

2. **Input Validation**: It is essential to implement rigorous input validation to prevent invalid operations that could lead to unexpected behavior or economic exploitation.

3. **Integer Safety**: While `SignedSafeMath` is utilized, developers should remain vigilant about potential overflow and underflow scenarios, particularly in complex calculations involving user balances and fees.

4. **Protocol Fee Integrity**: The fee calculation logic should be reviewed and potentially enhanced to ensure that it accurately reflects the intended economic model without introducing rounding errors.

5. **Access Control**: The contract's access control mechanisms must be thoroughly audited to prevent unauthorized access to sensitive functions, ensuring that only legitimate managers can perform critical operations.

6. **Front-Running Mitigation**: Implementing measures to mitigate front-running risks will be crucial in maintaining the integrity of trades executed through the contract.

7. **Event Logging**: Enhancing event logging for all significant state changes will improve transparency and facilitate easier tracking of contract activity.

8. **Gas Limit Considerations**: The limitation on the number of positions per transaction should be carefully considered to avoid potential exploitation and ensure that users can interact with the contract efficiently.

In conclusion, while the `PerpV2LeverageModule` contract demonstrates a solid foundation for leveraged trading, addressing the identified vulnerabilities will be critical to enhancing its security posture and ensuring user trust. A thorough audit and testing phase, including stress testing for edge cases, will be essential before deployment.

[2024-01-09 05:28:15 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `PerpV2LeverageModule`, here is a succinct summary of the security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract uses `nonReentrant` modifier to prevent reentrancy attacks in functions like `trade`, `deposit`, and `withdraw`. However, care must be taken to ensure that all external calls are properly guarded to prevent reentrancy in any function that interacts with external contracts.

2. **Lack of Input Validation**:
   - Functions such as `trade`, `deposit`, and `withdraw` require additional checks on input parameters to ensure that they are within acceptable limits. For example, ensuring that the amounts being traded or deposited are greater than zero.

3. **Potential for Integer Overflow/Underflow**:
   - Although the contract uses `SignedSafeMath`, there are still areas where integer operations could lead to unexpected behavior if not handled properly. For instance, the calculations involving balances and quantities should be carefully reviewed to ensure they do not lead to overflows or underflows.

4. **Protocol Fee Calculation**:
   - The calculation of protocol fees in `_accrueProtocolFee` does not account for potential rounding errors, which could lead to under- or overcharging fees. This could affect the economic model of the contract.

5. **Access Control Issues**:
   - The contract relies on the `onlyManagerAndValidSet` and `onlyValidAndInitializedSet` modifiers for access control. However, it is crucial to ensure that these roles are strictly enforced and that there are no ways for unauthorized users to execute sensitive functions.

6. **Potential for Front-Running Attacks**:
   - The contract does not implement any mechanisms to mitigate front-running attacks, particularly in the `trade` function where the price could be manipulated by an attacker before the transaction is confirmed.

7. **Event Emission**:
   - While events are emitted for significant actions (like trades and deposits), there may be additional state changes that should also trigger events for better tracking and transparency.

8. **Gas Limit Issues**:
   - The contract has a limit on the number of positions that can be opened in a single transaction (`maxPerpPositionsPerSet`). If this limit is reached, it could lead to failed transactions or require multiple transactions to achieve the desired state, which could be exploited.

### Comprehensive Analysis Report

The `PerpV2LeverageModule` contract is designed to facilitate leveraged trading using the PerpV2 protocol. While it incorporates several best practices, including the use of OpenZeppelin's libraries for safe math operations and access control, there are notable security vulnerabilities that need to be addressed to ensure the robustness and reliability of the contract.

1. **Reentrancy Protection**: The use of `nonReentrant` is a positive step, but developers must ensure that all external calls are carefully managed to prevent any potential reentrancy attacks.

2. **Input Validation**: It is essential to implement rigorous input validation to prevent invalid operations that could lead to unexpected behavior or economic exploitation.

3. **Integer Safety**: While `SignedSafeMath` is utilized, developers should remain vigilant about potential overflow and underflow scenarios, particularly in complex calculations involving user balances and fees.

4. **Protocol Fee Integrity**: The fee calculation logic should be reviewed and potentially enhanced to ensure that it accurately reflects the intended economic model without introducing rounding errors.

5. **Access Control**: The contract's access control mechanisms must be thoroughly audited to prevent unauthorized access to sensitive functions, ensuring that only legitimate managers can perform critical operations.

6. **Front-Running Mitigation**: Implementing measures to mitigate front-running risks will be crucial in maintaining the integrity of trades executed through the contract.

7. **Event Logging**: Enhancing event logging for all significant state changes will improve transparency and facilitate easier tracking of contract activity.

8. **Gas Limit Considerations**: The limitation on the number of positions per transaction should be carefully considered to avoid potential exploitation and ensure that users can interact with the contract efficiently.

In conclusion, while the `PerpV2LeverageModule` contract demonstrates a solid foundation for leveraged trading, addressing the identified vulnerabilities will be critical to enhancing its security posture and ensuring user trust. A thorough audit and testing phase, including stress testing for edge cases, will be essential before deployment.

[2024-01-09 05:28:15 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 05:28:16 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '/\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport "@openzeppelin/contracts/math/SignedSafeMath.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";\n\nimport { PerpV2 } from "../integration/lib/PerpV2.sol";\nimport { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";\nimport { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";\nimport { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";\nimport { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";\nimport { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";\nimport { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";\nimport { IVault } from "../../interfaces/external/perp-v2/IVault.sol";\nimport { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";\nimport { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";\nimport { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";\n\n/\n * @title PerpV2LeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account\n * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token\n * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of\n * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.\n \n * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit\n * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.\n * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the\n * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.\n \n * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current\n * value of the Set\'s perpetual position. The current value can be calculated from getPositionNotionalInfo.\n /\ncontract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {\n    using PerpV2 for ISetToken;\n    using PreciseUnitMath for int256;\n    using SignedSafeMath for int256;\n    using UnitConversionUtils for int256;\n    using UniswapV3Math for uint160;\n    using UniswapV3Math for uint256;\n    using UnitConversionUtils for uint256;\n    using AddressArrayUtils for address[];\n\n    / ============ Structs ============ */\n\n    struct ActionInfo {\n        ISetToken setToken;\n        address baseToken;              // Virtual token minted by the Perp protocol\n        bool isBuy;                     // When true, baseToken is being bought, when false, sold\n        uint256 baseTokenAmount;        // Base token quantity in 1018 decimals\n        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see _createActionInfoNotional for details)\n    }\n\n    struct PositionNotionalInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseBalance;             // Base position notional quantity in 1018 decimals. When negative, position is short\n        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short\n    }\n\n    struct PositionUnitInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseUnit;                // Base position unit. When negative, position is short\n        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short\n    }\n\n    // Note: when pendingFundingPayments is positive it will be credited to account on settlement,\n    // when negative it\'s a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value\n    // with the opposite meaning, e.g positively signed payments are owed by account to system).\n    struct AccountInfo {\n        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 1018 decimals\n        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 1018 decimals not yet settled to vault\n        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 1018 decimals\n        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account\n    }\n\n    / ============ Events ============ /\n\n    /\n     * @dev Emitted on trade\n     * @param _setToken         Instance of SetToken\n     * @param _baseToken        Virtual token minted by the Perp protocol\n     * @param _deltaBase        Change in baseToken position size resulting from trade\n     * @param _deltaQuote       Change in vUSDC position size resulting from trade\n     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade\n     * @param _isBuy            True when baseToken is being bought, false when being sold\n     */\n    event PerpTraded(\n        ISetToken indexed _setToken,\n        address indexed _baseToken,\n        uint256 indexed _deltaBase,\n        uint256 _deltaQuote,\n        uint256 _protocolFee,\n        bool _isBuy\n    );\n\n    /\n     * @dev Emitted on deposit (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being deposited as collateral (USDC)\n     * @param _amountDeposited      Amount of collateral being deposited into Perp\n     /\n    event CollateralDeposited(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountDeposited\n    );\n\n    /\n     * @dev Emitted on withdraw (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being withdrawn as collateral (USDC)\n     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp\n     /\n    event CollateralWithdrawn(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountWithdrawn\n    );\n\n    / ============ Constants ============ /\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it\'s settlement and collateral token\n    IERC20 public immutable collateralToken;\n\n    // Decimals of collateral token. We set this in the constructor for later reading\n    uint8 internal immutable collateralDecimals;\n\n    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances\n    IAccountBalance public immutable perpAccountBalance;\n\n    // PerpV2 contract which provides a trading API\n    IClearingHouse public immutable perpClearingHouse;\n\n    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances\n    IExchange public immutable perpExchange;\n\n    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances\n    IVault public immutable perpVault;\n\n    // PerpV2 contract which makes it possible to simulate a trade before it occurs\n    IQuoter public immutable perpQuoter;\n\n    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools\n    IMarketRegistry public immutable perpMarketRegistry;\n\n    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction\n    // during issuance/redemption. maxPerpPositionsPerSet is a safe limit set by governance taking Optimism\'s block gas limit into account.\n    uint256 public maxPerpPositionsPerSet;\n\n    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.\n    // Array is updated when new positions are opened or old positions are zeroed out.\n    mapping(ISetToken =&gt; address[]) internal positions;\n\n    / ============ Constructor ============ /\n\n    /\n     * @dev Sets external PerpV2 Protocol contract addresses. Sets collateralToken and collateralDecimals\n     * to the Perp vault\'s settlement token (USDC) and its decimals, respectively.\n     \n     * @param _controller               Address of controller contract\n     * @param _perpVault                Address of Perp Vault contract\n     * @param _perpQuoter               Address of Perp Quoter contract\n     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract\n     /\n    constructor(\n        IController _controller,\n        IVault _perpVault,\n        IQuoter _perpQuoter,\n        IMarketRegistry _perpMarketRegistry,\n        uint256 _maxPerpPositionsPerSet\n    )\n        public\n        ModuleBase(_controller)\n        SetTokenAccessible(_controller)\n    {\n        // Use temp variables to initialize immutables\n        address tempCollateralToken = _perpVault.getSettlementToken();\n        collateralToken = IERC20(tempCollateralToken);\n        collateralDecimals = ERC20(tempCollateralToken).decimals();\n\n        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());\n        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());\n        perpExchange = IExchange(_perpVault.getExchange());\n        perpVault = _perpVault;\n        perpQuoter = _perpQuoter;\n        perpMarketRegistry = _perpMarketRegistry;\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the\n     * allowed list or anySetAllowed needs to be true.\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     /\n    function initialize(\n        ISetToken _setToken\n    )\n        public\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n        onlyAllowedSet(_setToken)\n    {\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(\n            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),\n            "Issuance not initialized"\n        );\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {\n                // This module registered itself on modules[i] issuance module.\n            } catch {\n                // Try will fail if modules[i] is not an instance of IDebtIssuanceModule and does not\n                // implement the registerToIssuanceModule function, or if the registerToIssuanceModule\n                // function call reverted. Irrespective of the reason for failure, continue to the next module.\n            }\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.\n     * Providing a positive value for _baseQuantityUnits buys vToken on UniswapV3 via Perp\'s ClearingHouse,\n     * Providing a negative value sells the token. _quoteBoundQuantityUnits defines a min-receive-like slippage\n     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.\n     \n     * NOTE: This method doesn\'t update the externalPositionUnit because it is a function of UniswapV3 virtual\n     * token market prices and needs to be generated on the fly to be meaningful.\n     \n     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.\n     \n     * As a user when levering, e.g increasing the magnitude of your position, you\'d trade as below\n     * | ----------------------------------------------------------------------------------------------- |\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits |\n     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |\n     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |\n     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |\n     * | ----------------------------------------------------------------------------------------------- |\n     \n     * As a user when delevering by partially closing your position, you\'d trade as below\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when completely closing a position, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |\n     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _baseToken                    Address virtual token being traded\n     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units\n     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling\n     /\n    function trade(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteBoundQuantityUnits\n    )\n        public\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        ActionInfo memory actionInfo = _createAndValidateActionInfo(\n            _setToken,\n            _baseToken,\n            _baseQuantityUnits,\n            _quoteBoundQuantityUnits\n        );\n\n        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);\n\n        _updatePositionList(_setToken, _baseToken);\n\n        emit PerpTraded(\n            _setToken,\n            _baseToken,\n            deltaBase,\n            deltaQuote,\n            protocolFee,\n            actionInfo.isBuy\n        );\n    }\n\n    /\n     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing\n     * the size of the Perp account external position. This method is useful for establishing initial\n     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit\n     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference\n     * between these made up as automatically "issued" margin debt in the PerpV2 system.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units\n     /\n    function deposit(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");\n\n        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);\n\n        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);\n    }\n\n    /\n     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on\n     * the SetToken. This method is useful when adjusting the overall composition of a Set which has\n     * a Perp account external position as one of several components.\n     \n     * NOTE: Within PerpV2, withdraw settles owedRealizedPnl and any pending funding payments\n     * to the Perp vault prior to transfer.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units\n     */\n    function withdraw(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");\n\n        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);\n\n        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);\n    }\n\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes\n     * position mappings associated with SetToken.\n     \n     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.\n     /\n    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).\n        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.\n        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());\n        require(\n            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,\n            "Account balance exists"\n        );\n\n        // positions[setToken] mapping stores an array of addresses. The base token addresses are removed from the array when the\n        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should\n        // already be empty, and the mapping can be deleted directly.\n        delete positions[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     \n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then\n     * this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE\n     * during issue. Trades into current positions and sets the collateralToken\'s externalPositionUnit so that\n     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage\n     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current\n     * Set holders.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     /\n    function moduleIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        public\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);\n\n        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing\n     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the externalPositionUnit\n     * equal to the realizable value of account in position units (as measured by the trade outcomes for\n     * this redemption). Any owedRealizedPnl and pending funding payments are socialized in this step so\n     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     /\n    function moduleRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);\n\n        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits\n     * collateral into Perp protocol from SetToken default position.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to issue\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.\n            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());\n\n            _deposit(_setToken, usdcTransferInNotionalQuantity);\n        }\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws\n     * collateral from Perp protocol to SetToken default position without updating the default position unit.\n     * Called by issuance module\'s resolveEquityPositions method which immediately transfers the collateral\n     * component from SetToken to redeemer after this hook executes.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());\n\n            _withdraw(_setToken, usdcTransferOutNotionalQuantity);\n        }\n    }\n\n    / ============ External Setter Functions ============ /\n\n    /\n     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.\n     \n     * @param _maxPerpPositionsPerSet       New max perpetual positions per set\n     /\n    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * issuing a quantity of SetToken, representing the amount of collateral that would need to\n     * be transferred in per SetToken. Values in the returned arrays map to the same index in the\n     * SetToken\'s components array\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     /\n    function getIssuanceAdjustments(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        override\n        returns (int256[] memory, int256[] memory)\n    {\n        address[] memory components = _setToken.getComponents();\n\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.\n     * Values in the returned arrays map to the same index in the SetToken\'s components array.\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     */\n    function getRedemptionAdjustments(\n        ISetToken setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        returns (int256[] memory, int256[] memory )\n    {\n        address[] memory components = _setToken.getComponents();\n\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n\n    /\n     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     \n     *         + baseToken: address,\n     *         + baseBalance:  baseToken balance as notional quantity (1018)\n     *         + quoteBalance: USDC quote asset balance as notional quantity (1018)\n     /\n    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo;\n\n        for(uint i = 0; i &lt; positionLength; i++){\n            address baseToken = positionList[i];\n            positionInfo[i] = PositionNotionalInfo({\n                baseToken: baseToken,\n                baseBalance: perpAccountBalance.getBase(\n                    address(_setToken),\n                    baseToken\n                ),\n                quoteBalance: perpAccountBalance.getQuote(\n                    address(_setToken),\n                    baseToken\n                )\n            });\n        }\n\n        return positionInfo;\n    }\n\n    /\n     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     *\n     *         + baseToken: address,\n     *         + baseUnit:  baseToken balance as position unit (1018)\n     *         + quoteUnit: USDC quote asset balance as position unit (1018)\n     */\n    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionNotionalInfo.length;\n        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo;\n\n        for(uint i = 0; i &lt; positionLength; i++){\n            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];\n            positionUnitInfo[i] = PositionUnitInfo({\n                baseToken: currentPosition.baseToken,\n                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),\n                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)\n            });\n        }\n\n        return positionUnitInfo;\n    }\n\n\n    /\n     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide\n     * (rather than position specific) balance info\n     \n     * @param  _setToken            Instance of the SetToken\n     \n     * @return accountInfo          struct with properties for:\n     \n     *         + collateral balance (1018, regardless of underlying collateral decimals)\n     *         + owed realized Pnl(10**18)\n     *         + pending funding payments (10**18)\n     *         + net quote balance (10**18)\n     */\n    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {\n        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));\n\n        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"\n        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.\n        // We are flipping its sign here to reflect its settlement value.\n        accountInfo = AccountInfo({\n            collateralBalance: _getCollateralBalance(_setToken),\n            owedRealizedPnl: owedRealizedPnl,\n            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),\n            netQuoteBalance: _getNetQuoteBalance(_setToken)\n        });\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.\n     * This method implements the core logic to replicate positions during issuance and redemption. Syncs\n     * thepositionslist before starting (because positions may have liquidated). Cycles through\n     * each position, tradingbasePositionUnit * issueOrRedeemQuantityand calculates the amount of\n     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any\n     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders\n     * appropriately. The hook which invokes this method sets the SetToken\'s externalPositionUnit using\n     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module\n     * which reads this value.\n     *\n     * The general formula for determiningaccountValueper Set is:\n     *\n     *accountValue = collateral                                &lt;---\n     *               + owedRealizedPnl                               }   totalCollateralValue\n     *               + pendingFundingPayment                     &lt;---\n     *               + netQuoteBalance                           neg. when long, pos. when short\n     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short\n     \n     * (See docs for _calculatePartialAccountValuePositionUnit below for more detail about the\n     * account value components).\n     \n     * NOTE: On issuance, this hook is run BEFORE USDC is transferred in and deposited to the Perp\n     * vault to pay for the issuer\'s Sets. This trading temporarily spikes the Perp account\'s\n     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to\n     * a multiple of the current Perp account value (will vary depending on Set\'s leverage ratio).\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     * @param _isIssue              If true, invocation is for issuance, redemption otherwise\n     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)\n     * @return int256               Amount of collateral to transfer in/out in position units\n     /\n    function _executePositionTrades(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        bool _isIssue,\n        bool _isSimulation\n    )\n        internal\n        returns (int256)\n    {\n        _syncPositionList(_setToken);\n        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();\n\n        // Note: issued naming convention used here for brevity. This logic is also run on redemption\n        // and variable may refer to the value which will be redeemed.\n        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);\n\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n\n        for(uint i = 0; i &lt; positionLength; i++) {\n            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);\n\n            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,\n            // e.g selling base when long, buying base when short\n            ActionInfo memory actionInfo = _createActionInfoNotional(\n                _setToken,\n                positionInfo[i].baseToken,\n                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),\n                0\n            );\n\n            // Execute or simulate trade.\n            // deltaQuote is always a positive number\n            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);\n\n            // slippage is borne by the issuer\n            accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :\n                accountValueIssued.sub(deltaQuote.toInt256());\n        }\n\n        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the\n        // account could be bankrupt and we represent that as zero.\n        if (accountValueIssued &lt;= 0) {\n            return 0;\n        }\n\n        // Return value in collateral decimals (e.g USDC = 6)\n        // Use preciseDivCeil when issuing to ensure we don\'t under-collateralize due to rounding error\n        return (_isIssue)\n            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)\n            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);\n    }\n\n    /\n     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,\n     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,\n     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,\n     * and to which existing position values are added when calculating the externalPositionUnit.\n     \n     * @param _setToken             Instance of the SetToken\n     * @return accountValue         Partial account value in position units\n     /\n    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {\n        AccountInfo memory accountInfo = getAccountInfo(_setToken);\n\n        accountValue = accountInfo.collateralBalance\n            .add(accountInfo.owedRealizedPnl)\n            .add(accountInfo.pendingFundingPayments)\n            .add(accountInfo.netQuoteBalance)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n    }\n\n    /\n     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault\n     * Updates the collateral token default position unit. This function is called directly by\n     * the componentIssue hook, skipping external position unit setting because that method is assumed\n     * to be the end of a call sequence (e.g manager will not need to read the updated value)\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit\n     /\n    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        _setToken.invokeApprove(\n            address(collateralToken),\n            address(perpVault),\n            _collateralNotionalQuantity\n        );\n\n        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n\n    /\n     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit\n     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.\n     \n     * NOTE: This flow is only used when invoking the external deposit function - it converts collateral\n     * quantity units into a notional quantity.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit\n     * @return uint256                      Notional quantity deposited\n     /\n    function _depositAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n\n        _deposit(_setToken, collateralNotionalQuantity);\n\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n\n        return collateralNotionalQuantity;\n    }\n\n    /\n     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault\n     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,\n     * skipping position unit state updates because the funds withdrawn to SetToken are immediately\n     * forwarded to feeRecipient and SetToken owner respectively.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw\n     /\n    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        if (_collateralNotionalQuantity == 0) return;\n\n        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n\n    /\n     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken\n     * externalPositionUnit (so Manager contracts have a value they can base calculations for further\n     * trading on within the same transaction), and the collateral token default position unit.\n     \n     * NOTE: This flow is only used when invoking the external withdraw function - it converts\n     * a collateral units quantity into a notional quantity before invoking withdraw.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw\n     * @return uint256                      Notional quantity withdrawn\n     /\n    function _withdrawAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n\n        _withdraw(_setToken, collateralNotionalQuantity);\n\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n\n        return collateralNotionalQuantity;\n    }\n\n    /\n     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)\n     \n     * isBaseToQuote, isExactInput and oppositeAmountBound are configured as below:\n     * | ---------------------------------------------------|---------------------------- |\n     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |\n     * | ------- |-------- |--------|-----------------------|---------------------------- |\n     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |\n     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |\n     * |----------------------------------------------------|---------------------------- |\n     \n     * @param _actionInfo  ActionInfo object\n     * @return uint256     The base position delta resulting from the trade\n     * @return uint256     The quote asset position delta resulting from the trade\n     /\n    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n\n        // When isBaseToQuote is true, baseToken is being sold, when false, bought\n        // When isExactInput is true, amount is the swap input, when false, the swap output\n        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            oppositeAmountBound: _actionInfo.oppositeAmountBound,\n            deadline: PreciseUnitMath.maxUint256(),\n            sqrtPriceLimitX96: 0,\n            referralCode: bytes32(0)\n        });\n\n        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);\n    }\n\n\n    /\n     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)\n     \n     * See _executeTrade method comments for details about isBaseToQuote and isExactInput configuration.\n     \n     * @param _actionInfo   ActionInfo object\n     * @return uint256      The base position delta resulting from the trade\n     * @return uint256      The quote asset position delta resulting from the trade\n     */\n    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n        IQuoter.SwapParams memory params = IQuoter.SwapParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            sqrtPriceLimitX96: 0\n        });\n\n        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);\n        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);\n    }\n\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     \n     * @param  _setToken            Instance of SetToken\n     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)\n     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)\n     /\n    function _accrueProtocolFee(\n        ISetToken _setToken,\n        uint256 _exchangedQuantity\n    )\n        internal\n        returns(uint256)\n    {\n        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);\n\n        _withdraw(_setToken, protocolFeeInPreciseUnits);\n\n        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);\n\n        return protocolFeeInPreciseUnits;\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to\n     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If\n     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is\n     * only called from trade - the issue/redeem flow uses createActionInfoNotional directly.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _baseToken            Address of base token being traded into/out of\n     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits\n     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits\n     \n     * @return ActionInfo           Instance of constructed ActionInfo struct\n     */\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteReceiveUnits\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        require(_baseQuantityUnits != 0, "Amount is 0");\n        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");\n\n        uint256 totalSupply = _setToken.totalSupply();\n\n        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);\n        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());\n\n        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()\n            ? baseBalance.neg()         // To close position completely\n            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());\n\n        return _createActionInfoNotional(\n            _setToken,\n            _baseToken,\n            baseNotional,\n            _quoteReceiveUnits.preciseMul(totalSupply)\n        );\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates\n     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method\n     * is called during issue and redeem via _executePositionTrades and during trade via _createAndValidateActionInfo.\n     \n     * (See _executeTrade method comments for details about oppositeAmountBound configuration)\n     \n     * @param _setToken                 Instance of the SetToken\n     * @param _baseToken                Address of base token being traded into/out of\n     * @param _baseTokenQuantity        Notional quantity of baseToken to trade\n     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying\n     \n     * @return ActionInfo               Instance of constructed ActionInfo struct\n     /\n    function _createActionInfoNotional(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseTokenQuantity,\n        uint256 _quoteReceiveQuantity\n    )\n        internal\n        pure\n        returns(ActionInfo memory)\n    {\n        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called\n        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo\n        // that quantity is 0 for inputs to trade.\n        bool isBuy = _baseTokenQuantity &gt; 0;\n\n        return ActionInfo({\n            setToken: _setToken,\n            baseToken: _baseToken,\n            isBuy: isBuy,\n            baseTokenAmount: _baseTokenQuantity.abs(),\n            oppositeAmountBound: _quoteReceiveQuantity\n        });\n    }\n\n    /\n     * @dev Update position address array if a token has been newly added or completely sold off\n     * during lever/delever\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     /\n    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {\n        address[] memory positionList = positions[_setToken];\n        bool hasBaseToken = positionList.contains(_baseToken);\n\n        if (hasBaseToken) {\n            if(!_hasBaseBalance(_setToken, _baseToken)) {\n                positions[_setToken].removeStorage(_baseToken);\n            }\n        } else {\n            require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");\n            positions[_setToken].push(_baseToken);\n        }\n    }\n\n    /\n     * @dev Removes any zero balance positions from the positions array. This\n     * sync is done before issuance and redemption to account for positions that may have\n     * been liquidated.\n     \n     * @param _setToken         Instance of the SetToken\n     /\n    function _syncPositionList(ISetToken _setToken) internal {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            address currPosition = positionList[i];\n            if (!_hasBaseBalance(_setToken, currPosition)) {\n                positions[_setToken].removeStorage(currPosition);\n            }\n        }\n    }\n\n    /\n     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have\n     * no balance and return false\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     * @return bool         True if a non-dust base token balance exists, false otherwise\n     /\n    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {\n        int256 baseBalanceUnit = perpAccountBalance\n            .getBase(address(_setToken), _baseToken)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n\n        return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1);\n    }\n\n    /\n     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol\n     \n     * @param  _baseToken           Address of virtual token to price\n     * @return price                Mid-point price of virtual token in UniswapV3 AMM market\n     /\n    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {\n        address pool = perpMarketRegistry.getPool(_baseToken);\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();\n        return priceX96.formatX96ToX10_18();\n    }\n\n    /\n     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per\n     * SetToken\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       External position unit\n     /\n    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalPositionValue = 0;\n\n        for (uint i = 0; i &lt; positionLength; i++ ) {\n            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();\n            totalPositionValue = totalPositionValue.add(\n                positionInfo[i].baseBalance.preciseMul(spotPrice)\n            );\n        }\n\n        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)\n            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));\n\n        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);\n    }\n\n    /\n     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       Collateral balance as an 18 decimal vUSDC quote value\n     /\n    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {\n        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);\n    }\n\n    /\n     * @dev Retrieves net quote balance of all open positions\n     \n     * @param _setToken             Instance of SetToken\n     * @return netQuoteBalance      Net quote balance of all open positions\n     /\n    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            netQuoteBalance = netQuoteBalance.add(\n                perpAccountBalance.getQuote(address(_setToken), positionList[i])\n            );\n        }\n    }\n\n    /\n     * @dev Returns issuance or redemption adjustments in the format expected by SlippageIssuanceModule.\n     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated\n     * externalPositionUnit (new) and set in an equityAdjustments array which is the same length as\n     * the SetToken\'s components array, at the same index the collateral token occupies in the components\n     * array. All other values are left unset (0). An empty-value components length debtAdjustments\n     * array is also returned.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _components                       Array of components held by the SetToken\n     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit\n     * @return int256[]                         Components-length array with equity adjustment value at appropriate index\n     * @return int256[]                         Components-length array of zeroes (debt adjustments)\n     /\n    function _formatAdjustments(\n        ISetToken _setToken,\n        address[] memory _components,\n        int256 _newExternalPositionUnit\n    )\n        internal\n        view\n        returns (int256[] memory, int256[] memory)\n    {\n        int256[] memory equityAdjustments = new int256;\n        int256[] memory debtAdjustments = new int256;\n\n        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));\n\n        if (isIn) {\n            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(\n                address(collateralToken),\n                address(this)\n            );\n\n            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);\n        }\n\n        return (equityAdjustments, debtAdjustments);\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:28:16 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:28:16 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 05:28:20 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:28:20 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 26495
completion_tokens: 1
total_tokens: 26496
cost: $-1.000000


[2024-01-09 05:28:20 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

###

[2024-01-09 05:28:20 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 05:28:20 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 05:28:20 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:28:20 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:28:20 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 05:28:32 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:28:32 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13306
completion_tokens: 872
total_tokens: 14178
cost: $-1.000000


[2024-01-09 05:28:32 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Based on the provided smart contract code for the `PerpV2LeverageModule`, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., to the Perp protocol) that could potentially be exploited if not properly managed. Care should be taken to ensure that state changes occur before external calls.

2. **Lack of Input Validation**:
   - The contract does not thoroughly validate inputs in several functions. For instance, in the `trade` function, there is no check to ensure that the `_baseQuantityUnits` and `_quoteBoundQuantityUnits` are within acceptable limits, which could lead to unexpected behavior or losses.

3. **Arithmetic Overflows/Underflows**:
   - While the contract uses `SignedSafeMath`, it is essential to ensure that all arithmetic operations are consistently protected against overflows and underflows, especially in critical functions like `trade`, `deposit`, and `withdraw`.

4. **Potential for Sandwich Attacks**:
   - The contract mentions the risk of sandwich attacks during issuance and redemption processes. If users do not use the `SlippageIssuanceModule`, they may be vulnerable to front-running attacks.

5. **Improper Handling of Liquidation Scenarios**:
   - The contract does not adequately handle scenarios where positions may be liquidated. This could lead to unexpected losses for users if the liquidation process is not properly managed.

6. **Access Control Issues**:
   - The contract relies on modifiers like `onlyManagerAndValidSet`, but there may be scenarios where access control could be bypassed if not properly enforced. It is crucial to ensure that only authorized users can execute sensitive functions.

7. **Inadequate Event Emission**:
   - While the contract emits events for significant actions, there may be other critical state changes that do not emit events, making it difficult to track the contract's state and actions effectively.

8. **Gas Limit Issues**:
   - The contract has a limit on the number of positions that can be opened in a single transaction (`maxPerpPositionsPerSet`). If this limit is reached, it could lead to failed transactions or excessive gas costs.

### Comprehensive Analysis Report:

The `PerpV2LeverageModule` contract is designed to facilitate leveraged trading using the PerpV2 protocol. While it incorporates several best practices, including the use of OpenZeppelin's libraries for safe math operations and access control, it still presents multiple security vulnerabilities that could be exploited.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect; however, the contract must ensure that all state changes occur before any external calls to prevent reentrancy attacks.

2. **Input Validation**: The lack of thorough input validation in critical functions poses a risk. Implementing strict checks on input parameters can mitigate potential misuse.

3. **Arithmetic Safety**: Although `SignedSafeMath` is used, developers should ensure that all arithmetic operations are safeguarded, especially in functions that handle user funds.

4. **Sandwich Attack Mitigation**: The contract should encourage the use of the `SlippageIssuanceModule` to protect users from sandwich attacks, and additional measures could be implemented to further secure trades.

5. **Liquidation Handling**: The contract should implement robust mechanisms for handling liquidations to protect users from unexpected losses.

6. **Access Control**: Continuous auditing of access control mechanisms is necessary to prevent unauthorized access to sensitive functions.

7. **Event Emission**: Enhancing event logging for all critical state changes will improve transparency and allow for better tracking of contract activity.

8. **Gas Limit Management**: The contract should include mechanisms to handle scenarios where the gas limit is reached, ensuring that users are informed and can take appropriate action.

In conclusion, while the `PerpV2LeverageModule` contract is a sophisticated implementation for leveraged trading, it requires careful attention to security vulnerabilities. Addressing the identified issues will enhance the contract's robustness and protect users from potential exploits. Regular audits and updates should be conducted to ensure ongoing security and compliance with best practices in smart contract development.

[2024-01-09 05:28:32 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `PerpV2LeverageModule`, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., to the Perp protocol) that could potentially be exploited if not properly managed. Care should be taken to ensure that state changes occur before external calls.

2. **Lack of Input Validation**:
   - The contract does not thoroughly validate inputs in several functions. For instance, in the `trade` function, there is no check to ensure that the `_baseQuantityUnits` and `_quoteBoundQuantityUnits` are within acceptable limits, which could lead to unexpected behavior or losses.

3. **Arithmetic Overflows/Underflows**:
   - While the contract uses `SignedSafeMath`, it is essential to ensure that all arithmetic operations are consistently protected against overflows and underflows, especially in critical functions like `trade`, `deposit`, and `withdraw`.

4. **Potential for Sandwich Attacks**:
   - The contract mentions the risk of sandwich attacks during issuance and redemption processes. If users do not use the `SlippageIssuanceModule`, they may be vulnerable to front-running attacks.

5. **Improper Handling of Liquidation Scenarios**:
   - The contract does not adequately handle scenarios where positions may be liquidated. This could lead to unexpected losses for users if the liquidation process is not properly managed.

6. **Access Control Issues**:
   - The contract relies on modifiers like `onlyManagerAndValidSet`, but there may be scenarios where access control could be bypassed if not properly enforced. It is crucial to ensure that only authorized users can execute sensitive functions.

7. **Inadequate Event Emission**:
   - While the contract emits events for significant actions, there may be other critical state changes that do not emit events, making it difficult to track the contract's state and actions effectively.

8. **Gas Limit Issues**:
   - The contract has a limit on the number of positions that can be opened in a single transaction (`maxPerpPositionsPerSet`). If this limit is reached, it could lead to failed transactions or excessive gas costs.

### Comprehensive Analysis Report:

The `PerpV2LeverageModule` contract is designed to facilitate leveraged trading using the PerpV2 protocol. While it incorporates several best practices, including the use of OpenZeppelin's libraries for safe math operations and access control, it still presents multiple security vulnerabilities that could be exploited.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect; however, the contract must ensure that all state changes occur before any external calls to prevent reentrancy attacks.

2. **Input Validation**: The lack of thorough input validation in critical functions poses a risk. Implementing strict checks on input parameters can mitigate potential misuse.

3. **Arithmetic Safety**: Although `SignedSafeMath` is used, developers should ensure that all arithmetic operations are safeguarded, especially in functions that handle user funds.

4. **Sandwich Attack Mitigation**: The contract should encourage the use of the `SlippageIssuanceModule` to protect users from sandwich attacks, and additional measures could be implemented to further secure trades.

5. **Liquidation Handling**: The contract should implement robust mechanisms for handling liquidations to protect users from unexpected losses.

6. **Access Control**: Continuous auditing of access control mechanisms is necessary to prevent unauthorized access to sensitive functions.

7. **Event Emission**: Enhancing event logging for all critical state changes will improve transparency and allow for better tracking of contract activity.

8. **Gas Limit Management**: The contract should include mechanisms to handle scenarios where the gas limit is reached, ensuring that users are informed and can take appropriate action.

In conclusion, while the `PerpV2LeverageModule` contract is a sophisticated implementation for leveraged trading, it requires careful attention to security vulnerabilities. Addressing the identified issues will enhance the contract's robustness and protect users from potential exploits. Regular audits and updates should be conducted to ensure ongoing security and compliance with best practices in smart contract development.

[2024-01-09 05:28:32 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 05:28:33 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '/\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport "@openzeppelin/contracts/math/SignedSafeMath.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";\n\nimport { PerpV2 } from "../integration/lib/PerpV2.sol";\nimport { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";\nimport { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";\nimport { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";\nimport { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";\nimport { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";\nimport { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";\nimport { IVault } from "../../interfaces/external/perp-v2/IVault.sol";\nimport { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";\nimport { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";\nimport { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";\n\n/\n * @title PerpV2LeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account\n * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token\n * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of\n * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.\n \n * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit\n * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.\n * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the\n * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.\n \n * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current\n * value of the Set\'s perpetual position. The current value can be calculated from getPositionNotionalInfo.\n /\ncontract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {\n    using PerpV2 for ISetToken;\n    using PreciseUnitMath for int256;\n    using SignedSafeMath for int256;\n    using UnitConversionUtils for int256;\n    using UniswapV3Math for uint160;\n    using UniswapV3Math for uint256;\n    using UnitConversionUtils for uint256;\n    using AddressArrayUtils for address[];\n\n    / ============ Structs ============ */\n\n    struct ActionInfo {\n        ISetToken setToken;\n        address baseToken;              // Virtual token minted by the Perp protocol\n        bool isBuy;                     // When true, baseToken is being bought, when false, sold\n        uint256 baseTokenAmount;        // Base token quantity in 1018 decimals\n        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see _createActionInfoNotional for details)\n    }\n\n    struct PositionNotionalInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseBalance;             // Base position notional quantity in 1018 decimals. When negative, position is short\n        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short\n    }\n\n    struct PositionUnitInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseUnit;                // Base position unit. When negative, position is short\n        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short\n    }\n\n    // Note: when pendingFundingPayments is positive it will be credited to account on settlement,\n    // when negative it\'s a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value\n    // with the opposite meaning, e.g positively signed payments are owed by account to system).\n    struct AccountInfo {\n        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 1018 decimals\n        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 1018 decimals not yet settled to vault\n        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 1018 decimals\n        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account\n    }\n\n    / ============ Events ============ /\n\n    /\n     * @dev Emitted on trade\n     * @param _setToken         Instance of SetToken\n     * @param _baseToken        Virtual token minted by the Perp protocol\n     * @param _deltaBase        Change in baseToken position size resulting from trade\n     * @param _deltaQuote       Change in vUSDC position size resulting from trade\n     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade\n     * @param _isBuy            True when baseToken is being bought, false when being sold\n     */\n    event PerpTraded(\n        ISetToken indexed _setToken,\n        address indexed _baseToken,\n        uint256 indexed _deltaBase,\n        uint256 _deltaQuote,\n        uint256 _protocolFee,\n        bool _isBuy\n    );\n\n    /\n     * @dev Emitted on deposit (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being deposited as collateral (USDC)\n     * @param _amountDeposited      Amount of collateral being deposited into Perp\n     /\n    event CollateralDeposited(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountDeposited\n    );\n\n    /\n     * @dev Emitted on withdraw (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being withdrawn as collateral (USDC)\n     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp\n     /\n    event CollateralWithdrawn(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountWithdrawn\n    );\n\n    / ============ Constants ============ /\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it\'s settlement and collateral token\n    IERC20 public immutable collateralToken;\n\n    // Decimals of collateral token. We set this in the constructor for later reading\n    uint8 internal immutable collateralDecimals;\n\n    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances\n    IAccountBalance public immutable perpAccountBalance;\n\n    // PerpV2 contract which provides a trading API\n    IClearingHouse public immutable perpClearingHouse;\n\n    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances\n    IExchange public immutable perpExchange;\n\n    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances\n    IVault public immutable perpVault;\n\n    // PerpV2 contract which makes it possible to simulate a trade before it occurs\n    IQuoter public immutable perpQuoter;\n\n    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools\n    IMarketRegistry public immutable perpMarketRegistry;\n\n    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction\n    // during issuance/redemption. maxPerpPositionsPerSet is a safe limit set by governance taking Optimism\'s block gas limit into account.\n    uint256 public maxPerpPositionsPerSet;\n\n    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.\n    // Array is updated when new positions are opened or old positions are zeroed out.\n    mapping(ISetToken =&gt; address[]) internal positions;\n\n    / ============ Constructor ============ /\n\n    /\n     * @dev Sets external PerpV2 Protocol contract addresses. Sets collateralToken and collateralDecimals\n     * to the Perp vault\'s settlement token (USDC) and its decimals, respectively.\n     \n     * @param _controller               Address of controller contract\n     * @param _perpVault                Address of Perp Vault contract\n     * @param _perpQuoter               Address of Perp Quoter contract\n     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract\n     /\n    constructor(\n        IController _controller,\n        IVault _perpVault,\n        IQuoter _perpQuoter,\n        IMarketRegistry _perpMarketRegistry,\n        uint256 _maxPerpPositionsPerSet\n    )\n        public\n        ModuleBase(_controller)\n        SetTokenAccessible(_controller)\n    {\n        // Use temp variables to initialize immutables\n        address tempCollateralToken = _perpVault.getSettlementToken();\n        collateralToken = IERC20(tempCollateralToken);\n        collateralDecimals = ERC20(tempCollateralToken).decimals();\n\n        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());\n        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());\n        perpExchange = IExchange(_perpVault.getExchange());\n        perpVault = _perpVault;\n        perpQuoter = _perpQuoter;\n        perpMarketRegistry = _perpMarketRegistry;\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the\n     * allowed list or anySetAllowed needs to be true.\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     /\n    function initialize(\n        ISetToken _setToken\n    )\n        public\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n        onlyAllowedSet(_setToken)\n    {\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(\n            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),\n            "Issuance not initialized"\n        );\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {\n                // This module registered itself on modules[i] issuance module.\n            } catch {\n                // Try will fail if modules[i] is not an instance of IDebtIssuanceModule and does not\n                // implement the registerToIssuanceModule function, or if the registerToIssuanceModule\n                // function call reverted. Irrespective of the reason for failure, continue to the next module.\n            }\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.\n     * Providing a positive value for _baseQuantityUnits buys vToken on UniswapV3 via Perp\'s ClearingHouse,\n     * Providing a negative value sells the token. _quoteBoundQuantityUnits defines a min-receive-like slippage\n     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.\n     \n     * NOTE: This method doesn\'t update the externalPositionUnit because it is a function of UniswapV3 virtual\n     * token market prices and needs to be generated on the fly to be meaningful.\n     \n     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.\n     \n     * As a user when levering, e.g increasing the magnitude of your position, you\'d trade as below\n     * | ----------------------------------------------------------------------------------------------- |\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits |\n     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |\n     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |\n     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |\n     * | ----------------------------------------------------------------------------------------------- |\n     \n     * As a user when delevering by partially closing your position, you\'d trade as below\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when completely closing a position, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |\n     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _baseToken                    Address virtual token being traded\n     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units\n     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling\n     /\n    function trade(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteBoundQuantityUnits\n    )\n        public\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        ActionInfo memory actionInfo = _createAndValidateActionInfo(\n            _setToken,\n            _baseToken,\n            _baseQuantityUnits,\n            _quoteBoundQuantityUnits\n        );\n\n        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);\n\n        _updatePositionList(_setToken, _baseToken);\n\n        emit PerpTraded(\n            _setToken,\n            _baseToken,\n            deltaBase,\n            deltaQuote,\n            protocolFee,\n            actionInfo.isBuy\n        );\n    }\n\n    /\n     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing\n     * the size of the Perp account external position. This method is useful for establishing initial\n     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit\n     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference\n     * between these made up as automatically "issued" margin debt in the PerpV2 system.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units\n     /\n    function deposit(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");\n\n        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);\n\n        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);\n    }\n\n    /\n     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on\n     * the SetToken. This method is useful when adjusting the overall composition of a Set which has\n     * a Perp account external position as one of several components.\n     \n     * NOTE: Within PerpV2, withdraw settles owedRealizedPnl and any pending funding payments\n     * to the Perp vault prior to transfer.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units\n     */\n    function withdraw(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");\n\n        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);\n\n        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);\n    }\n\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes\n     * position mappings associated with SetToken.\n     \n     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.\n     /\n    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).\n        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.\n        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());\n        require(\n            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,\n            "Account balance exists"\n        );\n\n        // positions[setToken] mapping stores an array of addresses. The base token addresses are removed from the array when the\n        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should\n        // already be empty, and the mapping can be deleted directly.\n        delete positions[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     \n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then\n     * this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE\n     * during issue. Trades into current positions and sets the collateralToken\'s externalPositionUnit so that\n     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage\n     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current\n     * Set holders.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     /\n    function moduleIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        public\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);\n\n        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing\n     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the externalPositionUnit\n     * equal to the realizable value of account in position units (as measured by the trade outcomes for\n     * this redemption). Any owedRealizedPnl and pending funding payments are socialized in this step so\n     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     /\n    function moduleRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);\n\n        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits\n     * collateral into Perp protocol from SetToken default position.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to issue\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.\n            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());\n\n            _deposit(_setToken, usdcTransferInNotionalQuantity);\n        }\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws\n     * collateral from Perp protocol to SetToken default position without updating the default position unit.\n     * Called by issuance module\'s resolveEquityPositions method which immediately transfers the collateral\n     * component from SetToken to redeemer after this hook executes.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());\n\n            _withdraw(_setToken, usdcTransferOutNotionalQuantity);\n        }\n    }\n\n    / ============ External Setter Functions ============ /\n\n    /\n     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.\n     \n     * @param _maxPerpPositionsPerSet       New max perpetual positions per set\n     /\n    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * issuing a quantity of SetToken, representing the amount of collateral that would need to\n     * be transferred in per SetToken. Values in the returned arrays map to the same index in the\n     * SetToken\'s components array\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     /\n    function getIssuanceAdjustments(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        override\n        returns (int256[] memory, int256[] memory)\n    {\n        address[] memory components = _setToken.getComponents();\n\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.\n     * Values in the returned arrays map to the same index in the SetToken\'s components array.\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     */\n    function getRedemptionAdjustments(\n        ISetToken setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        returns (int256[] memory, int256[] memory )\n    {\n        address[] memory components = _setToken.getComponents();\n\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n\n    /\n     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     \n     *         + baseToken: address,\n     *         + baseBalance:  baseToken balance as notional quantity (1018)\n     *         + quoteBalance: USDC quote asset balance as notional quantity (1018)\n     /\n    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo;\n\n        for(uint i = 0; i &lt; positionLength; i++){\n            address baseToken = positionList[i];\n            positionInfo[i] = PositionNotionalInfo({\n                baseToken: baseToken,\n                baseBalance: perpAccountBalance.getBase(\n                    address(_setToken),\n                    baseToken\n                ),\n                quoteBalance: perpAccountBalance.getQuote(\n                    address(_setToken),\n                    baseToken\n                )\n            });\n        }\n\n        return positionInfo;\n    }\n\n    /\n     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     *\n     *         + baseToken: address,\n     *         + baseUnit:  baseToken balance as position unit (1018)\n     *         + quoteUnit: USDC quote asset balance as position unit (1018)\n     */\n    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionNotionalInfo.length;\n        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo;\n\n        for(uint i = 0; i &lt; positionLength; i++){\n            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];\n            positionUnitInfo[i] = PositionUnitInfo({\n                baseToken: currentPosition.baseToken,\n                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),\n                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)\n            });\n        }\n\n        return positionUnitInfo;\n    }\n\n\n    /\n     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide\n     * (rather than position specific) balance info\n     \n     * @param  _setToken            Instance of the SetToken\n     \n     * @return accountInfo          struct with properties for:\n     \n     *         + collateral balance (1018, regardless of underlying collateral decimals)\n     *         + owed realized Pnl(10**18)\n     *         + pending funding payments (10**18)\n     *         + net quote balance (10**18)\n     */\n    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {\n        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));\n\n        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"\n        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.\n        // We are flipping its sign here to reflect its settlement value.\n        accountInfo = AccountInfo({\n            collateralBalance: _getCollateralBalance(_setToken),\n            owedRealizedPnl: owedRealizedPnl,\n            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),\n            netQuoteBalance: _getNetQuoteBalance(_setToken)\n        });\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.\n     * This method implements the core logic to replicate positions during issuance and redemption. Syncs\n     * thepositionslist before starting (because positions may have liquidated). Cycles through\n     * each position, tradingbasePositionUnit * issueOrRedeemQuantityand calculates the amount of\n     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any\n     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders\n     * appropriately. The hook which invokes this method sets the SetToken\'s externalPositionUnit using\n     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module\n     * which reads this value.\n     *\n     * The general formula for determiningaccountValueper Set is:\n     *\n     *accountValue = collateral                                &lt;---\n     *               + owedRealizedPnl                               }   totalCollateralValue\n     *               + pendingFundingPayment                     &lt;---\n     *               + netQuoteBalance                           neg. when long, pos. when short\n     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short\n     \n     * (See docs for _calculatePartialAccountValuePositionUnit below for more detail about the\n     * account value components).\n     \n     * NOTE: On issuance, this hook is run BEFORE USDC is transferred in and deposited to the Perp\n     * vault to pay for the issuer\'s Sets. This trading temporarily spikes the Perp account\'s\n     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to\n     * a multiple of the current Perp account value (will vary depending on Set\'s leverage ratio).\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     * @param _isIssue              If true, invocation is for issuance, redemption otherwise\n     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)\n     * @return int256               Amount of collateral to transfer in/out in position units\n     /\n    function _executePositionTrades(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        bool _isIssue,\n        bool _isSimulation\n    )\n        internal\n        returns (int256)\n    {\n        _syncPositionList(_setToken);\n        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();\n\n        // Note: issued naming convention used here for brevity. This logic is also run on redemption\n        // and variable may refer to the value which will be redeemed.\n        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);\n\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n\n        for(uint i = 0; i &lt; positionLength; i++) {\n            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);\n\n            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,\n            // e.g selling base when long, buying base when short\n            ActionInfo memory actionInfo = _createActionInfoNotional(\n                _setToken,\n                positionInfo[i].baseToken,\n                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),\n                0\n            );\n\n            // Execute or simulate trade.\n            // deltaQuote is always a positive number\n            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);\n\n            // slippage is borne by the issuer\n            accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :\n                accountValueIssued.sub(deltaQuote.toInt256());\n        }\n\n        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the\n        // account could be bankrupt and we represent that as zero.\n        if (accountValueIssued &lt;= 0) {\n            return 0;\n        }\n\n        // Return value in collateral decimals (e.g USDC = 6)\n        // Use preciseDivCeil when issuing to ensure we don\'t under-collateralize due to rounding error\n        return (_isIssue)\n            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)\n            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);\n    }\n\n    /\n     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,\n     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,\n     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,\n     * and to which existing position values are added when calculating the externalPositionUnit.\n     \n     * @param _setToken             Instance of the SetToken\n     * @return accountValue         Partial account value in position units\n     /\n    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {\n        AccountInfo memory accountInfo = getAccountInfo(_setToken);\n\n        accountValue = accountInfo.collateralBalance\n            .add(accountInfo.owedRealizedPnl)\n            .add(accountInfo.pendingFundingPayments)\n            .add(accountInfo.netQuoteBalance)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n    }\n\n    /\n     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault\n     * Updates the collateral token default position unit. This function is called directly by\n     * the componentIssue hook, skipping external position unit setting because that method is assumed\n     * to be the end of a call sequence (e.g manager will not need to read the updated value)\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit\n     /\n    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        _setToken.invokeApprove(\n            address(collateralToken),\n            address(perpVault),\n            _collateralNotionalQuantity\n        );\n\n        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n\n    /\n     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit\n     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.\n     \n     * NOTE: This flow is only used when invoking the external deposit function - it converts collateral\n     * quantity units into a notional quantity.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit\n     * @return uint256                      Notional quantity deposited\n     /\n    function _depositAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n\n        _deposit(_setToken, collateralNotionalQuantity);\n\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n\n        return collateralNotionalQuantity;\n    }\n\n    /\n     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault\n     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,\n     * skipping position unit state updates because the funds withdrawn to SetToken are immediately\n     * forwarded to feeRecipient and SetToken owner respectively.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw\n     /\n    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        if (_collateralNotionalQuantity == 0) return;\n\n        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n\n    /\n     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken\n     * externalPositionUnit (so Manager contracts have a value they can base calculations for further\n     * trading on within the same transaction), and the collateral token default position unit.\n     \n     * NOTE: This flow is only used when invoking the external withdraw function - it converts\n     * a collateral units quantity into a notional quantity before invoking withdraw.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw\n     * @return uint256                      Notional quantity withdrawn\n     /\n    function _withdrawAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n\n        _withdraw(_setToken, collateralNotionalQuantity);\n\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n\n        return collateralNotionalQuantity;\n    }\n\n    /\n     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)\n     \n     * isBaseToQuote, isExactInput and oppositeAmountBound are configured as below:\n     * | ---------------------------------------------------|---------------------------- |\n     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |\n     * | ------- |-------- |--------|-----------------------|---------------------------- |\n     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |\n     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |\n     * |----------------------------------------------------|---------------------------- |\n     \n     * @param _actionInfo  ActionInfo object\n     * @return uint256     The base position delta resulting from the trade\n     * @return uint256     The quote asset position delta resulting from the trade\n     /\n    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n\n        // When isBaseToQuote is true, baseToken is being sold, when false, bought\n        // When isExactInput is true, amount is the swap input, when false, the swap output\n        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            oppositeAmountBound: _actionInfo.oppositeAmountBound,\n            deadline: PreciseUnitMath.maxUint256(),\n            sqrtPriceLimitX96: 0,\n            referralCode: bytes32(0)\n        });\n\n        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);\n    }\n\n\n    /\n     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)\n     \n     * See _executeTrade method comments for details about isBaseToQuote and isExactInput configuration.\n     \n     * @param _actionInfo   ActionInfo object\n     * @return uint256      The base position delta resulting from the trade\n     * @return uint256      The quote asset position delta resulting from the trade\n     */\n    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n        IQuoter.SwapParams memory params = IQuoter.SwapParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            sqrtPriceLimitX96: 0\n        });\n\n        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);\n        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);\n    }\n\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     \n     * @param  _setToken            Instance of SetToken\n     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)\n     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)\n     /\n    function _accrueProtocolFee(\n        ISetToken _setToken,\n        uint256 _exchangedQuantity\n    )\n        internal\n        returns(uint256)\n    {\n        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);\n\n        _withdraw(_setToken, protocolFeeInPreciseUnits);\n\n        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);\n\n        return protocolFeeInPreciseUnits;\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to\n     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If\n     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is\n     * only called from trade - the issue/redeem flow uses createActionInfoNotional directly.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _baseToken            Address of base token being traded into/out of\n     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits\n     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits\n     \n     * @return ActionInfo           Instance of constructed ActionInfo struct\n     */\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteReceiveUnits\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        require(_baseQuantityUnits != 0, "Amount is 0");\n        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");\n\n        uint256 totalSupply = _setToken.totalSupply();\n\n        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);\n        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());\n\n        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()\n            ? baseBalance.neg()         // To close position completely\n            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());\n\n        return _createActionInfoNotional(\n            _setToken,\n            _baseToken,\n            baseNotional,\n            _quoteReceiveUnits.preciseMul(totalSupply)\n        );\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates\n     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method\n     * is called during issue and redeem via _executePositionTrades and during trade via _createAndValidateActionInfo.\n     \n     * (See _executeTrade method comments for details about oppositeAmountBound configuration)\n     \n     * @param _setToken                 Instance of the SetToken\n     * @param _baseToken                Address of base token being traded into/out of\n     * @param _baseTokenQuantity        Notional quantity of baseToken to trade\n     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying\n     \n     * @return ActionInfo               Instance of constructed ActionInfo struct\n     /\n    function _createActionInfoNotional(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseTokenQuantity,\n        uint256 _quoteReceiveQuantity\n    )\n        internal\n        pure\n        returns(ActionInfo memory)\n    {\n        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called\n        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo\n        // that quantity is 0 for inputs to trade.\n        bool isBuy = _baseTokenQuantity &gt; 0;\n\n        return ActionInfo({\n            setToken: _setToken,\n            baseToken: _baseToken,\n            isBuy: isBuy,\n            baseTokenAmount: _baseTokenQuantity.abs(),\n            oppositeAmountBound: _quoteReceiveQuantity\n        });\n    }\n\n    /\n     * @dev Update position address array if a token has been newly added or completely sold off\n     * during lever/delever\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     /\n    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {\n        address[] memory positionList = positions[_setToken];\n        bool hasBaseToken = positionList.contains(_baseToken);\n\n        if (hasBaseToken) {\n            if(!_hasBaseBalance(_setToken, _baseToken)) {\n                positions[_setToken].removeStorage(_baseToken);\n            }\n        } else {\n            require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");\n            positions[_setToken].push(_baseToken);\n        }\n    }\n\n    /\n     * @dev Removes any zero balance positions from the positions array. This\n     * sync is done before issuance and redemption to account for positions that may have\n     * been liquidated.\n     \n     * @param _setToken         Instance of the SetToken\n     /\n    function _syncPositionList(ISetToken _setToken) internal {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            address currPosition = positionList[i];\n            if (!_hasBaseBalance(_setToken, currPosition)) {\n                positions[_setToken].removeStorage(currPosition);\n            }\n        }\n    }\n\n    /\n     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have\n     * no balance and return false\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     * @return bool         True if a non-dust base token balance exists, false otherwise\n     /\n    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {\n        int256 baseBalanceUnit = perpAccountBalance\n            .getBase(address(_setToken), _baseToken)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n\n        return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1);\n    }\n\n    /\n     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol\n     \n     * @param  _baseToken           Address of virtual token to price\n     * @return price                Mid-point price of virtual token in UniswapV3 AMM market\n     /\n    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {\n        address pool = perpMarketRegistry.getPool(_baseToken);\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();\n        return priceX96.formatX96ToX10_18();\n    }\n\n    /\n     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per\n     * SetToken\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       External position unit\n     /\n    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalPositionValue = 0;\n\n        for (uint i = 0; i &lt; positionLength; i++ ) {\n            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();\n            totalPositionValue = totalPositionValue.add(\n                positionInfo[i].baseBalance.preciseMul(spotPrice)\n            );\n        }\n\n        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)\n            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));\n\n        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);\n    }\n\n    /\n     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       Collateral balance as an 18 decimal vUSDC quote value\n     /\n    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {\n        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);\n    }\n\n    /\n     * @dev Retrieves net quote balance of all open positions\n     \n     * @param _setToken             Instance of SetToken\n     * @return netQuoteBalance      Net quote balance of all open positions\n     /\n    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            netQuoteBalance = netQuoteBalance.add(\n                perpAccountBalance.getQuote(address(_setToken), positionList[i])\n            );\n        }\n    }\n\n    /\n     * @dev Returns issuance or redemption adjustments in the format expected by SlippageIssuanceModule.\n     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated\n     * externalPositionUnit (new) and set in an equityAdjustments array which is the same length as\n     * the SetToken\'s components array, at the same index the collateral token occupies in the components\n     * array. All other values are left unset (0). An empty-value components length debtAdjustments\n     * array is also returned.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _components                       Array of components held by the SetToken\n     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit\n     * @return int256[]                         Components-length array with equity adjustment value at appropriate index\n     * @return int256[]                         Components-length array of zeroes (debt adjustments)\n     /\n    function _formatAdjustments(\n        ISetToken _setToken,\n        address[] memory _components,\n        int256 _newExternalPositionUnit\n    )\n        internal\n        view\n        returns (int256[] memory, int256[] memory)\n    {\n        int256[] memory equityAdjustments = new int256;\n        int256[] memory debtAdjustments = new int256;\n\n        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));\n\n        if (isIn) {\n            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(\n                address(collateralToken),\n                address(this)\n            );\n\n            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);\n        }\n\n        return (equityAdjustments, debtAdjustments);\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:28:33 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:28:33 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 05:28:36 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:28:36 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 26495
completion_tokens: 1
total_tokens: 26496
cost: $-1.000000


[2024-01-09 05:28:36 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

###

[2024-01-09 05:28:36 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 05:28:36 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 05:28:37 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 05:28:37 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:28:37 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 05:28:48 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 05:28:48 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13306
completion_tokens: 808
total_tokens: 14114
cost: $-1.000000


[2024-01-09 05:28:48 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Based on the provided Solidity smart contract code for the `PerpV2LeverageModule`, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `_withdraw`, `_deposit`, and `_executeTrade`) that could potentially be exploited if not properly managed. Ensure that state changes occur before external calls to mitigate this risk.

2. **Lack of Input Validation**:
   - The contract does not adequately validate inputs in several functions. For instance, functions like `trade`, `deposit`, and `withdraw` should include checks to ensure that the amounts being processed are within acceptable limits to prevent underflows or overflows.

3. **Potential for Integer Overflow/Underflow**:
   - While the contract uses `SignedSafeMath`, there are still areas where unchecked arithmetic could lead to vulnerabilities, especially when calculating balances or positions. It is crucial to ensure that all arithmetic operations are safe.

4. **Improper Handling of External Calls**:
   - The contract makes several external calls to other contracts (e.g., `perpVault`, `perpClearingHouse`). If these contracts are compromised or behave unexpectedly, it could lead to loss of funds or unintended behavior. Implement checks to ensure that these external calls succeed.

5. **Protocol Fee Calculation**:
   - The calculation of protocol fees in `_accrueProtocolFee` could lead to issues if the fee structure changes or if the fee is not correctly accounted for. Ensure that the fee calculation logic is robust and tested.

6. **Lack of Access Control**:
   - While the contract has some access control mechanisms (e.g., `onlyManagerAndValidSet`), it is essential to ensure that all sensitive functions are adequately protected to prevent unauthorized access.

7. **Potential for Front-Running Attacks**:
   - The contract's trading functions could be susceptible to front-running attacks, especially since they rely on external market prices. Implementing measures such as time-locks or commit-reveal schemes could help mitigate this risk.

8. **State Variable Visibility**:
   - Some state variables are marked as `internal` or `public` without clear necessity. Consider marking them as `private` if they are not intended to be accessed externally to reduce the attack surface.

9. **Event Emission**:
   - While the contract emits events for significant actions, ensure that all critical state changes are logged to provide a clear audit trail for future analysis.

### Comprehensive Analysis Report:

The `PerpV2LeverageModule` contract presents a sophisticated approach to leveraged trading within the PerpV2 protocol. However, several security vulnerabilities have been identified that could potentially compromise the integrity and safety of the contract. 

The use of `ReentrancyGuard` is a positive step towards preventing reentrancy attacks, but the presence of multiple external calls necessitates careful management of state changes to avoid vulnerabilities. Input validation is lacking in several areas, which could lead to unexpected behavior or exploitation of the contract.

While the contract employs `SignedSafeMath` to mitigate overflow and underflow risks, additional checks should be implemented to ensure all arithmetic operations are safe. The reliance on external contracts introduces risks, and it is crucial to validate the success of these calls to prevent loss of funds.

Access control mechanisms are in place, but it is vital to ensure that all sensitive functions are adequately protected. The potential for front-running attacks should also be addressed, as this could lead to significant financial losses for users.

In conclusion, while the `PerpV2LeverageModule` contract demonstrates a robust framework for leveraged trading, it requires further enhancements in security practices, input validation, and access control to ensure the safety and integrity of user funds. Regular audits and updates to the contract will be essential to maintain its security posture in the evolving landscape of decentralized finance.

[2024-01-09 05:28:48 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `PerpV2LeverageModule`, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `_withdraw`, `_deposit`, and `_executeTrade`) that could potentially be exploited if not properly managed. Ensure that state changes occur before external calls to mitigate this risk.

2. **Lack of Input Validation**:
   - The contract does not adequately validate inputs in several functions. For instance, functions like `trade`, `deposit`, and `withdraw` should include checks to ensure that the amounts being processed are within acceptable limits to prevent underflows or overflows.

3. **Potential for Integer Overflow/Underflow**:
   - While the contract uses `SignedSafeMath`, there are still areas where unchecked arithmetic could lead to vulnerabilities, especially when calculating balances or positions. It is crucial to ensure that all arithmetic operations are safe.

4. **Improper Handling of External Calls**:
   - The contract makes several external calls to other contracts (e.g., `perpVault`, `perpClearingHouse`). If these contracts are compromised or behave unexpectedly, it could lead to loss of funds or unintended behavior. Implement checks to ensure that these external calls succeed.

5. **Protocol Fee Calculation**:
   - The calculation of protocol fees in `_accrueProtocolFee` could lead to issues if the fee structure changes or if the fee is not correctly accounted for. Ensure that the fee calculation logic is robust and tested.

6. **Lack of Access Control**:
   - While the contract has some access control mechanisms (e.g., `onlyManagerAndValidSet`), it is essential to ensure that all sensitive functions are adequately protected to prevent unauthorized access.

7. **Potential for Front-Running Attacks**:
   - The contract's trading functions could be susceptible to front-running attacks, especially since they rely on external market prices. Implementing measures such as time-locks or commit-reveal schemes could help mitigate this risk.

8. **State Variable Visibility**:
   - Some state variables are marked as `internal` or `public` without clear necessity. Consider marking them as `private` if they are not intended to be accessed externally to reduce the attack surface.

9. **Event Emission**:
   - While the contract emits events for significant actions, ensure that all critical state changes are logged to provide a clear audit trail for future analysis.

### Comprehensive Analysis Report:

The `PerpV2LeverageModule` contract presents a sophisticated approach to leveraged trading within the PerpV2 protocol. However, several security vulnerabilities have been identified that could potentially compromise the integrity and safety of the contract. 

The use of `ReentrancyGuard` is a positive step towards preventing reentrancy attacks, but the presence of multiple external calls necessitates careful management of state changes to avoid vulnerabilities. Input validation is lacking in several areas, which could lead to unexpected behavior or exploitation of the contract.

While the contract employs `SignedSafeMath` to mitigate overflow and underflow risks, additional checks should be implemented to ensure all arithmetic operations are safe. The reliance on external contracts introduces risks, and it is crucial to validate the success of these calls to prevent loss of funds.

Access control mechanisms are in place, but it is vital to ensure that all sensitive functions are adequately protected. The potential for front-running attacks should also be addressed, as this could lead to significant financial losses for users.

In conclusion, while the `PerpV2LeverageModule` contract demonstrates a robust framework for leveraged trading, it requires further enhancements in security practices, input validation, and access control to ensure the safety and integrity of user funds. Regular audits and updates to the contract will be essential to maintain its security posture in the evolving landscape of decentralized finance.

[2024-01-09 05:28:52 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport "@openzeppelin/contracts/math/SignedSafeMath.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";\n\nimport { PerpV2 } from "../integration/lib/PerpV2.sol";\nimport { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";\nimport { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";\nimport { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";\nimport { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";\nimport { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";\nimport { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";\nimport { IVault } from "../../interfaces/external/perp-v2/IVault.sol";\nimport { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";\nimport { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";\nimport { IController } from "../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";\nimport { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";\nimport { ISetToken } from "../../interfaces/ISetToken.sol";\nimport { ModuleBase } from "../lib/ModuleBase.sol";\nimport { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";\nimport { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";\nimport { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";\nimport { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";\n\n/\n * @title PerpV2LeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account\n * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token\n * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of\n * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.\n \n * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit\n * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.\n * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the\n * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.\n \n * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current\n * value of the Set\'s perpetual position. The current value can be calculated from getPositionNotionalInfo.\n /\ncontract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {\n    using PerpV2 for ISetToken;\n    using PreciseUnitMath for int256;\n    using SignedSafeMath for int256;\n    using UnitConversionUtils for int256;\n    using UniswapV3Math for uint160;\n    using UniswapV3Math for uint256;\n    using UnitConversionUtils for uint256;\n    using AddressArrayUtils for address[];\n\n    / ============ Structs ============ */\n\n    struct ActionInfo {\n        ISetToken setToken;\n        address baseToken;              // Virtual token minted by the Perp protocol\n        bool isBuy;                     // When true, baseToken is being bought, when false, sold\n        uint256 baseTokenAmount;        // Base token quantity in 1018 decimals\n        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see _createActionInfoNotional for details)\n    }\n\n    struct PositionNotionalInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseBalance;             // Base position notional quantity in 1018 decimals. When negative, position is short\n        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short\n    }\n\n    struct PositionUnitInfo {\n        address baseToken;              // Virtual token minted by the Perp protocol\n        int256 baseUnit;                // Base position unit. When negative, position is short\n        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short\n    }\n\n    // Note: when pendingFundingPayments is positive it will be credited to account on settlement,\n    // when negative it\'s a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value\n    // with the opposite meaning, e.g positively signed payments are owed by account to system).\n    struct AccountInfo {\n        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 1018 decimals\n        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 1018 decimals not yet settled to vault\n        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 1018 decimals\n        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account\n    }\n\n    / ============ Events ============ /\n\n    /\n     * @dev Emitted on trade\n     * @param _setToken         Instance of SetToken\n     * @param _baseToken        Virtual token minted by the Perp protocol\n     * @param _deltaBase        Change in baseToken position size resulting from trade\n     * @param _deltaQuote       Change in vUSDC position size resulting from trade\n     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade\n     * @param _isBuy            True when baseToken is being bought, false when being sold\n     */\n    event PerpTraded(\n        ISetToken indexed _setToken,\n        address indexed _baseToken,\n        uint256 indexed _deltaBase,\n        uint256 _deltaQuote,\n        uint256 _protocolFee,\n        bool _isBuy\n    );\n\n    /\n     * @dev Emitted on deposit (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being deposited as collateral (USDC)\n     * @param _amountDeposited      Amount of collateral being deposited into Perp\n     /\n    event CollateralDeposited(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountDeposited\n    );\n\n    /\n     * @dev Emitted on withdraw (not issue or redeem)\n     * @param _setToken             Instance of SetToken\n     * @param _collateralToken      Token being withdrawn as collateral (USDC)\n     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp\n     /\n    event CollateralWithdrawn(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralToken,\n        uint256 indexed _amountWithdrawn\n    );\n\n    / ============ Constants ============ /\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it\'s settlement and collateral token\n    IERC20 public immutable collateralToken;\n\n    // Decimals of collateral token. We set this in the constructor for later reading\n    uint8 internal immutable collateralDecimals;\n\n    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances\n    IAccountBalance public immutable perpAccountBalance;\n\n    // PerpV2 contract which provides a trading API\n    IClearingHouse public immutable perpClearingHouse;\n\n    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances\n    IExchange public immutable perpExchange;\n\n    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances\n    IVault public immutable perpVault;\n\n    // PerpV2 contract which makes it possible to simulate a trade before it occurs\n    IQuoter public immutable perpQuoter;\n\n    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools\n    IMarketRegistry public immutable perpMarketRegistry;\n\n    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction\n    // during issuance/redemption. maxPerpPositionsPerSet is a safe limit set by governance taking Optimism\'s block gas limit into account.\n    uint256 public maxPerpPositionsPerSet;\n\n    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.\n    // Array is updated when new positions are opened or old positions are zeroed out.\n    mapping(ISetToken =&gt; address[]) internal positions;\n\n    / ============ Constructor ============ /\n\n    /\n     * @dev Sets external PerpV2 Protocol contract addresses. Sets collateralToken and collateralDecimals\n     * to the Perp vault\'s settlement token (USDC) and its decimals, respectively.\n     \n     * @param _controller               Address of controller contract\n     * @param _perpVault                Address of Perp Vault contract\n     * @param _perpQuoter               Address of Perp Quoter contract\n     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract\n     /\n    constructor(\n        IController _controller,\n        IVault _perpVault,\n        IQuoter _perpQuoter,\n        IMarketRegistry _perpMarketRegistry,\n        uint256 _maxPerpPositionsPerSet\n    )\n        public\n        ModuleBase(_controller)\n        SetTokenAccessible(_controller)\n    {\n        // Use temp variables to initialize immutables\n        address tempCollateralToken = _perpVault.getSettlementToken();\n        collateralToken = IERC20(tempCollateralToken);\n        collateralDecimals = ERC20(tempCollateralToken).decimals();\n\n        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());\n        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());\n        perpExchange = IExchange(_perpVault.getExchange());\n        perpVault = _perpVault;\n        perpQuoter = _perpQuoter;\n        perpMarketRegistry = _perpMarketRegistry;\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the\n     * allowed list or anySetAllowed needs to be true.\n     \n     * @param _setToken             Instance of the SetToken to initialize\n     /\n    function initialize(\n        ISetToken _setToken\n    )\n        public\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n        onlyAllowedSet(_setToken)\n    {\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(\n            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),\n            "Issuance not initialized"\n        );\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {\n                // This module registered itself on modules[i] issuance module.\n            } catch {\n                // Try will fail if modules[i] is not an instance of IDebtIssuanceModule and does not\n                // implement the registerToIssuanceModule function, or if the registerToIssuanceModule\n                // function call reverted. Irrespective of the reason for failure, continue to the next module.\n            }\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.\n     * Providing a positive value for _baseQuantityUnits buys vToken on UniswapV3 via Perp\'s ClearingHouse,\n     * Providing a negative value sells the token. _quoteBoundQuantityUnits defines a min-receive-like slippage\n     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.\n     \n     * NOTE: This method doesn\'t update the externalPositionUnit because it is a function of UniswapV3 virtual\n     * token market prices and needs to be generated on the fly to be meaningful.\n     \n     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.\n     \n     * As a user when levering, e.g increasing the magnitude of your position, you\'d trade as below\n     * | ----------------------------------------------------------------------------------------------- |\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits |\n     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |\n     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |\n     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |\n     * | ----------------------------------------------------------------------------------------------- |\n     \n     * As a user when delevering by partially closing your position, you\'d trade as below\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |\n     * -----------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when completely closing a position, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |\n     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you\'d trade as below\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     * | Type  |  Action         | Goal                      | quoteBoundQuantity        | baseQuantityUnits                                 |\n     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|\n     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |\n     * -------------------------------------------------------------------------------------------------------------------------------------------\n     \n     * @param _setToken                     Instance of the SetToken\n     * @param _baseToken                    Address virtual token being traded\n     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units\n     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling\n     /\n    function trade(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteBoundQuantityUnits\n    )\n        public\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        ActionInfo memory actionInfo = _createAndValidateActionInfo(\n            _setToken,\n            _baseToken,\n            _baseQuantityUnits,\n            _quoteBoundQuantityUnits\n        );\n\n        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);\n\n        _updatePositionList(_setToken, _baseToken);\n\n        emit PerpTraded(\n            _setToken,\n            _baseToken,\n            deltaBase,\n            deltaQuote,\n            protocolFee,\n            actionInfo.isBuy\n        );\n    }\n\n    /\n     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing\n     * the size of the Perp account external position. This method is useful for establishing initial\n     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit\n     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference\n     * between these made up as automatically "issued" margin debt in the PerpV2 system.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units\n     /\n    function deposit(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");\n\n        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);\n\n        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);\n    }\n\n    /\n     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on\n     * the SetToken. This method is useful when adjusting the overall composition of a Set which has\n     * a Perp account external position as one of several components.\n     \n     * NOTE: Within PerpV2, withdraw settles owedRealizedPnl and any pending funding payments\n     * to the Perp vault prior to transfer.\n     \n     * @param  _setToken                    Instance of the SetToken\n     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units\n     */\n    function withdraw(\n      ISetToken _setToken,\n      uint256 _collateralQuantityUnits\n    )\n      public\n      nonReentrant\n      onlyManagerAndValidSet(_setToken)\n    {\n        require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");\n\n        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);\n\n        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);\n    }\n\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes\n     * position mappings associated with SetToken.\n     \n     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.\n     /\n    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).\n        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.\n        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());\n        require(\n            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,\n            "Account balance exists"\n        );\n\n        // positions[setToken] mapping stores an array of addresses. The base token addresses are removed from the array when the\n        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should\n        // already be empty, and the mapping can be deleted directly.\n        delete positions[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     \n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then\n     * this function needs to be called if the debt issuance module is later added and initialized to prevent state\n     * inconsistencies\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE\n     * during issue. Trades into current positions and sets the collateralToken\'s externalPositionUnit so that\n     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage\n     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current\n     * Set holders.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     /\n    function moduleIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        public\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);\n\n        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing\n     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the externalPositionUnit\n     * equal to the realizable value of account in position units (as measured by the trade outcomes for\n     * this redemption). Any owedRealizedPnl and pending funding payments are socialized in this step so\n     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     /\n    function moduleRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        onlyModule(_setToken)\n    {\n        if (_setToken.totalSupply() == 0) return;\n        if (!_setToken.hasExternalPosition(address(collateralToken))) return;\n\n        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);\n\n        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation\n        _setToken.editExternalPositionUnit(\n            address(collateralToken),\n            address(this),\n            newExternalPositionUnit\n        );\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits\n     * collateral into Perp protocol from SetToken default position.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to issue\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.\n            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());\n\n            _deposit(_setToken, usdcTransferInNotionalQuantity);\n        }\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws\n     * collateral from Perp protocol to SetToken default position without updating the default position unit.\n     * Called by issuance module\'s resolveEquityPositions method which immediately transfers the collateral\n     * component from SetToken to redeemer after this hook executes.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken to redeem\n     * @param _component            Address of deposit collateral component\n     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise\n     /\n    function componentRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isEquity\n    )\n        external\n        override\n        onlyModule(_setToken)\n    {\n        if (_isEquity) {\n            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());\n\n            _withdraw(_setToken, usdcTransferOutNotionalQuantity);\n        }\n    }\n\n    / ============ External Setter Functions ============ /\n\n    /\n     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.\n     \n     * @param _maxPerpPositionsPerSet       New max perpetual positions per set\n     /\n    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {\n        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;\n    }\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * issuing a quantity of SetToken, representing the amount of collateral that would need to\n     * be transferred in per SetToken. Values in the returned arrays map to the same index in the\n     * SetToken\'s components array\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     /\n    function getIssuanceAdjustments(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        override\n        returns (int256[] memory, int256[] memory)\n    {\n        address[] memory components = _setToken.getComponents();\n\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n\n    /\n     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for\n     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.\n     * Values in the returned arrays map to the same index in the SetToken\'s components array.\n     \n     * @param _setToken             Instance of SetToken\n     * @param _setTokenQuantity     Number of sets to issue\n     \n     * @return equityAdjustments array containing a single element and an empty debtAdjustments array\n     */\n    function getRedemptionAdjustments(\n        ISetToken setToken,\n        uint256 _setTokenQuantity\n    )\n        external\n        virtual\n        override\n        returns (int256[] memory, int256[] memory )\n    {\n        address[] memory components = _setToken.getComponents();\n\n        if (positions[_setToken].length &gt; 0) {\n            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);\n            return _formatAdjustments(_setToken, components, newExternalPositionUnit);\n        } else {\n            return _formatAdjustments(_setToken, components, 0);\n        }\n    }\n\n    /\n     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     \n     *         + baseToken: address,\n     *         + baseBalance:  baseToken balance as notional quantity (1018)\n     *         + quoteBalance: USDC quote asset balance as notional quantity (1018)\n     /\n    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo;\n\n        for(uint i = 0; i &lt; positionLength; i++){\n            address baseToken = positionList[i];\n            positionInfo[i] = PositionNotionalInfo({\n                baseToken: baseToken,\n                baseBalance: perpAccountBalance.getBase(\n                    address(_setToken),\n                    baseToken\n                ),\n                quoteBalance: perpAccountBalance.getQuote(\n                    address(_setToken),\n                    baseToken\n                )\n            });\n        }\n\n        return positionInfo;\n    }\n\n    /\n     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.\n     \n     * @param _setToken         Instance of SetToken\n     \n     * @return PositionUnitInfo array, in which each element has properties:\n     *\n     *         + baseToken: address,\n     *         + baseUnit:  baseToken balance as position unit (1018)\n     *         + quoteUnit: USDC quote asset balance as position unit (1018)\n     */\n    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionNotionalInfo.length;\n        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo;\n\n        for(uint i = 0; i &lt; positionLength; i++){\n            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];\n            positionUnitInfo[i] = PositionUnitInfo({\n                baseToken: currentPosition.baseToken,\n                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),\n                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)\n            });\n        }\n\n        return positionUnitInfo;\n    }\n\n\n    /\n     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide\n     * (rather than position specific) balance info\n     \n     * @param  _setToken            Instance of the SetToken\n     \n     * @return accountInfo          struct with properties for:\n     \n     *         + collateral balance (1018, regardless of underlying collateral decimals)\n     *         + owed realized Pnl(10**18)\n     *         + pending funding payments (10**18)\n     *         + net quote balance (10**18)\n     */\n    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {\n        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));\n\n        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"\n        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.\n        // We are flipping its sign here to reflect its settlement value.\n        accountInfo = AccountInfo({\n            collateralBalance: _getCollateralBalance(_setToken),\n            owedRealizedPnl: owedRealizedPnl,\n            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),\n            netQuoteBalance: _getNetQuoteBalance(_setToken)\n        });\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.\n     * This method implements the core logic to replicate positions during issuance and redemption. Syncs\n     * thepositionslist before starting (because positions may have liquidated). Cycles through\n     * each position, tradingbasePositionUnit * issueOrRedeemQuantityand calculates the amount of\n     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any\n     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders\n     * appropriately. The hook which invokes this method sets the SetToken\'s externalPositionUnit using\n     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module\n     * which reads this value.\n     *\n     * The general formula for determiningaccountValueper Set is:\n     *\n     *accountValue = collateral                                &lt;---\n     *               + owedRealizedPnl                               }   totalCollateralValue\n     *               + pendingFundingPayment                     &lt;---\n     *               + netQuoteBalance                           neg. when long, pos. when short\n     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short\n     \n     * (See docs for _calculatePartialAccountValuePositionUnit below for more detail about the\n     * account value components).\n     \n     * NOTE: On issuance, this hook is run BEFORE USDC is transferred in and deposited to the Perp\n     * vault to pay for the issuer\'s Sets. This trading temporarily spikes the Perp account\'s\n     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to\n     * a multiple of the current Perp account value (will vary depending on Set\'s leverage ratio).\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of Set to issue\n     * @param _isIssue              If true, invocation is for issuance, redemption otherwise\n     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)\n     * @return int256               Amount of collateral to transfer in/out in position units\n     /\n    function _executePositionTrades(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        bool _isIssue,\n        bool _isSimulation\n    )\n        internal\n        returns (int256)\n    {\n        _syncPositionList(_setToken);\n        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();\n\n        // Note: issued naming convention used here for brevity. This logic is also run on redemption\n        // and variable may refer to the value which will be redeemed.\n        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);\n\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalSupply = _setToken.totalSupply().toInt256();\n\n        for(uint i = 0; i &lt; positionLength; i++) {\n            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);\n\n            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,\n            // e.g selling base when long, buying base when short\n            ActionInfo memory actionInfo = _createActionInfoNotional(\n                _setToken,\n                positionInfo[i].baseToken,\n                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),\n                0\n            );\n\n            // Execute or simulate trade.\n            // deltaQuote is always a positive number\n            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);\n\n            // slippage is borne by the issuer\n            accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :\n                accountValueIssued.sub(deltaQuote.toInt256());\n        }\n\n        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the\n        // account could be bankrupt and we represent that as zero.\n        if (accountValueIssued &lt;= 0) {\n            return 0;\n        }\n\n        // Return value in collateral decimals (e.g USDC = 6)\n        // Use preciseDivCeil when issuing to ensure we don\'t under-collateralize due to rounding error\n        return (_isIssue)\n            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)\n            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);\n    }\n\n    /\n     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,\n     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,\n     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,\n     * and to which existing position values are added when calculating the externalPositionUnit.\n     \n     * @param _setToken             Instance of the SetToken\n     * @return accountValue         Partial account value in position units\n     /\n    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {\n        AccountInfo memory accountInfo = getAccountInfo(_setToken);\n\n        accountValue = accountInfo.collateralBalance\n            .add(accountInfo.owedRealizedPnl)\n            .add(accountInfo.pendingFundingPayments)\n            .add(accountInfo.netQuoteBalance)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n    }\n\n    /\n     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault\n     * Updates the collateral token default position unit. This function is called directly by\n     * the componentIssue hook, skipping external position unit setting because that method is assumed\n     * to be the end of a call sequence (e.g manager will not need to read the updated value)\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit\n     /\n    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        _setToken.invokeApprove(\n            address(collateralToken),\n            address(perpVault),\n            _collateralNotionalQuantity\n        );\n\n        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n\n    /\n     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit\n     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.\n     \n     * NOTE: This flow is only used when invoking the external deposit function - it converts collateral\n     * quantity units into a notional quantity.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit\n     * @return uint256                      Notional quantity deposited\n     /\n    function _depositAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n\n        _deposit(_setToken, collateralNotionalQuantity);\n\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n\n        return collateralNotionalQuantity;\n    }\n\n    /\n     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault\n     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,\n     * skipping position unit state updates because the funds withdrawn to SetToken are immediately\n     * forwarded to feeRecipient and SetToken owner respectively.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw\n     /\n    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {\n        if (_collateralNotionalQuantity == 0) return;\n\n        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);\n    }\n\n    /\n     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken\n     * externalPositionUnit (so Manager contracts have a value they can base calculations for further\n     * trading on within the same transaction), and the collateral token default position unit.\n     \n     * NOTE: This flow is only used when invoking the external withdraw function - it converts\n     * a collateral units quantity into a notional quantity before invoking withdraw.\n     \n     * @param _setToken                     Instance of SetToken\n     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw\n     * @return uint256                      Notional quantity withdrawn\n     /\n    function _withdrawAndUpdatePositions(\n        ISetToken _setToken,\n        uint256 _collateralQuantityUnits\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));\n        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());\n\n        _withdraw(_setToken, collateralNotionalQuantity);\n\n        _setToken.calculateAndEditDefaultPosition(\n            address(collateralToken),\n            _setToken.totalSupply(),\n            initialCollateralPositionBalance\n        );\n\n        _setToken.editExternalPosition(\n            address(collateralToken),\n            address(this),\n            _calculateExternalPositionUnit(_setToken),\n            ""\n        );\n\n        return collateralNotionalQuantity;\n    }\n\n    /\n     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)\n     \n     * isBaseToQuote, isExactInput and oppositeAmountBound are configured as below:\n     * | ---------------------------------------------------|---------------------------- |\n     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |\n     * | ------- |-------- |--------|-----------------------|---------------------------- |\n     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |\n     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |\n     * |----------------------------------------------------|---------------------------- |\n     \n     * @param _actionInfo  ActionInfo object\n     * @return uint256     The base position delta resulting from the trade\n     * @return uint256     The quote asset position delta resulting from the trade\n     /\n    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n\n        // When isBaseToQuote is true, baseToken is being sold, when false, bought\n        // When isExactInput is true, amount is the swap input, when false, the swap output\n        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            oppositeAmountBound: _actionInfo.oppositeAmountBound,\n            deadline: PreciseUnitMath.maxUint256(),\n            sqrtPriceLimitX96: 0,\n            referralCode: bytes32(0)\n        });\n\n        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);\n    }\n\n\n    /\n     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)\n     \n     * See _executeTrade method comments for details about isBaseToQuote and isExactInput configuration.\n     \n     * @param _actionInfo   ActionInfo object\n     * @return uint256      The base position delta resulting from the trade\n     * @return uint256      The quote asset position delta resulting from the trade\n     */\n    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {\n        IQuoter.SwapParams memory params = IQuoter.SwapParams({\n            baseToken: _actionInfo.baseToken,\n            isBaseToQuote: !_actionInfo.isBuy,\n            isExactInput: !_actionInfo.isBuy,\n            amount: _actionInfo.baseTokenAmount,\n            sqrtPriceLimitX96: 0\n        });\n\n        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);\n        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);\n    }\n\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     \n     * @param  _setToken            Instance of SetToken\n     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)\n     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)\n     /\n    function _accrueProtocolFee(\n        ISetToken _setToken,\n        uint256 _exchangedQuantity\n    )\n        internal\n        returns(uint256)\n    {\n        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);\n\n        _withdraw(_setToken, protocolFeeInPreciseUnits);\n\n        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);\n\n        return protocolFeeInPreciseUnits;\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to\n     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If\n     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is\n     * only called from trade - the issue/redeem flow uses createActionInfoNotional directly.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _baseToken            Address of base token being traded into/out of\n     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits\n     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits\n     \n     * @return ActionInfo           Instance of constructed ActionInfo struct\n     */\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseQuantityUnits,\n        uint256 _quoteReceiveUnits\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        require(_baseQuantityUnits != 0, "Amount is 0");\n        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");\n\n        uint256 totalSupply = _setToken.totalSupply();\n\n        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);\n        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());\n\n        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()\n            ? baseBalance.neg()         // To close position completely\n            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());\n\n        return _createActionInfoNotional(\n            _setToken,\n            _baseToken,\n            baseNotional,\n            _quoteReceiveUnits.preciseMul(totalSupply)\n        );\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates\n     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method\n     * is called during issue and redeem via _executePositionTrades and during trade via _createAndValidateActionInfo.\n     \n     * (See _executeTrade method comments for details about oppositeAmountBound configuration)\n     \n     * @param _setToken                 Instance of the SetToken\n     * @param _baseToken                Address of base token being traded into/out of\n     * @param _baseTokenQuantity        Notional quantity of baseToken to trade\n     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying\n     \n     * @return ActionInfo               Instance of constructed ActionInfo struct\n     /\n    function _createActionInfoNotional(\n        ISetToken _setToken,\n        address _baseToken,\n        int256 _baseTokenQuantity,\n        uint256 _quoteReceiveQuantity\n    )\n        internal\n        pure\n        returns(ActionInfo memory)\n    {\n        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called\n        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo\n        // that quantity is 0 for inputs to trade.\n        bool isBuy = _baseTokenQuantity &gt; 0;\n\n        return ActionInfo({\n            setToken: _setToken,\n            baseToken: _baseToken,\n            isBuy: isBuy,\n            baseTokenAmount: _baseTokenQuantity.abs(),\n            oppositeAmountBound: _quoteReceiveQuantity\n        });\n    }\n\n    /\n     * @dev Update position address array if a token has been newly added or completely sold off\n     * during lever/delever\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     /\n    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {\n        address[] memory positionList = positions[_setToken];\n        bool hasBaseToken = positionList.contains(_baseToken);\n\n        if (hasBaseToken) {\n            if(!_hasBaseBalance(_setToken, _baseToken)) {\n                positions[_setToken].removeStorage(_baseToken);\n            }\n        } else {\n            require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");\n            positions[_setToken].push(_baseToken);\n        }\n    }\n\n    /\n     * @dev Removes any zero balance positions from the positions array. This\n     * sync is done before issuance and redemption to account for positions that may have\n     * been liquidated.\n     \n     * @param _setToken         Instance of the SetToken\n     /\n    function _syncPositionList(ISetToken _setToken) internal {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            address currPosition = positionList[i];\n            if (!_hasBaseBalance(_setToken, currPosition)) {\n                positions[_setToken].removeStorage(currPosition);\n            }\n        }\n    }\n\n    /\n     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have\n     * no balance and return false\n     \n     * @param _setToken     Instance of SetToken\n     * @param _baseToken    Address of virtual base token\n     * @return bool         True if a non-dust base token balance exists, false otherwise\n     /\n    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {\n        int256 baseBalanceUnit = perpAccountBalance\n            .getBase(address(_setToken), _baseToken)\n            .preciseDiv(_setToken.totalSupply().toInt256());\n\n        return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1);\n    }\n\n    /\n     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol\n     \n     * @param  _baseToken           Address of virtual token to price\n     * @return price                Mid-point price of virtual token in UniswapV3 AMM market\n     /\n    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {\n        address pool = perpMarketRegistry.getPool(_baseToken);\n        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();\n        return priceX96.formatX96ToX10_18();\n    }\n\n    /\n     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per\n     * SetToken\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       External position unit\n     /\n    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {\n        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);\n        uint256 positionLength = positionInfo.length;\n        int256 totalPositionValue = 0;\n\n        for (uint i = 0; i &lt; positionLength; i++ ) {\n            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();\n            totalPositionValue = totalPositionValue.add(\n                positionInfo[i].baseBalance.preciseMul(spotPrice)\n            );\n        }\n\n        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)\n            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));\n\n        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);\n    }\n\n    /\n     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value\n     \n     * @param _setToken     Instance of SetToken\n     * @return int256       Collateral balance as an 18 decimal vUSDC quote value\n     /\n    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {\n        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);\n    }\n\n    /\n     * @dev Retrieves net quote balance of all open positions\n     \n     * @param _setToken             Instance of SetToken\n     * @return netQuoteBalance      Net quote balance of all open positions\n     /\n    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {\n        address[] memory positionList = positions[_setToken];\n        uint256 positionLength = positionList.length;\n\n        for (uint256 i = 0; i &lt; positionLength; i++) {\n            netQuoteBalance = netQuoteBalance.add(\n                perpAccountBalance.getQuote(address(_setToken), positionList[i])\n            );\n        }\n    }\n\n    /\n     * @dev Returns issuance or redemption adjustments in the format expected by SlippageIssuanceModule.\n     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated\n     * externalPositionUnit (new) and set in an equityAdjustments array which is the same length as\n     * the SetToken\'s components array, at the same index the collateral token occupies in the components\n     * array. All other values are left unset (0). An empty-value components length debtAdjustments\n     * array is also returned.\n     \n     * @param _setToken                         Instance of the SetToken\n     * @param _components                       Array of components held by the SetToken\n     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit\n     * @return int256[]                         Components-length array with equity adjustment value at appropriate index\n     * @return int256[]                         Components-length array of zeroes (debt adjustments)\n     /\n    function _formatAdjustments(\n        ISetToken _setToken,\n        address[] memory _components,\n        int256 _newExternalPositionUnit\n    )\n        internal\n        view\n        returns (int256[] memory, int256[] memory)\n    {\n        int256[] memory equityAdjustments = new int256;\n        int256[] memory debtAdjustments = new int256;\n\n        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));\n\n        if (isIn) {\n            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(\n                address(collateralToken),\n                address(this)\n            );\n\n            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);\n        }\n\n        return (equityAdjustments, debtAdjustments);\n    }\n}', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 05:28:52 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /     Copyright 2021 Set Labs Inc.     Licensed under the Apache License, Version 2.0 (the "License");     you may not use this file except in compliance with the License.     You may obtain a copy of the License at     http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software     distributed under the License is distributed on an "AS IS" BASIS,     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     See the License for the specific language governing permissions and     limitations under the License.     SPDX-License-Identifier: Apache License, Version 2.0 / pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import "@openzeppelin/contracts/math/SignedSafeMath.sol"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"; import { PerpV2 } from "../integration/lib/PerpV2.sol"; import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol"; import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol"; import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol"; import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol"; import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol"; import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol"; import { IVault } from "../../interfaces/external/perp-v2/IVault.sol"; import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol"; import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol"; import { IController } from "../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol"; import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol"; import { ISetToken } from "../../interfaces/ISetToken.sol"; import { ModuleBase } from "../lib/ModuleBase.sol"; import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol"; import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol"; import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol"; import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol"; /*  * @title PerpV2LeverageModule  * @author Set Protocol  * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account  * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token  * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of  * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.  *  * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit  * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.  * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the  * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.  *  * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current  * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.  / contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {     using PerpV2 for ISetToken;     using PreciseUnitMath for int256;     using SignedSafeMath for int256;     using UnitConversionUtils for int256;     using UniswapV3Math for uint160;     using UniswapV3Math for uint256;     using UnitConversionUtils for uint256;     using AddressArrayUtils for address[]; /* ============ Structs ============ */  struct ActionInfo {     ISetToken setToken;     address baseToken;              // Virtual token minted by the Perp protocol     bool isBuy;                     // When true, `baseToken` is being bought, when false, sold     uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals     uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details) }  struct PositionNotionalInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short     int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short }  struct PositionUnitInfo {     address baseToken;              // Virtual token minted by the Perp protocol     int256 baseUnit;                // Base position unit. When negative, position is short     int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short }  // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement, // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value // with the opposite meaning, e.g positively signed payments are owed by account to system). struct AccountInfo {     int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals     int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault     int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals     int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account }  /* ============ Events ============ */  /**  * @dev Emitted on trade  * @param _setToken         Instance of SetToken  * @param _baseToken        Virtual token minted by the Perp protocol  * @param _deltaBase        Change in baseToken position size resulting from trade  * @param _deltaQuote       Change in vUSDC position size resulting from trade  * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade  * @param _isBuy            True when baseToken is being bought, false when being sold  */ event PerpTraded(     ISetToken indexed _setToken,     address indexed _baseToken,     uint256 indexed _deltaBase,     uint256 _deltaQuote,     uint256 _protocolFee,     bool _isBuy );  /**  * @dev Emitted on deposit (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being deposited as collateral (USDC)  * @param _amountDeposited      Amount of collateral being deposited into Perp  */ event CollateralDeposited(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountDeposited );  /**  * @dev Emitted on withdraw (not issue or redeem)  * @param _setToken             Instance of SetToken  * @param _collateralToken      Token being withdrawn as collateral (USDC)  * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp  */ event CollateralWithdrawn(     ISetToken indexed _setToken,     IERC20 indexed _collateralToken,     uint256 indexed _amountWithdrawn );  /* ============ Constants ============ */  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token IERC20 public immutable collateralToken;  // Decimals of collateral token. We set this in the constructor for later reading uint8 internal immutable collateralDecimals;  // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances IAccountBalance public immutable perpAccountBalance;  // PerpV2 contract which provides a trading API IClearingHouse public immutable perpClearingHouse;  // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances IExchange public immutable perpExchange;  // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances IVault public immutable perpVault;  // PerpV2 contract which makes it possible to simulate a trade before it occurs IQuoter public immutable perpQuoter;  // PerpV2 contract which provides a getter for baseToken UniswapV3 pools IMarketRegistry public immutable perpMarketRegistry;  // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account. uint256 public maxPerpPositionsPerSet;  // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for. // Array is updated when new positions are opened or old positions are zeroed out. mapping(ISetToken =&gt; address[]) internal positions;  /* ============ Constructor ============ */  /**  * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`  * to the Perp vault's settlement token (USDC) and its decimals, respectively.  *  * @param _controller               Address of controller contract  * @param _perpVault                Address of Perp Vault contract  * @param _perpQuoter               Address of Perp Quoter contract  * @param _perpMarketRegistry       Address of Perp MarketRegistry contract  */ constructor(     IController _controller,     IVault _perpVault,     IQuoter _perpQuoter,     IMarketRegistry _perpMarketRegistry,     uint256 _maxPerpPositionsPerSet )     public     ModuleBase(_controller)     SetTokenAccessible(_controller) {     // Use temp variables to initialize immutables     address tempCollateralToken = _perpVault.getSettlementToken();     collateralToken = IERC20(tempCollateralToken);     collateralDecimals = ERC20(tempCollateralToken).decimals();      perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());     perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());     perpExchange = IExchange(_perpVault.getExchange());     perpVault = _perpVault;     perpQuoter = _perpQuoter;     perpMarketRegistry = _perpMarketRegistry;     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the  * allowed list or anySetAllowed needs to be true.  *  * @param _setToken             Instance of the SetToken to initialize  */ function initialize(     ISetToken _setToken )     public     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken)     onlyAllowedSet(_setToken) {     // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(         getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),         "Issuance not initialized"     );      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {             // This module registered itself on `modules[i]` issuance module.         } catch {             // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not             // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`             // function call reverted. Irrespective of the reason for failure, continue to the next module.         }     } }  /**  * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.  * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,  * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage  * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.  *  * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual  * token market prices and needs to be generated on the fly to be meaningful.  *  * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.  *  * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below  * | ----------------------------------------------------------------------------------------------- |  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |  * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |  * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |  * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |  * | ----------------------------------------------------------------------------------------------- |  *  * As a user when delevering by partially closing your position, you'd trade as below  * -----------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &lt; |basePositionUnit|  |  * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &lt; |basePositionUnit|  |  * -----------------------------------------------------------------------------------------------------------------------------------  *  * As a user when completely closing a position, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|  * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |  * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below  * -------------------------------------------------------------------------------------------------------------------------------------------  * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |  * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|  * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| &gt; |basePositionUnit|  |  * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| &gt; |basePositionUnit|  |  * -------------------------------------------------------------------------------------------------------------------------------------------  *  * @param _setToken                     Instance of the SetToken  * @param _baseToken                    Address virtual token being traded  * @param _baseQuantityUnits            Quantity of virtual token to trade in position units  * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling  */ function trade(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteBoundQuantityUnits )     public     nonReentrant     onlyManagerAndValidSet(_setToken) {     ActionInfo memory actionInfo = _createAndValidateActionInfo(         _setToken,         _baseToken,         _baseQuantityUnits,         _quoteBoundQuantityUnits     );      (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);      uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);      _updatePositionList(_setToken, _baseToken);      emit PerpTraded(         _setToken,         _baseToken,         deltaBase,         deltaQuote,         protocolFee,         actionInfo.isBuy     ); }  /**  * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing  * the size of the Perp account external position. This method is useful for establishing initial  * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit  * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference  * between these made up as automatically "issued" margin debt in the PerpV2 system.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units  */ function deposit(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Deposit amount is 0");      uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity); }  /**  * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on  * the SetToken. This method is useful when adjusting the overall composition of a Set which has  * a Perp account external position as one of several components.  *  * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments  * to the Perp vault prior to transfer.  *  * @param  _setToken                    Instance of the SetToken  * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units  */ function withdraw(   ISetToken _setToken,   uint256 _collateralQuantityUnits )   public   nonReentrant   onlyManagerAndValidSet(_setToken) {     require(_collateralQuantityUnits &gt; 0, "Withdraw amount is 0");      uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);      emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes  * position mappings associated with SetToken.  *  * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.  */ function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).     // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.     int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());     require(         accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) &lt;= 1,         "Account balance exists"     );      // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the     // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should     // already be empty, and the mapping can be deleted directly.     delete positions[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  *  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then  * this function needs to be called if the debt issuance module is later added and initialized to prevent state  * inconsistencies  *  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE  * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that  * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage  * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current  * Set holders.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  */ function moduleIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     public     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);      // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing  * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`  * equal to the realizable value of account in position units (as measured by the trade outcomes for  * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so  * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  */ function moduleRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     onlyModule(_setToken) {     if (_setToken.totalSupply() == 0) return;     if (!_setToken.hasExternalPosition(address(collateralToken))) return;      int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);      // Set USDC externalPositionUnit such that DIM can use it for transfer calculation     _setToken.editExternalPositionUnit(         address(collateralToken),         address(this),         newExternalPositionUnit     ); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits  * collateral into Perp protocol from SetToken default position.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to issue  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentIssueHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));          // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.         uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());          _deposit(_setToken, usdcTransferInNotionalQuantity);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws  * collateral from Perp protocol to SetToken default position *without* updating the default position unit.  * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral  * component from SetToken to redeemer after this hook executes.  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken to redeem  * @param _component            Address of deposit collateral component  * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise  */ function componentRedeemHook(     ISetToken _setToken,     uint256 _setTokenQuantity,     IERC20 _component,     bool _isEquity )     external     override     onlyModule(_setToken) {     if (_isEquity) {         int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));         uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());          _withdraw(_setToken, usdcTransferOutNotionalQuantity);     } }  /* ============ External Setter Functions ============ */  /**  * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.  *  * @param _maxPerpPositionsPerSet       New max perpetual positions per set  */ function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {     maxPerpPositionsPerSet = _maxPerpPositionsPerSet; }  /* ============ External Getter Functions ============ */  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * issuing a quantity of SetToken, representing the amount of collateral that would need to  * be transferred in per SetToken. Values in the returned arrays map to the same index in the  * SetToken's components array  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getIssuanceAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     override     returns (int256[] memory, int256[] memory) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for  * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.  * Values in the returned arrays map to the same index in the SetToken's components array.  *  * @param _setToken             Instance of SetToken  * @param _setTokenQuantity     Number of sets to issue  *  * @return equityAdjustments array containing a single element and an empty debtAdjustments array  */ function getRedemptionAdjustments(     ISetToken _setToken,     uint256 _setTokenQuantity )     external     virtual     override     returns (int256[] memory, int256[] memory _) {     address[] memory components = _setToken.getComponents();      if (positions[_setToken].length &gt; 0) {         int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);         return _formatAdjustments(_setToken, components, newExternalPositionUnit);     } else {         return _formatAdjustments(_setToken, components, 0);     } }  /**  * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseBalance:  baseToken balance as notional quantity (10**18)  *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)  */ function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;     PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         address baseToken = positionList[i];         positionInfo[i] = PositionNotionalInfo({             baseToken: baseToken,             baseBalance: perpAccountBalance.getBase(                 address(_setToken),                 baseToken             ),             quoteBalance: perpAccountBalance.getQuote(                 address(_setToken),                 baseToken             )         });     }      return positionInfo; }  /**  * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.  *  * @param _setToken         Instance of SetToken  *  * @return PositionUnitInfo array, in which each element has properties:  *  *         + baseToken: address,  *         + baseUnit:  baseToken balance as position unit (10**18)  *         + quoteUnit: USDC quote asset balance as position unit (10**18)  */ function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {     int256 totalSupply = _setToken.totalSupply().toInt256();     PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionNotionalInfo.length;     PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);      for(uint i = 0; i &lt; positionLength; i++){         PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];         positionUnitInfo[i] = PositionUnitInfo({             baseToken: currentPosition.baseToken,             baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),             quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)         });     }      return positionUnitInfo; }   /**  * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide  * (rather than position specific) balance info  *  * @param  _setToken            Instance of the SetToken  *  * @return accountInfo          struct with properties for:  *  *         + collateral balance (10**18, regardless of underlying collateral decimals)  *         + owed realized Pnl` (10**18)  *         + pending funding payments (10**18)  *         + net quote balance (10**18)  */ function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {     (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));      // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"     // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.     // We are flipping its sign here to reflect its settlement value.     accountInfo = AccountInfo({         collateralBalance: _getCollateralBalance(_setToken),         owedRealizedPnl: owedRealizedPnl,         pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),         netQuoteBalance: _getNetQuoteBalance(_setToken)     }); }  /* ============ Internal Functions ============ */  /**  * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.  * This method implements the core logic to replicate positions during issuance and redemption. Syncs  * the `positions` list before starting (because positions may have liquidated). Cycles through  * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of  * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any  * pending payments like funding or owedRealizedPnl are socialized among existing Set holders  * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using  * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module  * which reads this value.  *  * The general formula for determining `accountValue` per Set is:  *  * `accountValue = collateral                                &lt;---  *               + owedRealizedPnl                               }   totalCollateralValue  *               + pendingFundingPayment                     &lt;---  *               + netQuoteBalance                           neg. when long, pos. when short  *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short  *  * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the  * account value components).  *  * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp  * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's  * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to  * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).  *  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of Set to issue  * @param _isIssue              If true, invocation is for issuance, redemption otherwise  * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)  * @return int256               Amount of collateral to transfer in/out in position units  */ function _executePositionTrades(     ISetToken _setToken,     uint256 _setTokenQuantity,     bool _isIssue,     bool _isSimulation )     internal     returns (int256) {     _syncPositionList(_setToken);     int256 setTokenQuantityInt = _setTokenQuantity.toInt256();      // Note: `issued` naming convention used here for brevity. This logic is also run on redemption     // and variable may refer to the value which will be redeemed.     int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);      PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalSupply = _setToken.totalSupply().toInt256();      for(uint i = 0; i &lt; positionLength; i++) {         int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);          // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,         // e.g selling base when long, buying base when short         ActionInfo memory actionInfo = _createActionInfoNotional(             _setToken,             positionInfo[i].baseToken,             _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),             0         );          // Execute or simulate trade.         // `deltaQuote` is always a positive number         (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);          // slippage is borne by the issuer         accountValueIssued = baseTradeNotionalQuantity &gt;= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :             accountValueIssued.sub(deltaQuote.toInt256());     }      // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the     // account could be bankrupt and we represent that as zero.     if (accountValueIssued &lt;= 0) {         return 0;     }      // Return value in collateral decimals (e.g USDC = 6)     // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error     return (_isIssue)         ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)         : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals); }  /**  * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,  * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,  * as a position unit. It forms the base to which traded position values are added during issuance or redemption,  * and to which existing position values are added when calculating the externalPositionUnit.  *  * @param _setToken             Instance of the SetToken  * @return accountValue         Partial account value in position units  */ function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {     AccountInfo memory accountInfo = getAccountInfo(_setToken);      accountValue = accountInfo.collateralBalance         .add(accountInfo.owedRealizedPnl)         .add(accountInfo.pendingFundingPayments)         .add(accountInfo.netQuoteBalance)         .preciseDiv(_setToken.totalSupply().toInt256()); }  /**  * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault  * Updates the collateral token default position unit. This function is called directly by  * the componentIssue hook, skipping external position unit setting because that method is assumed  * to be the end of a call sequence (e.g manager will not need to read the updated value)  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to deposit  */ function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     _setToken.invokeApprove(         address(collateralToken),         address(perpVault),         _collateralNotionalQuantity     );      _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit  * so Manager contracts have a value they can base calculations for further trading on within the same transaction.  *  * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral  * quantity units into a notional quantity.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to deposit  * @return uint256                      Notional quantity deposited  */ function _depositAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _deposit(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault  * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,  * skipping position unit state updates because the funds withdrawn to SetToken are immediately  * forwarded to `feeRecipient` and SetToken owner respectively.  *  * @param _setToken                     Instance of SetToken  * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw  */ function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {     if (_collateralNotionalQuantity == 0) return;      _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity); }  /**  * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken  * externalPositionUnit (so Manager contracts have a value they can base calculations for further  * trading on within the same transaction), and the collateral token default position unit.  *  * NOTE: This flow is only used when invoking the external `withdraw` function - it converts  * a collateral units quantity into a notional quantity before invoking withdraw.  *  * @param _setToken                     Instance of SetToken  * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw  * @return uint256                      Notional quantity withdrawn  */ function _withdrawAndUpdatePositions(     ISetToken _setToken,     uint256 _collateralQuantityUnits )     internal     returns (uint256) {     uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));     uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());      _withdraw(_setToken, collateralNotionalQuantity);      _setToken.calculateAndEditDefaultPosition(         address(collateralToken),         _setToken.totalSupply(),         initialCollateralPositionBalance     );      _setToken.editExternalPosition(         address(collateralToken),         address(this),         _calculateExternalPositionUnit(_setToken),         ""     );      return collateralNotionalQuantity; }  /**  * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)  *  * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:  * | ---------------------------------------------------|---------------------------- |  * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |  * | ------- |-------- |--------|-----------------------|---------------------------- |  * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |  * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |  * |----------------------------------------------------|---------------------------- |  *  * @param _actionInfo  ActionInfo object  * @return uint256     The base position delta resulting from the trade  * @return uint256     The quote asset position delta resulting from the trade  */ function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {      // When isBaseToQuote is true, `baseToken` is being sold, when false, bought     // When isExactInput is true, `amount` is the swap input, when false, the swap output     IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         oppositeAmountBound: _actionInfo.oppositeAmountBound,         deadline: PreciseUnitMath.maxUint256(),         sqrtPriceLimitX96: 0,         referralCode: bytes32(0)     });      return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params); }   /**  * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)  *  * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.  *  * @param _actionInfo   ActionInfo object  * @return uint256      The base position delta resulting from the trade  * @return uint256      The quote asset position delta resulting from the trade  */ function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {     IQuoter.SwapParams memory params = IQuoter.SwapParams({         baseToken: _actionInfo.baseToken,         isBaseToQuote: !_actionInfo.isBuy,         isExactInput: !_actionInfo.isBuy,         amount: _actionInfo.baseTokenAmount,         sqrtPriceLimitX96: 0     });      IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);     return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote); }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  *  * @param  _setToken            Instance of SetToken  * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)  * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)  */ function _accrueProtocolFee(     ISetToken _setToken,     uint256 _exchangedQuantity )     internal     returns(uint256) {     uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);     uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);      _withdraw(_setToken, protocolFeeInPreciseUnits);      payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);      return protocolFeeInPreciseUnits; }  /**  * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to  *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If  * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is  * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.  *  * @param _setToken             Instance of the SetToken  * @param _baseToken            Address of base token being traded into/out of  * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits  * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits  *  * @return ActionInfo           Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     address _baseToken,     int256 _baseQuantityUnits,     uint256 _quoteReceiveUnits )     internal     view     returns(ActionInfo memory) {     require(_baseQuantityUnits != 0, "Amount is 0");     require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");      uint256 totalSupply = _setToken.totalSupply();      int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);     int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());      int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()         ? baseBalance.neg()         // To close position completely         : _baseQuantityUnits.preciseMul(totalSupply.toInt256());      return _createActionInfoNotional(         _setToken,         _baseToken,         baseNotional,         _quoteReceiveUnits.preciseMul(totalSupply)     ); }  /**  * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates  * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method  * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.  *  * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)  *  * @param _setToken                 Instance of the SetToken  * @param _baseToken                Address of base token being traded into/out of  * @param _baseTokenQuantity        Notional quantity of baseToken to trade  * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying  *  * @return ActionInfo               Instance of constructed ActionInfo struct  */ function _createActionInfoNotional(     ISetToken _setToken,     address _baseToken,     int256 _baseTokenQuantity,     uint256 _quoteReceiveQuantity )     internal     pure     returns(ActionInfo memory) {     // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called     // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo     // that quantity is 0 for inputs to trade.     bool isBuy = _baseTokenQuantity &gt; 0;      return ActionInfo({         setToken: _setToken,         baseToken: _baseToken,         isBuy: isBuy,         baseTokenAmount: _baseTokenQuantity.abs(),         oppositeAmountBound: _quoteReceiveQuantity     }); }  /**  * @dev Update position address array if a token has been newly added or completely sold off  * during lever/delever  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  */ function _updatePositionList(ISetToken _setToken, address _baseToken) internal {     address[] memory positionList = positions[_setToken];     bool hasBaseToken = positionList.contains(_baseToken);      if (hasBaseToken) {         if(!_hasBaseBalance(_setToken, _baseToken)) {             positions[_setToken].removeStorage(_baseToken);         }     } else {         require(positions[_setToken].length &lt; maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");         positions[_setToken].push(_baseToken);     } }  /**  * @dev Removes any zero balance positions from the positions array. This  * sync is done before issuance and redemption to account for positions that may have  * been liquidated.  *  * @param _setToken         Instance of the SetToken  */ function _syncPositionList(ISetToken _setToken) internal {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         address currPosition = positionList[i];         if (!_hasBaseBalance(_setToken, currPosition)) {             positions[_setToken].removeStorage(currPosition);         }     } }  /**  * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have  * no balance and return false  *  * @param _setToken     Instance of SetToken  * @param _baseToken    Address of virtual base token  * @return bool         True if a non-dust base token balance exists, false otherwise  */ function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {     int256 baseBalanceUnit = perpAccountBalance         .getBase(address(_setToken), _baseToken)         .preciseDiv(_setToken.totalSupply().toInt256());      return (baseBalanceUnit &gt; 1) || (baseBalanceUnit &lt; -1); }  /**  * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol  *  * @param  _baseToken           Address of virtual token to price  * @return price                Mid-point price of virtual token in UniswapV3 AMM market  */ function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {     address pool = perpMarketRegistry.getPool(_baseToken);     (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();     uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();     return priceX96.formatX96ToX10_18(); }  /**  * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per  * SetToken  *  * @param _setToken     Instance of SetToken  * @return int256       External position unit  */ function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {     PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);     uint256 positionLength = positionInfo.length;     int256 totalPositionValue = 0;      for (uint i = 0; i &lt; positionLength; i++ ) {         int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();         totalPositionValue = totalPositionValue.add(             positionInfo[i].baseBalance.preciseMul(spotPrice)         );     }      int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)         .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));      return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals); }  /**  * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value  *  * @param _setToken     Instance of SetToken  * @return int256       Collateral balance as an 18 decimal vUSDC quote value  */ function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {     return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals); }  /**  * @dev Retrieves net quote balance of all open positions  *  * @param _setToken             Instance of SetToken  * @return netQuoteBalance      Net quote balance of all open positions  */ function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {     address[] memory positionList = positions[_setToken];     uint256 positionLength = positionList.length;      for (uint256 i = 0; i &lt; positionLength; i++) {         netQuoteBalance = netQuoteBalance.add(             perpAccountBalance.getQuote(address(_setToken), positionList[i])         );     } }  /**  * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.  * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated  * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as  * the SetToken's components array, at the same index the collateral token occupies in the components  * array. All other values are left unset (0). An empty-value components length debtAdjustments  * array is also returned.  *  * @param _setToken                         Instance of the SetToken  * @param _components                       Array of components held by the SetToken  * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit  * @return int256[]                         Components-length array with equity adjustment value at appropriate index  * @return int256[]                         Components-length array of zeroes (debt adjustments)  */ function _formatAdjustments(     ISetToken _setToken,     address[] memory _components,     int256 _newExternalPositionUnit )     internal     view     returns (int256[] memory, int256[] memory) {     int256[] memory equityAdjustments = new int256[](_components.length);     int256[] memory debtAdjustments = new int256[](_components.length);      (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));      if (isIn) {         int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(             address(collateralToken),             address(this)         );          equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);     }      return (equityAdjustments, debtAdjustments); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 05:28:52 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "/*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import "@openzeppelin/contracts/math/SignedSafeMath.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";

import { PerpV2 } from "../integration/lib/PerpV2.sol";
import { UniswapV3Math } from "../integration/lib/UniswapV3Math.sol";
import { IAccountBalance } from "../../interfaces/external/perp-v2/IAccountBalance.sol";
import { IClearingHouse } from "../../interfaces/external/perp-v2/IClearingHouse.sol";
import { IClearingHouseConfig } from "../../interfaces/external/perp-v2/IClearingHouseConfig.sol";
import { IExchange } from "../../interfaces/external/perp-v2/IExchange.sol";
import { IIndexPrice } from "../../interfaces/external/perp-v2/IIndexPrice.sol";
import { IVault } from "../../interfaces/external/perp-v2/IVault.sol";
import { IQuoter } from "../../interfaces/external/perp-v2/IQuoter.sol";
import { IMarketRegistry } from "../../interfaces/external/perp-v2/IMarketRegistry.sol";
import { IController } from "../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../interfaces/IDebtIssuanceModule.sol";
import { IModuleIssuanceHookV2 } from "../../interfaces/IModuleIssuanceHookV2.sol";
import { ISetToken } from "../../interfaces/ISetToken.sol";
import { ModuleBase } from "../lib/ModuleBase.sol";
import { SetTokenAccessible } from "../lib/SetTokenAccessible.sol";
import { PreciseUnitMath } from "../../lib/PreciseUnitMath.sol";
import { AddressArrayUtils } from "../../lib/AddressArrayUtils.sol";
import { UnitConversionUtils } from "../../lib/UnitConversionUtils.sol";

/**
 * @title PerpV2LeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leveraged trading using the PerpV2 protocol. Each SetToken can only manage a single Perp account
 * represented as a positive equity external position whose value is the net Perp account value denominated in the collateral token
 * deposited into the Perp Protocol. This module only allows Perp positions to be collateralized by one asset, USDC, set on deployment of
 * this contract (see collateralToken) however it can take positions simultaneously in multiple base assets.
 *
 * Upon issuance and redemption positions are not EXACTLY replicated like for other position types since a trade is necessary to enter/exit
 * the position on behalf of the issuer/redeemer. Any cost of entering/exiting the position (slippage) is carried by the issuer/redeemer.
 * Any pending funding costs or PnL is carried by the current token holders. To be used safely this module MUST issue using the
 * SlippageIssuanceModule or else issue and redeem transaction could be sandwich attacked.
 *
 * NOTE: The external position unit is only updated on an as-needed basis during issuance/redemption. It does not reflect the current
 * value of the Set's perpetual position. The current value can be calculated from getPositionNotionalInfo.
 */
contract PerpV2LeverageModule is ModuleBase, ReentrancyGuard, Ownable, SetTokenAccessible, IModuleIssuanceHookV2 {
    using PerpV2 for ISetToken;
    using PreciseUnitMath for int256;
    using SignedSafeMath for int256;
    using UnitConversionUtils for int256;
    using UniswapV3Math for uint160;
    using UniswapV3Math for uint256;
    using UnitConversionUtils for uint256;
    using AddressArrayUtils for address[];

    /* ============ Structs ============ */

    struct ActionInfo {
        ISetToken setToken;
        address baseToken;              // Virtual token minted by the Perp protocol
        bool isBuy;                     // When true, `baseToken` is being bought, when false, sold
        uint256 baseTokenAmount;        // Base token quantity in 10**18 decimals
        uint256 oppositeAmountBound;    // vUSDC pay or receive quantity bound (see `_createActionInfoNotional` for details)
    }

    struct PositionNotionalInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseBalance;             // Base position notional quantity in 10**18 decimals. When negative, position is short
        int256 quoteBalance;            // vUSDC "debt" notional quantity minted to open position. When positive, position is short
    }

    struct PositionUnitInfo {
        address baseToken;              // Virtual token minted by the Perp protocol
        int256 baseUnit;                // Base position unit. When negative, position is short
        int256 quoteUnit;               // vUSDC "debt" position unit. When positive, position is short
    }

    // Note: when `pendingFundingPayments` is positive it will be credited to account on settlement,
    // when negative it's a debt owed that will be repaid on settlement. (PerpProtocol.Exchange returns the value
    // with the opposite meaning, e.g positively signed payments are owed by account to system).
    struct AccountInfo {
        int256 collateralBalance;       // Quantity of collateral deposited in Perp vault in 10**18 decimals
        int256 owedRealizedPnl;         // USDC quantity of profit and loss in 10**18 decimals not yet settled to vault
        int256 pendingFundingPayments;  // USDC quantity of pending funding payments in 10**18 decimals
        int256 netQuoteBalance;         // USDC quantity of net quote balance for all open positions in Perp account
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on trade
     * @param _setToken         Instance of SetToken
     * @param _baseToken        Virtual token minted by the Perp protocol
     * @param _deltaBase        Change in baseToken position size resulting from trade
     * @param _deltaQuote       Change in vUSDC position size resulting from trade
     * @param _protocolFee      Quantity in collateral decimals sent to fee recipient during lever trade
     * @param _isBuy            True when baseToken is being bought, false when being sold
     */
    event PerpTraded(
        ISetToken indexed _setToken,
        address indexed _baseToken,
        uint256 indexed _deltaBase,
        uint256 _deltaQuote,
        uint256 _protocolFee,
        bool _isBuy
    );

    /**
     * @dev Emitted on deposit (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being deposited as collateral (USDC)
     * @param _amountDeposited      Amount of collateral being deposited into Perp
     */
    event CollateralDeposited(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountDeposited
    );

    /**
     * @dev Emitted on withdraw (not issue or redeem)
     * @param _setToken             Instance of SetToken
     * @param _collateralToken      Token being withdrawn as collateral (USDC)
     * @param _amountWithdrawn      Amount of collateral being withdrawn from Perp
     */
    event CollateralWithdrawn(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralToken,
        uint256 indexed _amountWithdrawn
    );

    /* ============ Constants ============ */

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Token (USDC) used as a vault deposit, Perp currently only supports USDC as it's settlement and collateral token
    IERC20 public immutable collateralToken;

    // Decimals of collateral token. We set this in the constructor for later reading
    uint8 internal immutable collateralDecimals;

    // PerpV2 contract which provides getters for base, quote, and owedRealizedPnl balances
    IAccountBalance public immutable perpAccountBalance;

    // PerpV2 contract which provides a trading API
    IClearingHouse public immutable perpClearingHouse;

    // PerpV2 contract which manages trading logic. Provides getters for UniswapV3 pools and pending funding balances
    IExchange public immutable perpExchange;

    // PerpV2 contract which handles deposits and withdrawals. Provides getter for collateral balances
    IVault public immutable perpVault;

    // PerpV2 contract which makes it possible to simulate a trade before it occurs
    IQuoter public immutable perpQuoter;

    // PerpV2 contract which provides a getter for baseToken UniswapV3 pools
    IMarketRegistry public immutable perpMarketRegistry;

    // PerpV2 operations are very gas intensive and there is a limit on the number of positions that can be opened in a single transaction
    // during issuance/redemption. `maxPerpPositionsPerSet` is a safe limit set by governance taking Optimism's block gas limit into account.
    uint256 public maxPerpPositionsPerSet;

    // Mapping of SetTokens to an array of virtual token addresses the Set has open positions for.
    // Array is updated when new positions are opened or old positions are zeroed out.
    mapping(ISetToken => address[]) internal positions;

    /* ============ Constructor ============ */

    /**
     * @dev Sets external PerpV2 Protocol contract addresses. Sets `collateralToken` and `collateralDecimals`
     * to the Perp vault's settlement token (USDC) and its decimals, respectively.
     *
     * @param _controller               Address of controller contract
     * @param _perpVault                Address of Perp Vault contract
     * @param _perpQuoter               Address of Perp Quoter contract
     * @param _perpMarketRegistry       Address of Perp MarketRegistry contract
     */
    constructor(
        IController _controller,
        IVault _perpVault,
        IQuoter _perpQuoter,
        IMarketRegistry _perpMarketRegistry,
        uint256 _maxPerpPositionsPerSet
    )
        public
        ModuleBase(_controller)
        SetTokenAccessible(_controller)
    {
        // Use temp variables to initialize immutables
        address tempCollateralToken = _perpVault.getSettlementToken();
        collateralToken = IERC20(tempCollateralToken);
        collateralDecimals = ERC20(tempCollateralToken).decimals();

        perpAccountBalance = IAccountBalance(_perpVault.getAccountBalance());
        perpClearingHouse = IClearingHouse(_perpVault.getClearingHouse());
        perpExchange = IExchange(_perpVault.getExchange());
        perpVault = _perpVault;
        perpQuoter = _perpQuoter;
        perpMarketRegistry = _perpMarketRegistry;
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the
     * allowed list or anySetAllowed needs to be true.
     *
     * @param _setToken             Instance of the SetToken to initialize
     */
    function initialize(
        ISetToken _setToken
    )
        public
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
        onlyAllowedSet(_setToken)
    {
        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(
            getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)),
            "Issuance not initialized"
        );

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {
                // This module registered itself on `modules[i]` issuance module.
            } catch {
                // Try will fail if `modules[i]` is not an instance of IDebtIssuanceModule and does not
                // implement the `registerToIssuanceModule` function, or if the `registerToIssuanceModule`
                // function call reverted. Irrespective of the reason for failure, continue to the next module.
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Allows manager to buy or sell perps to change exposure to the underlying baseToken.
     * Providing a positive value for `_baseQuantityUnits` buys vToken on UniswapV3 via Perp's ClearingHouse,
     * Providing a negative value sells the token. `_quoteBoundQuantityUnits` defines a min-receive-like slippage
     * bound for the amount of vUSDC quote asset the trade will either pay or receive as a result of the action.
     *
     * NOTE: This method doesn't update the externalPositionUnit because it is a function of UniswapV3 virtual
     * token market prices and needs to be generated on the fly to be meaningful.
     *
     * In the tables below, basePositionUnit = baseTokenBalance / setTotalSupply.
     *
     * As a user when levering, e.g increasing the magnitude of your position, you'd trade as below
     * | ----------------------------------------------------------------------------------------------- |
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits` |
     * | ----- |-------- | ------------------------- | --------------------------- | ------------------- |
     * | Long  | Buy     | pay least amt. of vQuote  | upper bound of input quote  | positive            |
     * | Short | Sell    | get most amt. of vQuote   | lower bound of output quote | negative            |
     * | ----------------------------------------------------------------------------------------------- |
     *
     * As a user when delevering by partially closing your position, you'd trade as below
     * -----------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-------- | ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell    | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| < |basePositionUnit|  |
     * | Short | Buy     | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| < |basePositionUnit|  |
     * -----------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when completely closing a position, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------| ------------------------- | --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to close   | get most amt. of vQuote   | upper bound of input quote  | negative, baseQuantityUnits = -1 * basePositionUnit |
     * | Short | Buy to close    | pay least amt. of vQuote  | lower bound of output quote | positive, baseQuantityUnits = -1 * basePositionUnit |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * As a user when reversing a position, e.g going from a long position to a short position in a single trade, you'd trade as below
     * -------------------------------------------------------------------------------------------------------------------------------------------
     * | Type  |  Action         | Goal                      | `quoteBoundQuantity`        | `baseQuantityUnits`                                 |
     * | ----- |-----------------|---------------------------| --------------------------- | ----------------------------------------------------|
     * | Long  | Sell to reverse | get most amt. of vQuote   | upper bound of input quote  | negative, |baseQuantityUnits| > |basePositionUnit|  |
     * | Short | Buy to reverse  | pay least amt. of vQuote  | lower bound of output quote | positive, |baseQuantityUnits| > |basePositionUnit|  |
     * -------------------------------------------------------------------------------------------------------------------------------------------
     *
     * @param _setToken                     Instance of the SetToken
     * @param _baseToken                    Address virtual token being traded
     * @param _baseQuantityUnits            Quantity of virtual token to trade in position units
     * @param _quoteBoundQuantityUnits      Max/min of vQuote asset to pay/receive when buying or selling
     */
    function trade(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteBoundQuantityUnits
    )
        public
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        ActionInfo memory actionInfo = _createAndValidateActionInfo(
            _setToken,
            _baseToken,
            _baseQuantityUnits,
            _quoteBoundQuantityUnits
        );

        (uint256 deltaBase, uint256 deltaQuote) = _executeTrade(actionInfo);

        uint256 protocolFee = _accrueProtocolFee(_setToken, deltaQuote);

        _updatePositionList(_setToken, _baseToken);

        emit PerpTraded(
            _setToken,
            _baseToken,
            deltaBase,
            deltaQuote,
            protocolFee,
            actionInfo.isBuy
        );
    }

    /**
     * @dev MANAGER ONLY: Deposits default position collateral token into the PerpV2 Vault, increasing
     * the size of the Perp account external position. This method is useful for establishing initial
     * collateralization ratios, e.g the flow when setting up a 2X external position would be to deposit
     * 100 units of USDC and execute a lever trade for ~200 vUSDC worth of vToken with the difference
     * between these made up as automatically "issued" margin debt in the PerpV2 system.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to deposit in position units
     */
    function deposit(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Deposit amount is 0");

        uint256 notionalDepositedQuantity = _depositAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralDeposited(_setToken, collateralToken, notionalDepositedQuantity);
    }

    /**
     * @dev MANAGER ONLY: Withdraws collateral token from the PerpV2 Vault to a default position on
     * the SetToken. This method is useful when adjusting the overall composition of a Set which has
     * a Perp account external position as one of several components.
     *
     * NOTE: Within PerpV2, `withdraw` settles `owedRealizedPnl` and any pending funding payments
     * to the Perp vault prior to transfer.
     *
     * @param  _setToken                    Instance of the SetToken
     * @param  _collateralQuantityUnits     Quantity of collateral to withdraw in position units
     */
    function withdraw(
      ISetToken _setToken,
      uint256 _collateralQuantityUnits
    )
      public
      nonReentrant
      onlyManagerAndValidSet(_setToken)
    {
        require(_collateralQuantityUnits > 0, "Withdraw amount is 0");

        uint256 notionalWithdrawnQuantity = _withdrawAndUpdatePositions(_setToken, _collateralQuantityUnits);

        emit CollateralWithdrawn(_setToken, collateralToken, notionalWithdrawnQuantity);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Deletes
     * position mappings associated with SetToken.
     *
     * NOTE: Function will revert if there is greater than a position unit amount of USDC of account value.
     */
    function removeModule() public virtual override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Check that there is less than 1 position unit of USDC of account value (to tolerate PRECISE_UNIT math rounding errors).
        // Account value is checked here because liquidation may result in a positive vault balance while net value is below zero.
        int256 accountValueUnit = perpClearingHouse.getAccountValue(address(setToken)).preciseDiv(setToken.totalSupply().toInt256());
        require(
            accountValueUnit.fromPreciseUnitToDecimals(collateralDecimals) <= 1,
            "Account balance exists"
        );

        // `positions[setToken]` mapping stores an array of addresses. The base token addresses are removed from the array when the
        // corresponding base token positions are zeroed out. Since no positions exist when removing the module, the stored array should
        // already be empty, and the mapping can be deleted directly.
        delete positions[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     *
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then
     * this function needs to be called if the debt issuance module is later added and initialized to prevent state
     * inconsistencies
     *
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance. Only callable by valid module. Should only be called ONCE
     * during issue. Trades into current positions and sets the collateralToken's externalPositionUnit so that
     * issuance module can transfer in the right amount of collateral accounting for accrued fees/pnl and slippage
     * incurred during issuance. Any pending funding payments and accrued owedRealizedPnl are attributed to current
     * Set holders.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     */
    function moduleIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        public
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, false);

        // Set collateralToken externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption in the issuance module. Trades out of existing
     * positions to make redemption capital withdrawable from PerpV2 vault. Sets the `externalPositionUnit`
     * equal to the realizable value of account in position units (as measured by the trade outcomes for
     * this redemption). Any `owedRealizedPnl` and pending funding payments are socialized in this step so
     * that redeemer pays/receives their share of them. Should only be called ONCE during redeem.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     */
    function moduleRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        onlyModule(_setToken)
    {
        if (_setToken.totalSupply() == 0) return;
        if (!_setToken.hasExternalPosition(address(collateralToken))) return;

        int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, false);

        // Set USDC externalPositionUnit such that DIM can use it for transfer calculation
        _setToken.editExternalPositionUnit(
            address(collateralToken),
            address(this),
            newExternalPositionUnit
        );
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Deposits
     * collateral into Perp protocol from SetToken default position.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to issue
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentIssueHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            // Use preciseMulCeil here to ensure correct collateralization if there are rounding errors.
            uint256 usdcTransferInNotionalQuantity = _setTokenQuantity.preciseMulCeil(externalPositionUnit.toUint256());

            _deposit(_setToken, usdcTransferInNotionalQuantity);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Withdraws
     * collateral from Perp protocol to SetToken default position *without* updating the default position unit.
     * Called by issuance module's `resolveEquityPositions` method which immediately transfers the collateral
     * component from SetToken to redeemer after this hook executes.
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken to redeem
     * @param _component            Address of deposit collateral component
     * @param _isEquity             True if componentHook called from issuance module for equity flow, false otherwise
     */
    function componentRedeemHook(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        IERC20 _component,
        bool _isEquity
    )
        external
        override
        onlyModule(_setToken)
    {
        if (_isEquity) {
            int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            uint256 usdcTransferOutNotionalQuantity = _setTokenQuantity.preciseMul(externalPositionUnit.toUint256());

            _withdraw(_setToken, usdcTransferOutNotionalQuantity);
        }
    }

    /* ============ External Setter Functions ============ */

    /**
     * @dev GOVERNANCE ONLY: Update max perpetual positions per SetToken. Only callable by governance.
     *
     * @param _maxPerpPositionsPerSet       New max perpetual positions per set
     */
    function updateMaxPerpPositionsPerSet(uint256 _maxPerpPositionsPerSet) external onlyOwner {
        maxPerpPositionsPerSet = _maxPerpPositionsPerSet;
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * issuing a quantity of SetToken, representing the amount of collateral that would need to
     * be transferred in per SetToken. Values in the returned arrays map to the same index in the
     * SetToken's components array
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getIssuanceAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        override
        returns (int256[] memory, int256[] memory)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, true, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Gets the positive equity collateral externalPositionUnit that would be calculated for
     * redeeming a quantity of SetToken representing the amount of collateral returned per SetToken.
     * Values in the returned arrays map to the same index in the SetToken's components array.
     *
     * @param _setToken             Instance of SetToken
     * @param _setTokenQuantity     Number of sets to issue
     *
     * @return equityAdjustments array containing a single element and an empty debtAdjustments array
     */
    function getRedemptionAdjustments(
        ISetToken _setToken,
        uint256 _setTokenQuantity
    )
        external
        virtual
        override
        returns (int256[] memory, int256[] memory _)
    {
        address[] memory components = _setToken.getComponents();

        if (positions[_setToken].length > 0) {
            int256 newExternalPositionUnit = _executePositionTrades(_setToken, _setTokenQuantity, false, true);
            return _formatAdjustments(_setToken, components, newExternalPositionUnit);
        } else {
            return _formatAdjustments(_setToken, components, 0);
        }
    }

    /**
     * @dev Returns a PositionUnitNotionalInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseBalance:  baseToken balance as notional quantity (10**18)
     *         + quoteBalance: USDC quote asset balance as notional quantity (10**18)
     */
    function getPositionNotionalInfo(ISetToken _setToken) public view returns (PositionNotionalInfo[] memory) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;
        PositionNotionalInfo[] memory positionInfo = new PositionNotionalInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            address baseToken = positionList[i];
            positionInfo[i] = PositionNotionalInfo({
                baseToken: baseToken,
                baseBalance: perpAccountBalance.getBase(
                    address(_setToken),
                    baseToken
                ),
                quoteBalance: perpAccountBalance.getQuote(
                    address(_setToken),
                    baseToken
                )
            });
        }

        return positionInfo;
    }

    /**
     * @dev Returns a PositionUnitInfo array representing all positions open for the SetToken.
     *
     * @param _setToken         Instance of SetToken
     *
     * @return PositionUnitInfo array, in which each element has properties:
     *
     *         + baseToken: address,
     *         + baseUnit:  baseToken balance as position unit (10**18)
     *         + quoteUnit: USDC quote asset balance as position unit (10**18)
     */
    function getPositionUnitInfo(ISetToken _setToken) external view returns (PositionUnitInfo[] memory) {
        int256 totalSupply = _setToken.totalSupply().toInt256();
        PositionNotionalInfo[] memory positionNotionalInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionNotionalInfo.length;
        PositionUnitInfo[] memory positionUnitInfo = new PositionUnitInfo[](positionLength);

        for(uint i = 0; i < positionLength; i++){
            PositionNotionalInfo memory currentPosition = positionNotionalInfo[i];
            positionUnitInfo[i] = PositionUnitInfo({
                baseToken: currentPosition.baseToken,
                baseUnit: currentPosition.baseBalance.preciseDiv(totalSupply),
                quoteUnit: currentPosition.quoteBalance.preciseDiv(totalSupply)
            });
        }

        return positionUnitInfo;
    }


    /**
     * @dev Gets Perp account info for SetToken. Returns an AccountInfo struct containing account wide
     * (rather than position specific) balance info
     *
     * @param  _setToken            Instance of the SetToken
     *
     * @return accountInfo          struct with properties for:
     *
     *         + collateral balance (10**18, regardless of underlying collateral decimals)
     *         + owed realized Pnl` (10**18)
     *         + pending funding payments (10**18)
     *         + net quote balance (10**18)
     */
    function getAccountInfo(ISetToken _setToken) public view returns (AccountInfo memory accountInfo) {
        (int256 owedRealizedPnl,, ) =  perpAccountBalance.getPnlAndPendingFee(address(_setToken));

        // NOTE: pendingFundingPayments are represented as in the Perp system as "funding owed"
        // e.g a positive number is a debt which gets subtracted from owedRealizedPnl on settlement.
        // We are flipping its sign here to reflect its settlement value.
        accountInfo = AccountInfo({
            collateralBalance: _getCollateralBalance(_setToken),
            owedRealizedPnl: owedRealizedPnl,
            pendingFundingPayments: perpExchange.getAllPendingFundingPayment(address(_setToken)).neg(),
            netQuoteBalance: _getNetQuoteBalance(_setToken)
        });
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev MODULE ONLY: Hook called prior to issuance or redemption. Only callable by valid module.
     * This method implements the core logic to replicate positions during issuance and redemption. Syncs
     * the `positions` list before starting (because positions may have liquidated). Cycles through
     * each position, trading `basePositionUnit * issueOrRedeemQuantity` and calculates the amount of
     * USDC to transfer in/out for exchange, ensuring that issuer/redeemer pays slippage and that any
     * pending payments like funding or owedRealizedPnl are socialized among existing Set holders
     * appropriately. The hook which invokes this method sets the SetToken's externalPositionUnit using
     * the positionUnit value returned here. Subsequent transfers in/out are managed by the issuance module
     * which reads this value.
     *
     * The general formula for determining `accountValue` per Set is:
     *
     * `accountValue = collateral                                <---
     *               + owedRealizedPnl                               }   totalCollateralValue
     *               + pendingFundingPayment                     <---
     *               + netQuoteBalance                           neg. when long, pos. when short
     *               +/- sum( |deltaQuoteResultingFromTrade| )   add when long, subtract when short
     *
     * (See docs for `_calculatePartialAccountValuePositionUnit` below for more detail about the
     * account value components).
     *
     * NOTE: On issuance, this hook is run *BEFORE* USDC is transferred in and deposited to the Perp
     * vault to pay for the issuer's Sets. This trading temporarily spikes the Perp account's
     * margin ratio (capped at ~9X) and limits the amount of Set that can issued at once to
     * a multiple of the current Perp account value (will vary depending on Set's leverage ratio).
     *
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of Set to issue
     * @param _isIssue              If true, invocation is for issuance, redemption otherwise
     * @param _isSimulation         If true, trading is only simulated (to return issuance adjustments)
     * @return int256               Amount of collateral to transfer in/out in position units
     */
    function _executePositionTrades(
        ISetToken _setToken,
        uint256 _setTokenQuantity,
        bool _isIssue,
        bool _isSimulation
    )
        internal
        returns (int256)
    {
        _syncPositionList(_setToken);
        int256 setTokenQuantityInt = _setTokenQuantity.toInt256();

        // Note: `issued` naming convention used here for brevity. This logic is also run on redemption
        // and variable may refer to the value which will be redeemed.
        int256 accountValueIssued = _calculatePartialAccountValuePositionUnit(_setToken).preciseMul(setTokenQuantityInt);

        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalSupply = _setToken.totalSupply().toInt256();

        for(uint i = 0; i < positionLength; i++) {
            int256 baseTradeNotionalQuantity = positionInfo[i].baseBalance.preciseDiv(totalSupply).preciseMul(setTokenQuantityInt);

            // When redeeming, we flip the sign of baseTradeNotionalQuantity because we are reducing the size of the position,
            // e.g selling base when long, buying base when short
            ActionInfo memory actionInfo = _createActionInfoNotional(
                _setToken,
                positionInfo[i].baseToken,
                _isIssue ? baseTradeNotionalQuantity : baseTradeNotionalQuantity.neg(),
                0
            );

            // Execute or simulate trade.
            // `deltaQuote` is always a positive number
            (, uint256 deltaQuote) = _isSimulation ? _simulateTrade(actionInfo) : _executeTrade(actionInfo);

            // slippage is borne by the issuer
            accountValueIssued = baseTradeNotionalQuantity >= 0 ? accountValueIssued.add(deltaQuote.toInt256()) :
                accountValueIssued.sub(deltaQuote.toInt256());
        }

        // After trading, verify that accountValueIssued is not negative. In some post-liquidation states the
        // account could be bankrupt and we represent that as zero.
        if (accountValueIssued <= 0) {
            return 0;
        }

        // Return value in collateral decimals (e.g USDC = 6)
        // Use preciseDivCeil when issuing to ensure we don't under-collateralize due to rounding error
        return (_isIssue)
            ? accountValueIssued.preciseDivCeil(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals)
            : accountValueIssued.preciseDiv(setTokenQuantityInt).fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * Calculates the "partial account value" position unit. This is the sum of the vault collateral balance,
     * the net quote balance for all positions, and any pending funding or owed realized Pnl balances,
     * as a position unit. It forms the base to which traded position values are added during issuance or redemption,
     * and to which existing position values are added when calculating the externalPositionUnit.
     *
     * @param _setToken             Instance of the SetToken
     * @return accountValue         Partial account value in position units
     */
    function _calculatePartialAccountValuePositionUnit(ISetToken _setToken) internal view returns (int256 accountValue) {
        AccountInfo memory accountInfo = getAccountInfo(_setToken);

        accountValue = accountInfo.collateralBalance
            .add(accountInfo.owedRealizedPnl)
            .add(accountInfo.pendingFundingPayments)
            .add(accountInfo.netQuoteBalance)
            .preciseDiv(_setToken.totalSupply().toInt256());
    }

    /**
     * @dev Invoke deposit from SetToken using PerpV2 library. Creates a collateral deposit in Perp vault
     * Updates the collateral token default position unit. This function is called directly by
     * the componentIssue hook, skipping external position unit setting because that method is assumed
     * to be the end of a call sequence (e.g manager will not need to read the updated value)
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to deposit
     */
    function _deposit(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        _setToken.invokeApprove(
            address(collateralToken),
            address(perpVault),
            _collateralNotionalQuantity
        );

        _setToken.invokeDeposit(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Approves and deposits collateral units into Perp vault and additionally sets collateral token externalPositionUnit
     * so Manager contracts have a value they can base calculations for further trading on within the same transaction.
     *
     * NOTE: This flow is only used when invoking the external `deposit` function - it converts collateral
     * quantity units into a notional quantity.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to deposit
     * @return uint256                      Notional quantity deposited
     */
    function _depositAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _deposit(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Invoke withdraw from SetToken using PerpV2 library. Withdraws collateral token from Perp vault
     * into a default position. This function is called directly by _accrueFee and _moduleRedeemHook,
     * skipping position unit state updates because the funds withdrawn to SetToken are immediately
     * forwarded to `feeRecipient` and SetToken owner respectively.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralNotionalQuantity   Notional collateral quantity to withdraw
     */
    function _withdraw(ISetToken _setToken, uint256 _collateralNotionalQuantity) internal {
        if (_collateralNotionalQuantity == 0) return;

        _setToken.invokeWithdraw(perpVault, collateralToken, _collateralNotionalQuantity);
    }

    /**
     * Withdraws collateral units from Perp vault to SetToken and additionally sets both the collateralToken
     * externalPositionUnit (so Manager contracts have a value they can base calculations for further
     * trading on within the same transaction), and the collateral token default position unit.
     *
     * NOTE: This flow is only used when invoking the external `withdraw` function - it converts
     * a collateral units quantity into a notional quantity before invoking withdraw.
     *
     * @param _setToken                     Instance of SetToken
     * @param _collateralQuantityUnits      Collateral quantity in position units to withdraw
     * @return uint256                      Notional quantity withdrawn
     */
    function _withdrawAndUpdatePositions(
        ISetToken _setToken,
        uint256 _collateralQuantityUnits
    )
        internal
        returns (uint256)
    {
        uint256 initialCollateralPositionBalance = collateralToken.balanceOf(address(_setToken));
        uint256 collateralNotionalQuantity = _collateralQuantityUnits.preciseMul(_setToken.totalSupply());

        _withdraw(_setToken, collateralNotionalQuantity);

        _setToken.calculateAndEditDefaultPosition(
            address(collateralToken),
            _setToken.totalSupply(),
            initialCollateralPositionBalance
        );

        _setToken.editExternalPosition(
            address(collateralToken),
            address(this),
            _calculateExternalPositionUnit(_setToken),
            ""
        );

        return collateralNotionalQuantity;
    }

    /**
     * @dev Formats Perp Protocol openPosition call and executes via SetToken (and PerpV2 lib)
     *
     * `isBaseToQuote`, `isExactInput` and `oppositeAmountBound` are configured as below:
     * | ---------------------------------------------------|---------------------------- |
     * | Action  | isBuy   | isB2Q  | Exact In / Out        | Opposite Bound Description  |
     * | ------- |-------- |--------|-----------------------|---------------------------- |
     * | Buy     |  true   | false  | exact output (false)  | Max quote to pay            |
     * | Sell    |  false  | true   | exact input (true)    | Min quote to receive        |
     * |----------------------------------------------------|---------------------------- |
     *
     * @param _actionInfo  ActionInfo object
     * @return uint256     The base position delta resulting from the trade
     * @return uint256     The quote asset position delta resulting from the trade
     */
    function _executeTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {

        // When isBaseToQuote is true, `baseToken` is being sold, when false, bought
        // When isExactInput is true, `amount` is the swap input, when false, the swap output
        IClearingHouse.OpenPositionParams memory params = IClearingHouse.OpenPositionParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            oppositeAmountBound: _actionInfo.oppositeAmountBound,
            deadline: PreciseUnitMath.maxUint256(),
            sqrtPriceLimitX96: 0,
            referralCode: bytes32(0)
        });

        return _actionInfo.setToken.invokeOpenPosition(perpClearingHouse, params);
    }


    /**
     * @dev Formats Perp Periphery Quoter.swap call and executes via SetToken (and PerpV2 lib)
     *
     * See _executeTrade method comments for details about `isBaseToQuote` and `isExactInput` configuration.
     *
     * @param _actionInfo   ActionInfo object
     * @return uint256      The base position delta resulting from the trade
     * @return uint256      The quote asset position delta resulting from the trade
     */
    function _simulateTrade(ActionInfo memory _actionInfo) internal returns (uint256, uint256) {
        IQuoter.SwapParams memory params = IQuoter.SwapParams({
            baseToken: _actionInfo.baseToken,
            isBaseToQuote: !_actionInfo.isBuy,
            isExactInput: !_actionInfo.isBuy,
            amount: _actionInfo.baseTokenAmount,
            sqrtPriceLimitX96: 0
        });

        IQuoter.SwapResponse memory swapResponse = _actionInfo.setToken.invokeSwap(perpQuoter, params);
        return (swapResponse.deltaAvailableBase, swapResponse.deltaAvailableQuote);
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     *
     * @param  _setToken            Instance of SetToken
     * @param  _exchangedQuantity   Notional quantity of USDC exchanged in trade (e.g deltaQuote)
     * @return uint256              Total protocol fee paid in underlying collateral decimals e.g (USDC = 6)
     */
    function _accrueProtocolFee(
        ISetToken _setToken,
        uint256 _exchangedQuantity
    )
        internal
        returns(uint256)
    {
        uint256 protocolFee = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        uint256 protocolFeeInPreciseUnits = protocolFee.fromPreciseUnitToDecimals(collateralDecimals);

        _withdraw(_setToken, protocolFeeInPreciseUnits);

        payProtocolFeeFromSetToken(_setToken, address(collateralToken), protocolFeeInPreciseUnits);

        return protocolFeeInPreciseUnits;
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes POSITION UNIT amounts and passes to
     *  _createActionInfoNotional to create the struct. If the _baseTokenQuantity is zero then revert. If
     * the _baseTokenQuantity = -(baseBalance/setSupply) then close the position entirely. This method is
     * only called from `trade` - the issue/redeem flow uses createActionInfoNotional directly.
     *
     * @param _setToken             Instance of the SetToken
     * @param _baseToken            Address of base token being traded into/out of
     * @param _baseQuantityUnits    Quantity of baseToken to trade in PositionUnits
     * @param _quoteReceiveUnits    Quantity of quote to receive if selling base and pay if buying, in PositionUnits
     *
     * @return ActionInfo           Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseQuantityUnits,
        uint256 _quoteReceiveUnits
    )
        internal
        view
        returns(ActionInfo memory)
    {
        require(_baseQuantityUnits != 0, "Amount is 0");
        require(perpMarketRegistry.hasPool(_baseToken), "Base token does not exist");

        uint256 totalSupply = _setToken.totalSupply();

        int256 baseBalance = perpAccountBalance.getBase(address(_setToken), _baseToken);
        int256 basePositionUnit = baseBalance.preciseDiv(totalSupply.toInt256());

        int256 baseNotional = _baseQuantityUnits == basePositionUnit.neg()
            ? baseBalance.neg()         // To close position completely
            : _baseQuantityUnits.preciseMul(totalSupply.toInt256());

        return _createActionInfoNotional(
            _setToken,
            _baseToken,
            baseNotional,
            _quoteReceiveUnits.preciseMul(totalSupply)
        );
    }

    /**
     * @dev Construct the ActionInfo struct for trading. This method takes NOTIONAL token amounts and creates
     * the struct. If the _baseTokenQuantity is greater than zero then we are buying the baseToken. This method
     * is called during issue and redeem via `_executePositionTrades` and during trade via `_createAndValidateActionInfo`.
     *
     * (See _executeTrade method comments for details about `oppositeAmountBound` configuration)
     *
     * @param _setToken                 Instance of the SetToken
     * @param _baseToken                Address of base token being traded into/out of
     * @param _baseTokenQuantity        Notional quantity of baseToken to trade
     * @param _quoteReceiveQuantity     Notional quantity of quote to receive if selling base and pay if buying
     *
     * @return ActionInfo               Instance of constructed ActionInfo struct
     */
    function _createActionInfoNotional(
        ISetToken _setToken,
        address _baseToken,
        int256 _baseTokenQuantity,
        uint256 _quoteReceiveQuantity
    )
        internal
        pure
        returns(ActionInfo memory)
    {
        // NOT checking that _baseTokenQuantity != 0 here because for places this is directly called
        // (issue/redeem hooks) we know the position cannot be 0. We check in _createAndValidateActionInfo
        // that quantity is 0 for inputs to trade.
        bool isBuy = _baseTokenQuantity > 0;

        return ActionInfo({
            setToken: _setToken,
            baseToken: _baseToken,
            isBuy: isBuy,
            baseTokenAmount: _baseTokenQuantity.abs(),
            oppositeAmountBound: _quoteReceiveQuantity
        });
    }

    /**
     * @dev Update position address array if a token has been newly added or completely sold off
     * during lever/delever
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     */
    function _updatePositionList(ISetToken _setToken, address _baseToken) internal {
        address[] memory positionList = positions[_setToken];
        bool hasBaseToken = positionList.contains(_baseToken);

        if (hasBaseToken) {
            if(!_hasBaseBalance(_setToken, _baseToken)) {
                positions[_setToken].removeStorage(_baseToken);
            }
        } else {
            require(positions[_setToken].length < maxPerpPositionsPerSet, "Exceeds max perpetual positions per set");
            positions[_setToken].push(_baseToken);
        }
    }

    /**
     * @dev Removes any zero balance positions from the positions array. This
     * sync is done before issuance and redemption to account for positions that may have
     * been liquidated.
     *
     * @param _setToken         Instance of the SetToken
     */
    function _syncPositionList(ISetToken _setToken) internal {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            address currPosition = positionList[i];
            if (!_hasBaseBalance(_setToken, currPosition)) {
                positions[_setToken].removeStorage(currPosition);
            }
        }
    }

    /**
     * @dev Checks to see if we can make 1 positionUnit worth of a baseToken position, if not we consider the Set to have
     * no balance and return false
     *
     * @param _setToken     Instance of SetToken
     * @param _baseToken    Address of virtual base token
     * @return bool         True if a non-dust base token balance exists, false otherwise
     */
    function _hasBaseBalance(ISetToken _setToken, address _baseToken) internal view returns(bool) {
        int256 baseBalanceUnit = perpAccountBalance
            .getBase(address(_setToken), _baseToken)
            .preciseDiv(_setToken.totalSupply().toInt256());

        return (baseBalanceUnit > 1) || (baseBalanceUnit < -1);
    }

    /**
     * @dev Gets the mid-point price of a virtual asset from UniswapV3 markets maintained by Perp Protocol
     *
     * @param  _baseToken           Address of virtual token to price
     * @return price                Mid-point price of virtual token in UniswapV3 AMM market
     */
    function _calculateAMMSpotPrice(address _baseToken) internal view returns (uint256 price) {
        address pool = perpMarketRegistry.getPool(_baseToken);
        (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
        uint256 priceX96 = sqrtPriceX96.formatSqrtPriceX96ToPriceX96();
        return priceX96.formatX96ToX10_18();
    }

    /**
     * @dev Calculates the sum of collateralToken denominated market-prices of assets and debt for the Perp account per
     * SetToken
     *
     * @param _setToken     Instance of SetToken
     * @return int256       External position unit
     */
    function _calculateExternalPositionUnit(ISetToken _setToken) internal view returns (int256) {
        PositionNotionalInfo[] memory positionInfo = getPositionNotionalInfo(_setToken);
        uint256 positionLength = positionInfo.length;
        int256 totalPositionValue = 0;

        for (uint i = 0; i < positionLength; i++ ) {
            int256 spotPrice = _calculateAMMSpotPrice(positionInfo[i].baseToken).toInt256();
            totalPositionValue = totalPositionValue.add(
                positionInfo[i].baseBalance.preciseMul(spotPrice)
            );
        }

        int256 externalPositionUnitInPreciseUnits = _calculatePartialAccountValuePositionUnit(_setToken)
            .add(totalPositionValue.preciseDiv(_setToken.totalSupply().toInt256()));

        return externalPositionUnitInPreciseUnits.fromPreciseUnitToDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves collateral balance as an 18 decimal vUSDC quote value
     *
     * @param _setToken     Instance of SetToken
     * @return int256       Collateral balance as an 18 decimal vUSDC quote value
     */
    function _getCollateralBalance(ISetToken _setToken) internal view returns (int256) {
        return perpVault.getBalance(address(_setToken)).toPreciseUnitsFromDecimals(collateralDecimals);
    }

    /**
     * @dev Retrieves net quote balance of all open positions
     *
     * @param _setToken             Instance of SetToken
     * @return netQuoteBalance      Net quote balance of all open positions
     */
    function _getNetQuoteBalance(ISetToken _setToken) internal view returns (int256 netQuoteBalance) {
        address[] memory positionList = positions[_setToken];
        uint256 positionLength = positionList.length;

        for (uint256 i = 0; i < positionLength; i++) {
            netQuoteBalance = netQuoteBalance.add(
                perpAccountBalance.getQuote(address(_setToken), positionList[i])
            );
        }
    }

    /**
     * @dev Returns issuance or redemption adjustments in the format expected by `SlippageIssuanceModule`.
     * The last recorded externalPositionUnit (current) is subtracted from a dynamically generated
     * externalPositionUnit (new) and set in an `equityAdjustments` array which is the same length as
     * the SetToken's components array, at the same index the collateral token occupies in the components
     * array. All other values are left unset (0). An empty-value components length debtAdjustments
     * array is also returned.
     *
     * @param _setToken                         Instance of the SetToken
     * @param _components                       Array of components held by the SetToken
     * @param _newExternalPositionUnit          Dynamically calculated externalPositionUnit
     * @return int256[]                         Components-length array with equity adjustment value at appropriate index
     * @return int256[]                         Components-length array of zeroes (debt adjustments)
     */
    function _formatAdjustments(
        ISetToken _setToken,
        address[] memory _components,
        int256 _newExternalPositionUnit
    )
        internal
        view
        returns (int256[] memory, int256[] memory)
    {
        int256[] memory equityAdjustments = new int256[](_components.length);
        int256[] memory debtAdjustments = new int256[](_components.length);

        (uint256 index, bool isIn) = _components.indexOf(address(collateralToken));

        if (isIn) {
            int256 currentExternalPositionUnit = _setToken.getExternalPositionRealUnit(
                address(collateralToken),
                address(this)
            );

            equityAdjustments[index] = _newExternalPositionUnit.sub(currentExternalPositionUnit);
        }

        return (equityAdjustments, debtAdjustments);
    }
}".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

